1
00:00:00,000 --> 00:00:15,314


2
00:00:15,314 --> 00:00:17,579
PROFESSOR: Well today we're
going to learn about something

3
00:00:17,579 --> 00:00:18,409
quite amazing.

4
00:00:18,410 --> 00:00:22,949
We're going to understand what
we mean by a program a little

5
00:00:22,949 --> 00:00:26,800
bit more profoundly than
we have up till now.

6
00:00:26,800 --> 00:00:30,650
Up till now, we've been thinking
of programs as

7
00:00:30,649 --> 00:00:32,728
describing machines.

8
00:00:32,728 --> 00:00:38,799
So for example, looking at this
still store, we see here

9
00:00:38,799 --> 00:00:42,799
is a program for factorial.

10
00:00:42,799 --> 00:00:46,969
And what it is, is a character
string description, if you

11
00:00:46,969 --> 00:00:49,519
will, of the wiring
diagram of a

12
00:00:49,520 --> 00:00:52,230
potentially infinite machine.

13
00:00:52,229 --> 00:00:53,869
And we can look at that
a little bit and

14
00:00:53,869 --> 00:00:55,129
just see the idea.

15
00:00:55,130 --> 00:00:58,950
That this is a sort of compact
notation which says, if n is

16
00:00:58,950 --> 00:01:00,170
0, the result is one.

17
00:01:00,170 --> 00:01:03,800
Well here comes n coming into
this machine, and if it's 0,

18
00:01:03,799 --> 00:01:06,719
then I control this switch in
such a way that the switch

19
00:01:06,719 --> 00:01:09,340
allows the output to be one.

20
00:01:09,340 --> 00:01:12,969
Otherwise, it's n times
factorial of n minus one.

21
00:01:12,969 --> 00:01:15,920
Well, I'm computing factorial of
n minus one and multiplying

22
00:01:15,920 --> 00:01:19,350
that by n, and, in the case that
it's not 0, this switch

23
00:01:19,349 --> 00:01:21,899
makes the output come
from there.

24
00:01:21,900 --> 00:01:24,460
Of course, this is a machine
with a potentially infinite

25
00:01:24,459 --> 00:01:27,299
number of parts, because
factorial occurs within

26
00:01:27,299 --> 00:01:31,069
factorial, so we don't know
how deep it has to be.

27
00:01:31,069 --> 00:01:36,479
But that's basically what our
notation for programs really

28
00:01:36,480 --> 00:01:38,310
means to us at this point.

29
00:01:38,310 --> 00:01:41,810
It's a character string
description, if you will, of a

30
00:01:41,810 --> 00:01:44,900
wiring diagram that could also
be drawn some other way.

31
00:01:44,900 --> 00:01:47,520
And, in fact, many people have
proposed to me, programming

32
00:01:47,519 --> 00:01:49,489
languages look graphical
like this.

33
00:01:49,489 --> 00:01:51,500
I'm not sure I believe there
are many advantages.

34
00:01:51,500 --> 00:01:54,469
The major disadvantage, of
course, is that it takes up

35
00:01:54,469 --> 00:01:57,359
more space on a page, and,
therefore, it's harder to pack

36
00:01:57,359 --> 00:02:01,090
into a listing or to
edit very well.

37
00:02:01,090 --> 00:02:05,299
But in any case, there's
something very remarkable that

38
00:02:05,299 --> 00:02:08,810
can happen in the competition
world which is that you can

39
00:02:08,810 --> 00:02:10,449
have something called
a universal machine.

40
00:02:10,449 --> 00:02:18,339
If we look at the second
slide, what we see is a

41
00:02:18,340 --> 00:02:21,259
special machine called eval.

42
00:02:21,259 --> 00:02:23,669
There is a machine called eval,
and I'm going to show it

43
00:02:23,669 --> 00:02:25,719
to you today.

44
00:02:25,719 --> 00:02:27,780
It's very simple.

45
00:02:27,780 --> 00:02:30,490
What is remarkable is that it
will fit on the blackboard.

46
00:02:30,490 --> 00:02:33,350


47
00:02:33,349 --> 00:02:38,310
However, eval is a machine
which takes as input a

48
00:02:38,310 --> 00:02:40,449
description of another
machine.

49
00:02:40,449 --> 00:02:42,619
It could take the wiring
diagram of a

50
00:02:42,620 --> 00:02:46,490
factorial machine as input.

51
00:02:46,490 --> 00:02:52,020
Having done so, it becomes a
simulator for the factorial

52
00:02:52,020 --> 00:02:58,909
machine such that, if you put
a six in, out comes a 720.

53
00:02:58,909 --> 00:03:02,129
That's a very remarkable
sort of machine.

54
00:03:02,129 --> 00:03:04,560
And the most amazing part of
it is that it fits on a

55
00:03:04,560 --> 00:03:05,590
blackboard.

56
00:03:05,590 --> 00:03:10,069
By contrast, one could imagine
in the analog electronics

57
00:03:10,069 --> 00:03:17,180
world a very different machine,
a machine which also

58
00:03:17,180 --> 00:03:20,439
was, in some sense, universal,
where you gave a circuit

59
00:03:20,439 --> 00:03:24,829
diagram as one of the inputs,
for example, of this little

60
00:03:24,830 --> 00:03:28,050
low-pass filter, one-pole
low-pass filter.

61
00:03:28,050 --> 00:03:30,230
And you can imagine that
you could, for

62
00:03:30,229 --> 00:03:32,030
example, scan this out--

63
00:03:32,030 --> 00:03:37,949
the scan lines are the signal
that's describing what this

64
00:03:37,949 --> 00:03:40,769
machine is to simulate--

65
00:03:40,770 --> 00:03:43,040
then the analog of that which
is made out of electrical

66
00:03:43,039 --> 00:03:45,539
circuits, should configure
itself into a filter that has

67
00:03:45,539 --> 00:03:47,009
the frequency response
specified

68
00:03:47,009 --> 00:03:49,889
by the circuit diagram.

69
00:03:49,889 --> 00:03:52,519
That's a very hard machine to
make, and, surely, there's no

70
00:03:52,520 --> 00:03:55,670
chance that I could put
it on a blackboard.

71
00:03:55,669 --> 00:03:58,429
So we're going to see an
amazing thing today.

72
00:03:58,430 --> 00:04:01,240
We're going to see,
on the blackboard,

73
00:04:01,240 --> 00:04:02,790
the universal machine.

74
00:04:02,789 --> 00:04:06,780
And we'll see that among other
things, it's extremely simple.

75
00:04:06,780 --> 00:04:10,069
Now, we're getting very close
to the real spirit in the

76
00:04:10,069 --> 00:04:11,280
computer at this point.

77
00:04:11,280 --> 00:04:14,110
So I have to show a certain
amount of reverence and

78
00:04:14,110 --> 00:04:16,970
respect, so I'm going to wear
a suit jacket for the only

79
00:04:16,970 --> 00:04:20,470
time that you'll ever see me
wear a suit jacket here.

80
00:04:20,470 --> 00:04:25,730
And I think I'm also going to
put on an appropriate hat for

81
00:04:25,730 --> 00:04:26,980
the occasion.

82
00:04:26,980 --> 00:04:28,780


83
00:04:28,779 --> 00:04:31,389
Now, this is a lecturer which
I have to warn you--

84
00:04:31,389 --> 00:04:34,139


85
00:04:34,139 --> 00:04:37,689
let's see, normally, people
under 40 and who don't have

86
00:04:37,689 --> 00:04:40,370
several children are advised
to be careful.

87
00:04:40,370 --> 00:04:44,170
If they're really worried, they
should leave. Because

88
00:04:44,170 --> 00:04:46,890
there's a certain amount of
mysticism that will appear

89
00:04:46,889 --> 00:04:50,139
here which may be disturbing
and cause

90
00:04:50,139 --> 00:04:51,819
trouble in your minds.

91
00:04:51,819 --> 00:04:57,300
Well in any case, let's see,
I wish to write for you the

92
00:04:57,300 --> 00:05:02,509
evaluator for Lisp.

93
00:05:02,509 --> 00:05:05,019
Now the evaluator isn't
very complicated.

94
00:05:05,019 --> 00:05:08,240
It's very much like all the
programs we've seen already.

95
00:05:08,240 --> 00:05:10,860
That's the amazing part of it.

96
00:05:10,860 --> 00:05:15,370
It's going to be-- and I'm going
to write it right here--

97
00:05:15,370 --> 00:05:16,620
it's a program called eval.

98
00:05:16,620 --> 00:05:22,899


99
00:05:22,899 --> 00:05:28,779
And it's a procedure of two
arguments in expression of an

100
00:05:28,779 --> 00:05:30,029
environment.

101
00:05:30,029 --> 00:05:31,859


102
00:05:31,860 --> 00:05:33,129
And like every interesting

103
00:05:33,129 --> 00:05:34,939
procedure, it's a case analysis.

104
00:05:34,939 --> 00:05:40,459


105
00:05:40,459 --> 00:05:44,209
But before I start on this, I
want to tell you some things.

106
00:05:44,209 --> 00:05:46,879
The program we're going to write
on the blackboard is

107
00:05:46,879 --> 00:05:52,449
ugly, dirty, disgusting, not the
way I would write this is

108
00:05:52,449 --> 00:05:54,209
a professional.

109
00:05:54,209 --> 00:05:57,939
It is written with concrete
syntax, meaning you've got

110
00:05:57,939 --> 00:05:59,629
really to use lots of CARs and
CDRs which is exactly what I

111
00:05:59,629 --> 00:06:02,550
told you not to do.

112
00:06:02,550 --> 00:06:07,180
That's on purpose in this case,
because I want it to be

113
00:06:07,180 --> 00:06:11,009
small, compact, fit on the
blackboard so you can get the

114
00:06:11,009 --> 00:06:12,420
whole thing.

115
00:06:12,420 --> 00:06:15,800
So I don't want to use long
names like I normally use.

116
00:06:15,800 --> 00:06:19,579
I want to use CAR-CDR
because it's short.

117
00:06:19,579 --> 00:06:20,949
Now, that's a trade-off.

118
00:06:20,949 --> 00:06:23,569
I don't want you writing
programs like this.

119
00:06:23,569 --> 00:06:26,089
This is purely for an effect.

120
00:06:26,089 --> 00:06:27,529
Now, you're going to have to
work a little harder to read

121
00:06:27,529 --> 00:06:29,269
it, but I'm going to try
to make it clear

122
00:06:29,269 --> 00:06:31,269
as I'm writing it.

123
00:06:31,269 --> 00:06:32,394
I'm also--

124
00:06:32,394 --> 00:06:34,959
this is a pretty much complete
interpreter, but there's going

125
00:06:34,959 --> 00:06:36,289
to be room for putting
in more things--

126
00:06:36,290 --> 00:06:39,160
I'm going to leave out
definition and assignment,

127
00:06:39,160 --> 00:06:45,310
just because they are not
essential, for a mathematical

128
00:06:45,310 --> 00:06:51,670
reason I'll show you later and
also they take up more space.

129
00:06:51,670 --> 00:06:54,170
But, in any case, what
do we have to do?

130
00:06:54,170 --> 00:06:57,160
We have to do a dispatch which
breaks the types of

131
00:06:57,160 --> 00:07:02,030
expressions up into particular
classes.

132
00:07:02,029 --> 00:07:03,524
So that's what we're
going to have here.

133
00:07:03,524 --> 00:07:05,149
Well, what expressions
are there?

134
00:07:05,149 --> 00:07:06,810
Let's look at the kinds
of expressions.

135
00:07:06,810 --> 00:07:10,420
We can have things like
the numeral three.

136
00:07:10,420 --> 00:07:12,720
What do I want that to do?

137
00:07:12,720 --> 00:07:15,640
I can make choices, but I think
right now, I want it to

138
00:07:15,639 --> 00:07:17,050
be a three.

139
00:07:17,050 --> 00:07:18,860
That's what I want.

140
00:07:18,860 --> 00:07:19,800
So that's easy enough.

141
00:07:19,800 --> 00:07:27,520
That means I want, if the
thing is a number, the

142
00:07:27,519 --> 00:07:30,719
expression, that I want
the expression

143
00:07:30,720 --> 00:07:31,970
itself as the answer.

144
00:07:31,970 --> 00:07:35,420


145
00:07:35,420 --> 00:07:37,699
Now the next possibility
is things that we

146
00:07:37,699 --> 00:07:39,389
represent as symbols.

147
00:07:39,389 --> 00:07:47,613
Examples of symbols are things
like x, n, eval, number, x.

148
00:07:47,613 --> 00:07:49,629
What do I mean them to be?

149
00:07:49,629 --> 00:07:51,689
Those are things that stand
for other things.

150
00:07:51,689 --> 00:07:54,769
Those are the variables
of our language.

151
00:07:54,769 --> 00:07:58,539
And so I want to be able to say,
for example, that x, for

152
00:07:58,540 --> 00:08:02,930
example, transforms to it's
value which might be three.

153
00:08:02,930 --> 00:08:07,920
Or I might ask something
like car.

154
00:08:07,920 --> 00:08:09,710
I want to have as its value--

155
00:08:09,709 --> 00:08:17,379
be something like some
procedure, which I don't know

156
00:08:17,379 --> 00:08:20,439
what is inside there, perhaps
a machine language code or

157
00:08:20,439 --> 00:08:23,100
something like that.

158
00:08:23,100 --> 00:08:24,430
So, well, that's easy enough.

159
00:08:24,430 --> 00:08:27,889
I'm going to push that
off on someone else.

160
00:08:27,889 --> 00:08:33,370
If something is a symbol, if
the expression is a symbol,

161
00:08:33,370 --> 00:08:38,139
then I want the answer to be
the result, looking up the

162
00:08:38,139 --> 00:08:40,158
expression in the environment.

163
00:08:40,158 --> 00:08:46,480


164
00:08:46,480 --> 00:08:52,409
Now the environment is a
dictionary which maps the

165
00:08:52,409 --> 00:08:54,059
symbol names to their values.

166
00:08:54,059 --> 00:08:56,279
And that's all it is.

167
00:08:56,279 --> 00:08:57,529
How it's done?

168
00:08:57,529 --> 00:08:59,759
Well, we'll see that later.

169
00:08:59,759 --> 00:09:01,669
It's very easy.

170
00:09:01,669 --> 00:09:03,629
It's easy to make data
structures that are tables of

171
00:09:03,629 --> 00:09:04,669
various sorts.

172
00:09:04,669 --> 00:09:07,079
But it's only a table, and this
is the access routine for

173
00:09:07,080 --> 00:09:10,040
some table.

174
00:09:10,039 --> 00:09:12,719
Well, the next thing, another
kind of expression--

175
00:09:12,720 --> 00:09:14,870
you have things that are
described constants that are

176
00:09:14,870 --> 00:09:17,429
not numbers, like 'foo.

177
00:09:17,429 --> 00:09:20,169


178
00:09:20,169 --> 00:09:22,449
Well, for my convenience,
I want to syntactically

179
00:09:22,450 --> 00:09:31,520
transform that into a list
structure which is, quote foo.

180
00:09:31,519 --> 00:09:35,139


181
00:09:35,139 --> 00:09:39,949
A quoted object, whatever it is,
is going to be actually an

182
00:09:39,950 --> 00:09:43,550
abbreviation, which is not
part of the evaluator but

183
00:09:43,549 --> 00:09:46,959
happens somewhere else, an
abbreviation for an expression

184
00:09:46,960 --> 00:09:48,780
that looks like this.

185
00:09:48,779 --> 00:09:52,120
This way, I can test for the
type of the expression as

186
00:09:52,120 --> 00:09:55,615
being a quotation by examining
the car of the expression.

187
00:09:55,615 --> 00:09:58,460


188
00:09:58,460 --> 00:10:01,650
So I'm not going to worry about
that in the evaluator.

189
00:10:01,649 --> 00:10:02,779
It's happening somewhere
earlier in

190
00:10:02,779 --> 00:10:05,539
the reader or something.

191
00:10:05,539 --> 00:10:18,620
If the expression of the
expression is quote, then what

192
00:10:18,620 --> 00:10:25,139
I want, I want quote foo to
itself evaluate to foo.

193
00:10:25,139 --> 00:10:27,529
It's a constant.

194
00:10:27,529 --> 00:10:30,644
This is just a way of saying
that this evaluates to itself.

195
00:10:30,644 --> 00:10:33,149


196
00:10:33,149 --> 00:10:33,659
What is that?

197
00:10:33,659 --> 00:10:37,329
That's the second of the list.
It's the second element of the

198
00:10:37,330 --> 00:10:41,604
list. The second element of the
list is it's CADR. So I'm

199
00:10:41,604 --> 00:10:51,290
just going to write
here, CADR.

200
00:10:51,289 --> 00:10:52,509
What else do we have here?

201
00:10:52,509 --> 00:10:56,039
We have lambda expressions,
for example,

202
00:10:56,039 --> 00:11:04,159
lambda of x plus x y.

203
00:11:04,159 --> 00:11:05,909
Well, I going have to have some
representation for the

204
00:11:05,909 --> 00:11:08,610
procedure which is the value of
an expression, of a lambda

205
00:11:08,610 --> 00:11:09,600
expression.

206
00:11:09,600 --> 00:11:13,029
The procedure here is not
the expression lambda x.

207
00:11:13,029 --> 00:11:16,169
That's the description of it,
the textual description.

208
00:11:16,169 --> 00:11:18,799
However, what what I going
to expect to see here is

209
00:11:18,799 --> 00:11:20,929
something which contains an
environment as one of its

210
00:11:20,929 --> 00:11:27,359
parts if I'm implementing
a lexical language.

211
00:11:27,360 --> 00:11:30,789
And so what I'd like to see
is some type flags.

212
00:11:30,789 --> 00:11:33,439
I'm going to have to be able
to distinguish procedures

213
00:11:33,440 --> 00:11:37,190
later, procedures which were
produced by lambdas, from ones

214
00:11:37,190 --> 00:11:39,060
that may be primitive.

215
00:11:39,059 --> 00:11:42,439
And so I'm going to have some
flag, which I'll just

216
00:11:42,440 --> 00:11:44,935
arbitrarily call closure, just
for historical reasons.

217
00:11:44,934 --> 00:11:47,759


218
00:11:47,759 --> 00:11:49,919
Now, to say what parts of
this are important.

219
00:11:49,919 --> 00:11:51,969
I'm going to need to know
the bound variable

220
00:11:51,970 --> 00:11:54,220
list and the body.

221
00:11:54,220 --> 00:12:00,870
Well, that's the CDR of this, so
it's going to be x and plus

222
00:12:00,870 --> 00:12:03,794
x y and some environment.

223
00:12:03,794 --> 00:12:08,169


224
00:12:08,169 --> 00:12:13,979
Now this is not something that
users should ever see, this is

225
00:12:13,980 --> 00:12:16,680
purely a representation,
internally,

226
00:12:16,679 --> 00:12:18,519
for a procedure object.

227
00:12:18,519 --> 00:12:22,009
It contains a bound variable
list, a body, and an

228
00:12:22,009 --> 00:12:26,340
environment, and some type tag
saying, I am a procedure.

229
00:12:26,340 --> 00:12:28,080
I'm going to make one now.

230
00:12:28,080 --> 00:12:43,720
So if the CAR of the expression
is quote lambda,

231
00:12:43,720 --> 00:12:45,970
then what I'm going
to put here is--

232
00:12:45,970 --> 00:12:58,860
I'm going to make a list of
closure, the CDR of the

233
00:12:58,860 --> 00:13:07,519
procedure description was
everything except the lambda,

234
00:13:07,519 --> 00:13:10,250
and the current environment.

235
00:13:10,250 --> 00:13:14,470
This implements the rule
for environments in the

236
00:13:14,470 --> 00:13:15,190
environment model.

237
00:13:15,190 --> 00:13:17,980
It has to do with construction
of procedures from lambda

238
00:13:17,980 --> 00:13:19,210
expressions.

239
00:13:19,210 --> 00:13:22,180
The environment that was
around at the time the

240
00:13:22,179 --> 00:13:25,939
evaluator encountered the
lambda expression is the

241
00:13:25,940 --> 00:13:30,990
environment where the procedure
resulting interprets

242
00:13:30,990 --> 00:13:32,240
it's free variables.

243
00:13:32,240 --> 00:13:34,720


244
00:13:34,720 --> 00:13:35,920
So that's part of that.

245
00:13:35,919 --> 00:13:38,120
And so we have to capture that
environment as part of the

246
00:13:38,120 --> 00:13:39,210
procedure object.

247
00:13:39,210 --> 00:13:41,750
And we'll see how that
gets used later.

248
00:13:41,750 --> 00:13:45,139
There are also conditional
expressions of things like

249
00:13:45,139 --> 00:13:54,519
COND of say, p one, e
one, p two, e two.

250
00:13:54,519 --> 00:13:57,669
Where this is a predicate, a
predicate is a thing that is

251
00:13:57,669 --> 00:14:00,929
either true or false, and the
expression to be evaluated if

252
00:14:00,929 --> 00:14:03,479
the predicate is true.

253
00:14:03,480 --> 00:14:05,515
A set of clauses, if you
will, that's the

254
00:14:05,515 --> 00:14:06,789
name for such a thing.

255
00:14:06,789 --> 00:14:09,360
So I'm going put that
somewhere else.

256
00:14:09,360 --> 00:14:12,419
We're going to worry about that
in another piece of code.

257
00:14:12,419 --> 00:14:13,669
So EQ--

258
00:14:13,669 --> 00:14:15,899


259
00:14:15,899 --> 00:14:24,709
if the CAR of the expression is
COND, then I'm going to do

260
00:14:24,710 --> 00:14:30,800
nothing more than evaluate
the COND, the CDR of the

261
00:14:30,799 --> 00:14:32,049
expression.

262
00:14:32,049 --> 00:14:34,079


263
00:14:34,080 --> 00:14:38,379
That's all the clauses in the
environment that I'm given.

264
00:14:38,379 --> 00:14:41,429


265
00:14:41,429 --> 00:14:46,479
Well, there's one more case,
arbitrary thing like the sum

266
00:14:46,480 --> 00:14:53,379
of x and three, where this
is an operator applied to

267
00:14:53,379 --> 00:14:56,590
operands, and there's nothing
special about it.

268
00:14:56,590 --> 00:14:59,850
It's not one of the special
cases, the special forms.

269
00:14:59,850 --> 00:15:09,649
These are the special forms.

270
00:15:09,649 --> 00:15:12,480
And if I were writing here a
professional program, again, I

271
00:15:12,480 --> 00:15:14,370
would somehow make this
data directed.

272
00:15:14,370 --> 00:15:16,690
So there wouldn't be a sequence
of conditionals here,

273
00:15:16,690 --> 00:15:20,290
there'd be a dispatch on some
bits if I were trying to do

274
00:15:20,289 --> 00:15:22,360
this in a more professional
way.

275
00:15:22,360 --> 00:15:25,750
So that, in fact, I can add to
the thing without changing my

276
00:15:25,750 --> 00:15:26,710
program much.

277
00:15:26,710 --> 00:15:29,850
So, for example, they would run
fast, but I'm not worried

278
00:15:29,850 --> 00:15:31,279
about that.

279
00:15:31,279 --> 00:15:34,889
Here we're trying to look
at this in its entirety.

280
00:15:34,889 --> 00:15:37,360
So it's else.

281
00:15:37,360 --> 00:15:38,560
Well, what do we do?

282
00:15:38,559 --> 00:15:40,964
In this case, I have to somehow
do an addition.

283
00:15:40,965 --> 00:15:44,350


284
00:15:44,350 --> 00:15:46,565
Well, I could find out
what the plus is.

285
00:15:46,565 --> 00:15:50,550
I have to find out what the
x and the three are.

286
00:15:50,549 --> 00:15:53,329
And then I have to apply the
result of finding what the

287
00:15:53,330 --> 00:15:56,360
plus is to the result of
finding out what the x

288
00:15:56,360 --> 00:15:58,019
and the three are.

289
00:15:58,019 --> 00:15:59,829
We'll have a name for that.

290
00:15:59,830 --> 00:16:11,280
So I'm going to apply the result
of evaluating the CAR

291
00:16:11,279 --> 00:16:13,269
of the expression--

292
00:16:13,269 --> 00:16:17,210
the car of the expression
is the operator--

293
00:16:17,210 --> 00:16:20,480
in the environment given.

294
00:16:20,480 --> 00:16:24,050
So evaluating the operator
gets me the procedure.

295
00:16:24,049 --> 00:16:27,289
Now I have to evaluate all the
operands to get the arguments.

296
00:16:27,289 --> 00:16:34,709
I'll call that EVLIST, the CDR
of the operands, of the

297
00:16:34,710 --> 00:16:38,835
expression, with respect
to the environment.

298
00:16:38,835 --> 00:16:41,940


299
00:16:41,940 --> 00:16:43,290
EVLIST will come up later--

300
00:16:43,289 --> 00:16:48,069
EVLIST, apply, COND pair,
COND, lambda, define.

301
00:16:48,070 --> 00:16:50,900


302
00:16:50,899 --> 00:16:53,629
So that what you are seeing here
now is pretty much all

303
00:16:53,629 --> 00:16:56,590
there is in the evaluator
itself.

304
00:16:56,590 --> 00:17:01,370
It's the case dispatch on the
type of the expression with

305
00:17:01,370 --> 00:17:07,470
the default being a general
application or a combination.

306
00:17:07,470 --> 00:17:17,519


307
00:17:17,519 --> 00:17:20,088
Now there is lots of things
we haven't defined yet.

308
00:17:20,088 --> 00:17:21,779
Let's just look at them
and see what they are.

309
00:17:21,779 --> 00:17:25,480
We're going to have to do
this later, evcond.

310
00:17:25,480 --> 00:17:27,578
We have to write apply.

311
00:17:27,578 --> 00:17:29,119
We're going to have to
write EVLIST. We're

312
00:17:29,119 --> 00:17:31,789
going to write LOOKUP.

313
00:17:31,789 --> 00:17:33,430
I think that's everything,
isn't there?

314
00:17:33,430 --> 00:17:35,860
Everything else is something
which is simple, or primitive,

315
00:17:35,859 --> 00:17:38,569
or something like that.

316
00:17:38,569 --> 00:17:42,359
And, of course, we could many
more special forms here, but

317
00:17:42,359 --> 00:17:44,449
that would be a bad idea in
general in a language.

318
00:17:44,450 --> 00:17:46,730
You make a language very
complicated by putting a lot

319
00:17:46,730 --> 00:17:47,690
of things in there.

320
00:17:47,690 --> 00:17:49,830
The number of reserve words
that should exist in a

321
00:17:49,829 --> 00:17:52,539
language should be no more than
a person could remember

322
00:17:52,539 --> 00:17:54,009
on his fingers and toes.

323
00:17:54,009 --> 00:17:56,819
And I get very upset with
languages which have hundreds

324
00:17:56,819 --> 00:17:59,409
of reserve words.

325
00:17:59,410 --> 00:18:00,710
But that's where the
reserve words go.

326
00:18:00,710 --> 00:18:04,750


327
00:18:04,750 --> 00:18:06,430
Well, now let's get to
the next part of

328
00:18:06,430 --> 00:18:09,640
this, the kernel, apply.

329
00:18:09,640 --> 00:18:11,590
What else is this doing?

330
00:18:11,589 --> 00:18:17,019
Well, apply's job is to take a
procedure and apply it to its

331
00:18:17,019 --> 00:18:19,500
arguments after both have been
evaluated to come up with a

332
00:18:19,500 --> 00:18:22,559
procedure and the arguments
rather the operator symbols

333
00:18:22,559 --> 00:18:25,359
and the operand symbols,
whatever they are--

334
00:18:25,359 --> 00:18:26,609
symbolic expressions.

335
00:18:26,609 --> 00:18:33,269


336
00:18:33,269 --> 00:18:40,809
So we will define apply to be a
procedure of two arguments,

337
00:18:40,809 --> 00:18:43,279
a procedure and arguments.

338
00:18:43,279 --> 00:18:47,109


339
00:18:47,109 --> 00:18:48,079
And what does it do?

340
00:18:48,079 --> 00:18:49,720
It does nothing very
complicated.

341
00:18:49,720 --> 00:18:50,970
It's got two cases.

342
00:18:50,970 --> 00:18:53,579


343
00:18:53,579 --> 00:18:55,095
Either the procedure
is primitive--

344
00:18:55,095 --> 00:19:02,970


345
00:19:02,970 --> 00:19:06,930
And I don't know exactly
how that is done.

346
00:19:06,930 --> 00:19:10,930
It's possible there's some type
information just like we

347
00:19:10,930 --> 00:19:14,110
made closure for, here, being
the description of the type of

348
00:19:14,109 --> 00:19:16,809
a compound thing--

349
00:19:16,809 --> 00:19:18,549
probably so.

350
00:19:18,549 --> 00:19:21,359
But it is not essential how that
works, and, in fact, it

351
00:19:21,359 --> 00:19:24,139
turns out, as you probably know
or have deduced, that you

352
00:19:24,140 --> 00:19:27,350
don't need any primitives
anyway.

353
00:19:27,349 --> 00:19:30,731
You can compute anything without
them because some of

354
00:19:30,731 --> 00:19:33,190
the lambda that I've
been playing with.

355
00:19:33,190 --> 00:19:34,750
But it's nice to have them.

356
00:19:34,750 --> 00:19:36,630
So here we're going to do
some magic which I'm

357
00:19:36,630 --> 00:19:38,060
not going to explain.

358
00:19:38,059 --> 00:19:42,859
Go to machine language,
apply primop.

359
00:19:42,859 --> 00:19:44,849
Here's how it adds.

360
00:19:44,849 --> 00:19:46,099
Execute an add instruction.

361
00:19:46,099 --> 00:19:50,359


362
00:19:50,359 --> 00:19:52,839
However, the interesting part
of a language is the glue by

363
00:19:52,839 --> 00:19:54,939
which the predicates
are glued together.

364
00:19:54,940 --> 00:19:56,910
So let's look at that.

365
00:19:56,910 --> 00:20:01,210
Well, the other possibility is
that this is a compound made

366
00:20:01,210 --> 00:20:05,140
up by executing a lambda
expression, this

367
00:20:05,140 --> 00:20:07,620
is a compound procedure.

368
00:20:07,619 --> 00:20:10,109
Well, we'll check its type.

369
00:20:10,109 --> 00:20:23,009
If it is closure, if it's one of
those, then I have to do an

370
00:20:23,009 --> 00:20:24,500
eval of the body.

371
00:20:24,500 --> 00:20:28,960
The way I do this, the way I
deal with this at all, is the

372
00:20:28,960 --> 00:20:31,210
way I evaluate the application
of a procedure to its

373
00:20:31,210 --> 00:20:34,400
arguments, is by evaluating the
body of the procedure in

374
00:20:34,400 --> 00:20:37,050
the environment resulting from
extending the environment of

375
00:20:37,049 --> 00:20:39,669
the procedure with the bindings
of the formal

376
00:20:39,670 --> 00:20:43,009
parameters of the procedure
to the arguments that

377
00:20:43,009 --> 00:20:44,259
were passed to it.

378
00:20:44,259 --> 00:20:47,029


379
00:20:47,029 --> 00:20:48,279
That was a long sentence.

380
00:20:48,279 --> 00:20:51,129


381
00:20:51,130 --> 00:20:52,822
Well that's easy enough.

382
00:20:52,821 --> 00:20:56,213
Now here's going to be
a lot of CAR-CDRing.

383
00:20:56,213 --> 00:20:59,399
I have to get the body
of the procedure.

384
00:20:59,400 --> 00:21:02,960
Where's the body of the
procedure in here?

385
00:21:02,960 --> 00:21:05,490
Well here's the CAR, here's
the CDR is the

386
00:21:05,490 --> 00:21:06,130
whole rest of this.

387
00:21:06,130 --> 00:21:09,130
So here's the CADR. And so I
see, what I have here is the

388
00:21:09,130 --> 00:21:11,430
body is the second element
of the second

389
00:21:11,430 --> 00:21:13,200
element of the procedure.

390
00:21:13,200 --> 00:21:19,170
So it's the CADR of the
CADR or the CADADR.

391
00:21:19,170 --> 00:21:27,495
It's the C-A-D-A-D-R, CADADR
of the procedure.

392
00:21:27,494 --> 00:21:30,259


393
00:21:30,259 --> 00:21:35,170
To evaluate the body in the
result of binding that's

394
00:21:35,170 --> 00:21:39,080
making up more environment,
well I need the formal

395
00:21:39,079 --> 00:21:43,500
parameters of the of the
procedure, what is that?

396
00:21:43,500 --> 00:21:48,779
That's the CAR of the CDR.
It's horrible isn't it?

397
00:21:48,779 --> 00:21:52,440


398
00:21:52,440 --> 00:21:55,440
--of the procedure.

399
00:21:55,440 --> 00:22:00,370
Bind that to the arguments
that were passed in the

400
00:22:00,369 --> 00:22:04,539
environment, which is passed
also as part of the procedure.

401
00:22:04,539 --> 00:22:09,670
Well, that's the CAR of the
CDR of the CDR of this,

402
00:22:09,670 --> 00:22:16,315
CADADR, of the procedure.

403
00:22:16,315 --> 00:22:20,289


404
00:22:20,289 --> 00:22:26,490
Bind, eval, pair, COND,
lamda, define--

405
00:22:26,490 --> 00:22:29,370
Now, of course, if I were being
really a neat character,

406
00:22:29,369 --> 00:22:33,489
and I was being very careful, I
would actually put an extra

407
00:22:33,490 --> 00:22:36,539
case here for checking for
certain errors like, did you

408
00:22:36,539 --> 00:22:39,000
try to apply one
to an argument?

409
00:22:39,000 --> 00:22:42,569
You get a undefined
procedure type.

410
00:22:42,569 --> 00:22:45,500
So I may as well
do that anyway.

411
00:22:45,500 --> 00:22:57,609
--else, some sort of
error, like that.

412
00:22:57,609 --> 00:23:02,619
Now, of course, again, in some
sort of more real system,

413
00:23:02,619 --> 00:23:06,769
written for professional
reasons, this would be written

414
00:23:06,769 --> 00:23:10,750
with a case analysis done by
some sort of dispatch.

415
00:23:10,750 --> 00:23:13,250
Over here, I would probably have
other cases like, is this

416
00:23:13,250 --> 00:23:16,220
compiled code?

417
00:23:16,220 --> 00:23:17,019
It's very important.

418
00:23:17,019 --> 00:23:19,529
I might have distinguished the
kind of code that's produced

419
00:23:19,529 --> 00:23:23,149
by a directly evaluating a
lambda in interpretation from

420
00:23:23,150 --> 00:23:25,190
code that was produced by
somebody's compiler or

421
00:23:25,190 --> 00:23:25,880
something like that.

422
00:23:25,880 --> 00:23:27,230
And we'll talk about
that later.

423
00:23:27,230 --> 00:23:28,710
Or is this a piece Fortran
program I have

424
00:23:28,710 --> 00:23:30,509
to go off and execute.

425
00:23:30,509 --> 00:23:31,819
It's a perfectly possible
thing, at this

426
00:23:31,819 --> 00:23:32,919
point, to do that.

427
00:23:32,920 --> 00:23:36,070
In fact, in this concrete syntax
evaluator I'm writing

428
00:23:36,069 --> 00:23:42,599
here, there's an assumption
built in that this is Lisp,

429
00:23:42,599 --> 00:23:44,359
because I'm using
CARs and CDRs.

430
00:23:44,359 --> 00:23:46,750
CAR means the operator, and
CDR means the operand.

431
00:23:46,750 --> 00:23:50,500
In the text, there is an
abstract syntax evaluator for

432
00:23:50,500 --> 00:23:52,160
which these could be--

433
00:23:52,160 --> 00:23:54,310
these are given abstract names
like operator, and operand,

434
00:23:54,309 --> 00:23:56,159
and all these other things
are like that.

435
00:23:56,160 --> 00:24:00,320
And, in that case, you could
reprogram it to be ALGOL with

436
00:24:00,319 --> 00:24:01,569
no problem.

437
00:24:01,569 --> 00:24:03,759


438
00:24:03,759 --> 00:24:07,410
Well, here we have added another
couple of things that

439
00:24:07,410 --> 00:24:08,660
we haven't defined.

440
00:24:08,660 --> 00:24:10,810


441
00:24:10,809 --> 00:24:13,799
I don't think I'll worry about
these at all, however, this

442
00:24:13,799 --> 00:24:15,049
one will be interesting later.

443
00:24:15,049 --> 00:24:17,930


444
00:24:17,930 --> 00:24:20,549
Let's just proceed through
this and get it done.

445
00:24:20,549 --> 00:24:21,809
There's only two more
blackboards so it

446
00:24:21,809 --> 00:24:23,059
can't be very long.

447
00:24:23,059 --> 00:24:27,056


448
00:24:27,056 --> 00:24:30,069
It's carefully tailored
to exactly fit.

449
00:24:30,069 --> 00:24:30,980
Well, what do we have left?

450
00:24:30,980 --> 00:24:33,730
We have to define EVLIST,
which is over here.

451
00:24:33,730 --> 00:24:40,620
And EVLIST is nothing more than
a map down a bunch of

452
00:24:40,619 --> 00:24:44,239
operands producing arguments.

453
00:24:44,240 --> 00:24:45,819
But I'm going to write it out.

454
00:24:45,819 --> 00:24:47,444
And one of the reasons I'm going
to write this out is for

455
00:24:47,444 --> 00:24:51,819
a mystical reason, which is I
want to make this evaluator so

456
00:24:51,819 --> 00:24:53,609
simple that it can understand
itself.

457
00:24:53,609 --> 00:24:56,449


458
00:24:56,450 --> 00:25:00,230
I'm going to really worry
about that a little bit.

459
00:25:00,230 --> 00:25:02,849
So let's write it
out completely.

460
00:25:02,849 --> 00:25:04,889
See, I don't want to worry about
whether or not the thing

461
00:25:04,890 --> 00:25:06,080
can pass functional arguments.

462
00:25:06,079 --> 00:25:08,980
The value evaluator is not
going to use them.

463
00:25:08,980 --> 00:25:10,880
The evaluator is not going to
produce functional values.

464
00:25:10,880 --> 00:25:12,310
So even if there were a
different, alternative

465
00:25:12,309 --> 00:25:16,509
language that were very close
to this, this evaluates a

466
00:25:16,509 --> 00:25:19,829
complex language like Scheme
which does allow procedural

467
00:25:19,829 --> 00:25:24,069
arguments, procedural values,
and procedural data.

468
00:25:24,069 --> 00:25:28,099
But even if I were evaluating
ALGOL, which doesn't allow

469
00:25:28,099 --> 00:25:31,579
procedural values, I could
use this evaluator.

470
00:25:31,579 --> 00:25:32,869
And this evaluator
is not making any

471
00:25:32,869 --> 00:25:34,049
assumptions about that.

472
00:25:34,049 --> 00:25:36,579
And, in fact, if this value were
to be restricted to not

473
00:25:36,579 --> 00:25:37,699
being able to that, it wouldn't
matter, because it

474
00:25:37,700 --> 00:25:40,640
doesn't use any of those
clever things.

475
00:25:40,640 --> 00:25:44,070
So that's why I'm arranging
this to be super simple.

476
00:25:44,069 --> 00:25:45,970
This is sort of the kernel
of all possible language

477
00:25:45,970 --> 00:25:47,809
evaluators.

478
00:25:47,809 --> 00:25:49,419
How about that?

479
00:25:49,420 --> 00:25:50,670
Evlist--

480
00:25:50,670 --> 00:25:52,525


481
00:25:52,525 --> 00:25:53,820
well, what is it?

482
00:25:53,819 --> 00:25:56,299
It's the procedure of two
arguments, l and an

483
00:25:56,299 --> 00:26:06,259
environment, where l is a list
such that if the list of

484
00:26:06,259 --> 00:26:12,379
arguments is the empty list,
then the result is the empty

485
00:26:12,380 --> 00:26:21,480
list. Otherwise, I want to
cons up the result of

486
00:26:21,480 --> 00:26:31,880
evaluating the CAR of the
list of operands in the

487
00:26:31,880 --> 00:26:33,260
environment.

488
00:26:33,259 --> 00:26:36,359
So I want the first operand
evaluated, and I'm going to

489
00:26:36,359 --> 00:26:40,734
make a list of the results by
CONSing that onto the result

490
00:26:40,734 --> 00:26:48,879
of this EVLISTing as a CDR
recursion, the CDR of the list

491
00:26:48,880 --> 00:26:50,130
relative to the same
environment.

492
00:26:50,130 --> 00:26:53,350


493
00:26:53,349 --> 00:26:57,959
Evlist, cons, else, COND,
lambda, define--

494
00:26:57,960 --> 00:27:00,950


495
00:27:00,950 --> 00:27:03,620
And I have one more that I want
to put on the blackboard.

496
00:27:03,619 --> 00:27:05,469
It's the essence of
this whole thing.

497
00:27:05,470 --> 00:27:08,130
And there's some sort
of next layer down.

498
00:27:08,130 --> 00:27:14,540


499
00:27:14,539 --> 00:27:15,769
Conditionals--

500
00:27:15,769 --> 00:27:17,500
conditionals are the only thing
left that are sort of

501
00:27:17,500 --> 00:27:18,880
substantial.

502
00:27:18,880 --> 00:27:22,320
Then below that, we have to
worry about things like lookup

503
00:27:22,319 --> 00:27:25,529
and bind, and we'll look
at that in a second.

504
00:27:25,529 --> 00:27:29,029
But of the substantial stuff at
this level of detail, next

505
00:27:29,029 --> 00:27:31,599
important thing is how you
deal with conditionals.

506
00:27:31,599 --> 00:27:33,329
Well, how do we have a
conditional thing?

507
00:27:33,329 --> 00:27:37,669


508
00:27:37,670 --> 00:27:44,720
It's a procedure of a set of
clauses and an environment.

509
00:27:44,720 --> 00:27:47,339


510
00:27:47,339 --> 00:27:49,819
And what does it do?

511
00:27:49,819 --> 00:28:03,309
It says, if I've no more
clauses, well, I have to give

512
00:28:03,309 --> 00:28:04,519
this a value.

513
00:28:04,519 --> 00:28:06,539
It could be that it
was an error.

514
00:28:06,539 --> 00:28:08,029
Supposing it run off
the end of a

515
00:28:08,029 --> 00:28:10,059
conditional, it's pretty arbitrary.

516
00:28:10,059 --> 00:28:13,649
It's up to me as programmer to
choose what I want to happen.

517
00:28:13,650 --> 00:28:15,940
It's convenient for me, right
now, to write down that this

518
00:28:15,940 --> 00:28:20,100
has a value which is the empty
list, doesn't matter.

519
00:28:20,099 --> 00:28:21,529
For error checking,
some people might

520
00:28:21,529 --> 00:28:23,109
prefer something else.

521
00:28:23,109 --> 00:28:25,569
But the interesting things
are the following ones.

522
00:28:25,569 --> 00:28:27,450
If I've got an else clause--

523
00:28:27,450 --> 00:28:31,420


524
00:28:31,420 --> 00:28:34,120
You see, if I have a list of
clauses, then each clause is a

525
00:28:34,119 --> 00:28:37,479
list. And so the predicate
part is

526
00:28:37,480 --> 00:28:40,265
the CAAR of the clauses.

527
00:28:40,265 --> 00:28:43,560


528
00:28:43,559 --> 00:28:48,069
It's the CAR, which is the first
part of the first clause

529
00:28:48,069 --> 00:28:51,089
in the list of clauses.

530
00:28:51,089 --> 00:28:55,899
If it's an else, then it means
I want my result of the

531
00:28:55,900 --> 00:28:58,400
conditional to be the result
of evaluating the matching

532
00:28:58,400 --> 00:28:59,800
expression.

533
00:28:59,799 --> 00:29:10,609
So I eval the CADR. So this is
the first clause, the second

534
00:29:10,609 --> 00:29:12,829
element of it, CADAR--

535
00:29:12,829 --> 00:29:16,359
CADAR of a CAR--

536
00:29:16,359 --> 00:29:22,194
of the clauses, with respect
to the environment.

537
00:29:22,194 --> 00:29:26,619


538
00:29:26,619 --> 00:29:29,629
Now the next possibility
is more interesting.

539
00:29:29,630 --> 00:29:34,860
If it's false, if the first
predicate in the predicate

540
00:29:34,859 --> 00:29:38,839
list is not an else, and it's
not false, if it's not the

541
00:29:38,839 --> 00:29:42,049
word else, and if it's
not a false thing--

542
00:29:42,049 --> 00:29:44,359
Let's write down what it is
if it's a false thing.

543
00:29:44,359 --> 00:29:49,589
If the result of evaluating
the first

544
00:29:49,589 --> 00:29:52,899
predicate, the clauses--

545
00:29:52,900 --> 00:29:55,490


546
00:29:55,490 --> 00:30:01,630
respect the environment, if that
evaluation yields false,

547
00:30:01,630 --> 00:30:04,180
then it means, I want to look
at the next clause.

548
00:30:04,180 --> 00:30:05,990
So I want to discard
the first one.

549
00:30:05,990 --> 00:30:15,450
So we just go around loop,
evcond, the CDR of the clauses

550
00:30:15,450 --> 00:30:16,700
relative to that environment.

551
00:30:16,700 --> 00:30:21,240


552
00:30:21,240 --> 00:30:27,740
And otherwise, I had a true
clause, in which case, what I

553
00:30:27,740 --> 00:30:40,710
want is to evaluate the CADAR
of the clauses relative to

554
00:30:40,710 --> 00:30:41,960
that environment.

555
00:30:41,960 --> 00:30:48,200


556
00:30:48,200 --> 00:30:51,210
Boy, it's almost done.

557
00:30:51,210 --> 00:30:53,730
It's quite close to done.

558
00:30:53,730 --> 00:30:56,210
I think we're going to
finish this part off.

559
00:30:56,210 --> 00:30:59,529
So just buzzing through this
evaluator, but so far you're

560
00:30:59,529 --> 00:31:01,220
seeing almost everything.

561
00:31:01,220 --> 00:31:04,039
Let's look at the next
transparency here.

562
00:31:04,039 --> 00:31:08,980


563
00:31:08,980 --> 00:31:11,980
Here is bind.

564
00:31:11,980 --> 00:31:15,460
Bind is for making more table.

565
00:31:15,460 --> 00:31:19,259
And what we are going to
do here is make a--

566
00:31:19,259 --> 00:31:22,799
we're going to make a no-frame
for an environment structure.

567
00:31:22,799 --> 00:31:26,230
The environment structure is
going to be represented as a

568
00:31:26,230 --> 00:31:28,079
list of frames.

569
00:31:28,079 --> 00:31:30,519
So given an existing environment
structure, I'm

570
00:31:30,519 --> 00:31:32,500
going to make a new environment
structure by

571
00:31:32,500 --> 00:31:35,269
consing a new frame onto the
existing environment

572
00:31:35,269 --> 00:31:38,700
structure, where the new frame
consists of the result of

573
00:31:38,700 --> 00:31:41,940
pairing up the variables, which
are the bound variables

574
00:31:41,940 --> 00:31:45,610
of the procedure I'm applying,
to the values which are the

575
00:31:45,609 --> 00:31:49,689
arguments that were passed
that procedure.

576
00:31:49,690 --> 00:31:53,259
This is just making a list,
adding a new element to our

577
00:31:53,259 --> 00:31:56,069
list of frames, which is an
environment structure, to make

578
00:31:56,069 --> 00:31:58,390
a new environment.

579
00:31:58,391 --> 00:32:01,539
Where pair-up is very simple.

580
00:32:01,539 --> 00:32:04,609
Pair-up is nothing more than if
I have a list of variables

581
00:32:04,609 --> 00:32:07,829
and a list of values, well, if
I run out of variables and if

582
00:32:07,829 --> 00:32:09,720
I run out of values,
everything's OK.

583
00:32:09,720 --> 00:32:12,990
Otherwise, I've given
too many arguments.

584
00:32:12,990 --> 00:32:15,390
If I've not run out of
variables, but I've run out of

585
00:32:15,390 --> 00:32:18,560
values, that I have
too few arguments.

586
00:32:18,559 --> 00:32:20,694
And in the general case, where
I don't have any errors, and

587
00:32:20,694 --> 00:32:26,859
I'm not done, then I really am
just adding a new pair of the

588
00:32:26,859 --> 00:32:32,809
first variable with the first
argument, the first value,

589
00:32:32,809 --> 00:32:37,779
onto a list resulting from
pairing-up the rest of the

590
00:32:37,779 --> 00:32:42,950
variables with the rest
of the values.

591
00:32:42,950 --> 00:32:46,620
Lookup is of course
equally simple.

592
00:32:46,619 --> 00:32:50,229
If I have to look up a symbol
in an environment, well, if

593
00:32:50,230 --> 00:32:54,650
the environment is empty, then
I've got an unbound variable.

594
00:32:54,650 --> 00:32:59,769
Otherwise, what I'm going to do
is use a special pair list

595
00:32:59,769 --> 00:33:02,539
lookup procedure, which we'll
have very shortly, of the

596
00:33:02,539 --> 00:33:05,930
symbol in the first frame
of the environment.

597
00:33:05,930 --> 00:33:07,670
Since I know the environment is
not empty, it must have a

598
00:33:07,670 --> 00:33:09,200
first frame.

599
00:33:09,200 --> 00:33:11,140
So I lookup the symbol
in the first frame.

600
00:33:11,140 --> 00:33:15,150
That becomes the value
cell here.

601
00:33:15,150 --> 00:33:19,860
And then, if the value cell is
empty, if there is no such

602
00:33:19,859 --> 00:33:22,149
value cell, then I have to
continue and look at the rest

603
00:33:22,150 --> 00:33:23,720
of the frames.

604
00:33:23,720 --> 00:33:25,990
It means there was nothing
found there.

605
00:33:25,990 --> 00:33:29,740
So that's a property of ASSQ is
it returns emptiness if it

606
00:33:29,740 --> 00:33:32,009
doesn't find something.

607
00:33:32,009 --> 00:33:35,174
but if it did find something,
then I'm going to use the CDR

608
00:33:35,174 --> 00:33:38,079
of the value cell here, which is
the thing that was the pair

609
00:33:38,079 --> 00:33:41,049
consisting of the variable
and the value.

610
00:33:41,049 --> 00:33:45,000
So the CDR of it is
the value part.

611
00:33:45,000 --> 00:33:47,970
Finally, ASSQ is something
you've probably seen already.

612
00:33:47,970 --> 00:33:52,400
ASSQ takes a symbol and a list
of pairs, and if the list is

613
00:33:52,400 --> 00:33:53,759
empty, it's empty.

614
00:33:53,759 --> 00:33:57,849
If the symbol is the first
thing in the list--

615
00:33:57,849 --> 00:33:59,819
That's an error.

616
00:33:59,819 --> 00:34:04,159
That should be CAAR, C-A-A-R.
Everybody note that.

617
00:34:04,160 --> 00:34:07,730


618
00:34:07,730 --> 00:34:08,980
Right there, OK?

619
00:34:08,980 --> 00:34:13,121


620
00:34:13,121 --> 00:34:17,150
And in any case, if the symbol
is the CAAR of the A list,

621
00:34:17,150 --> 00:34:22,340
then I want the first, the first
pair, in the A list. So,

622
00:34:22,340 --> 00:34:26,300
in other words, if this is the
key matching the right entry,

623
00:34:26,300 --> 00:34:30,429
otherwise, I want to look up
that symbol in the rest. Sorry

624
00:34:30,429 --> 00:34:35,190
for producing a bug,
bugs appear.

625
00:34:35,190 --> 00:34:38,389
Well, in any case, you're
pretty much seeing

626
00:34:38,389 --> 00:34:39,639
the whole thing now.

627
00:34:39,639 --> 00:34:41,880


628
00:34:41,880 --> 00:34:45,150
It's a very beautiful thing,
even though it's written in an

629
00:34:45,150 --> 00:34:49,599
ugly style, being the kernel
of every language.

630
00:34:49,599 --> 00:34:50,210
I suggest that we just--

631
00:34:50,210 --> 00:34:51,460
let's look at it for a while.

632
00:34:51,460 --> 00:34:56,749


633
00:34:56,748 --> 00:35:49,750
[MUSIC PLAYING]

634
00:35:49,750 --> 00:35:51,000
Are there any questions?

635
00:35:51,000 --> 00:36:01,179


636
00:36:01,179 --> 00:36:04,043
Alright, I suppose it's time
to take a small break then.

637
00:36:04,043 --> 00:36:56,779
[MUSIC PLAYING]

638
00:36:56,780 --> 00:36:59,390
OK, now we're just going to do
a little bit of practice

639
00:36:59,389 --> 00:37:03,469
understanding what it is
we've just shown you.

640
00:37:03,469 --> 00:37:05,699
What we're going to do is go
through, in detail, an

641
00:37:05,699 --> 00:37:09,719
evaluation by informally
substituting through the

642
00:37:09,719 --> 00:37:11,500
interpreter.

643
00:37:11,500 --> 00:37:14,159
And since we have no assignments
or definitions in

644
00:37:14,159 --> 00:37:18,469
this interpreter, we have no
possible side effects, and so

645
00:37:18,469 --> 00:37:23,199
the we can do substitution with
impunity and not worry

646
00:37:23,199 --> 00:37:25,329
about results.

647
00:37:25,329 --> 00:37:28,799
So the particular problem I'd
like to look at is it an

648
00:37:28,800 --> 00:37:30,690
interesting one.

649
00:37:30,690 --> 00:37:41,909
It's the evaluation of quote,
open, open, open, lambda of x,

650
00:37:41,909 --> 00:37:55,099
lambda of y plus x y, lambda,
lambda, applied to three,

651
00:37:55,099 --> 00:37:58,639
applied to four, in some
global environment

652
00:37:58,639 --> 00:37:59,889
which I'll call e0.

653
00:37:59,889 --> 00:38:04,929


654
00:38:04,929 --> 00:38:07,899
So what we have here is a
procedure of one argument x,

655
00:38:07,900 --> 00:38:10,980
which produces as its value a
procedure of one argument y,

656
00:38:10,980 --> 00:38:14,300
which adds x to y.

657
00:38:14,300 --> 00:38:17,960
We are applying the procedure
of one argument x to three.

658
00:38:17,960 --> 00:38:21,400
So x should become three.

659
00:38:21,400 --> 00:38:23,590
And the result of that should
be procedure of one argument

660
00:38:23,590 --> 00:38:26,167
y, which will then apply to 4.

661
00:38:26,166 --> 00:38:28,909


662
00:38:28,909 --> 00:38:31,480
And there is a very simple
case, they will

663
00:38:31,480 --> 00:38:34,789
then add those results.

664
00:38:34,789 --> 00:38:36,860
And now in order to do that, I
want to make a very simple

665
00:38:36,860 --> 00:38:37,660
environment model.

666
00:38:37,659 --> 00:38:41,199
And at this point, you should
already have in your mind the

667
00:38:41,199 --> 00:38:44,460
environments that
this produces.

668
00:38:44,460 --> 00:38:48,809
But we're going to start out
with a global environment,

669
00:38:48,809 --> 00:38:56,739
which I'll call e0,
which is that.

670
00:38:56,739 --> 00:39:00,549
And it's going to have in it
things, definitions for plus,

671
00:39:00,550 --> 00:39:07,390
and times, and--

672
00:39:07,389 --> 00:39:08,559
using Greek letters, isn't that

673
00:39:08,559 --> 00:39:11,289
interesting, for the objects--

674
00:39:11,289 --> 00:39:27,329
and minus, and quotient, and
CAR, and CDR, and CONS, and

675
00:39:27,329 --> 00:39:30,480
EQ, and everything else you
might imagine in a global

676
00:39:30,480 --> 00:39:31,269
environment.

677
00:39:31,269 --> 00:39:34,590
It's got something there for
each of those things,

678
00:39:34,590 --> 00:39:39,220
something the machine is
born with, that's e0.

679
00:39:39,219 --> 00:39:42,939
Now what does it mean to
do this evaluation?

680
00:39:42,940 --> 00:39:46,119
Well, we go through the set of
special forms. First of all,

681
00:39:46,119 --> 00:39:48,670
this is not a number.

682
00:39:48,670 --> 00:39:50,380
This is not a symbol.

683
00:39:50,380 --> 00:39:53,210


684
00:39:53,210 --> 00:39:56,519
Gee, it's not a quoted
expression.

685
00:39:56,519 --> 00:40:00,079
This is a quoted expression,
but that's not what I

686
00:40:00,079 --> 00:40:00,599
interested in.

687
00:40:00,599 --> 00:40:02,699
The question is, whether or not
the thing which is quoted

688
00:40:02,699 --> 00:40:05,889
is quoted expression?

689
00:40:05,889 --> 00:40:07,960
I'm evaluating an expression.

690
00:40:07,960 --> 00:40:11,409
This just says it's this
particular expression.

691
00:40:11,409 --> 00:40:12,659
This is not a quoted
expression.

692
00:40:12,659 --> 00:40:15,230


693
00:40:15,230 --> 00:40:19,119
It's not a thing that
begins with lambda.

694
00:40:19,119 --> 00:40:22,029
It's not a thing that
begins with COND.

695
00:40:22,030 --> 00:40:24,630
Therefore, it's an application
of its

696
00:40:24,630 --> 00:40:26,309
of an operated operands.

697
00:40:26,309 --> 00:40:28,570
It's a combination.

698
00:40:28,570 --> 00:40:35,230
The combination thus has this
as the operator and this is

699
00:40:35,230 --> 00:40:36,480
the operands.

700
00:40:36,480 --> 00:40:40,130


701
00:40:40,130 --> 00:40:43,539
Well, that means that what I'm
going to do is transform this

702
00:40:43,539 --> 00:40:54,009
into apply of eval, of quote,
open, open lambda of

703
00:40:54,010 --> 00:40:58,180
x, lambda of y--

704
00:40:58,179 --> 00:40:59,980
I'm evaluating the operator--

705
00:40:59,980 --> 00:41:13,610
plus x y, in the environment,
also e0, with the operands

706
00:41:13,610 --> 00:41:16,329
that I'm going to apply this
to, the arguments being the

707
00:41:16,329 --> 00:41:24,449
result of EVLIST, the list
containing four, fin e0.

708
00:41:24,449 --> 00:41:29,009


709
00:41:29,010 --> 00:41:33,010
I'm using this funny notation
here for e0 because this

710
00:41:33,010 --> 00:41:36,840
should be that environment.

711
00:41:36,840 --> 00:41:38,640
I haven't a name for it, because
I have no environment

712
00:41:38,639 --> 00:41:39,889
to name it in.

713
00:41:39,889 --> 00:41:41,960


714
00:41:41,960 --> 00:41:44,630
So this is just a representation
of what would

715
00:41:44,630 --> 00:41:47,730
be a quoted expression,
if you will.

716
00:41:47,730 --> 00:41:53,039
The data structure, which is the
environment, goes there.

717
00:41:53,039 --> 00:41:55,849
Well, that's what we're
seeing here.

718
00:41:55,849 --> 00:41:57,369
Well in order to do this,
I have to do this, and

719
00:41:57,369 --> 00:41:59,609
I have to do that.

720
00:41:59,610 --> 00:42:03,769
Well this one's easy, so why
don't we do that one first.

721
00:42:03,769 --> 00:42:07,780
This turns into apply
of eval-- just

722
00:42:07,780 --> 00:42:09,519
copying something now.

723
00:42:09,519 --> 00:42:11,000
Most of the substitution
rule is copying.

724
00:42:11,000 --> 00:42:18,530


725
00:42:18,530 --> 00:42:22,100
So I'm going to not say the
words when I copy, because

726
00:42:22,099 --> 00:42:23,349
it's faster.

727
00:42:23,349 --> 00:42:26,099


728
00:42:26,099 --> 00:42:34,130
And then the EVLIST is going to
turn into a cons, of eval,

729
00:42:34,130 --> 00:42:36,160
of four, in e0--

730
00:42:36,159 --> 00:42:38,779


731
00:42:38,780 --> 00:42:42,260
because it was not
an empty list--

732
00:42:42,260 --> 00:42:48,910
onto the result of EVLISTing,
on the empty list, in e0.

733
00:42:48,909 --> 00:42:52,579


734
00:42:52,579 --> 00:42:54,549
And I'm going to start leaving
out steps soon, because it's

735
00:42:54,550 --> 00:42:55,800
going to get boring.

736
00:42:55,800 --> 00:42:59,870


737
00:42:59,869 --> 00:43:05,025
But this is basically the same
thing as apply, of eval--

738
00:43:05,025 --> 00:43:07,639


739
00:43:07,639 --> 00:43:10,230
I'm going to keep doing this--

740
00:43:10,230 --> 00:43:20,240
the lambda of x, the lambda of
y, plus xy, 3, close, e0.

741
00:43:20,239 --> 00:43:21,489
I'm a pretty good machine.

742
00:43:21,489 --> 00:43:24,689


743
00:43:24,690 --> 00:43:27,409
Well, eval of four,
that's meets the

744
00:43:27,409 --> 00:43:28,789
question, is it a number.

745
00:43:28,789 --> 00:43:35,279
So that's cons, cons of 4.

746
00:43:35,280 --> 00:43:37,110
And EVLIST of the empty
list is the empty

747
00:43:37,110 --> 00:43:39,240
list, so that's this.

748
00:43:39,239 --> 00:43:43,269


749
00:43:43,269 --> 00:43:46,170
And that's very simple to
understand, because that means

750
00:43:46,170 --> 00:43:48,710
the list containing
four itself.

751
00:43:48,710 --> 00:43:56,340
So this is nothing more than
apply of eval, quote, open,

752
00:43:56,340 --> 00:44:06,590
open, lambda of x, lambda of y,
plus x y, three applied to,

753
00:44:06,590 --> 00:44:11,678
e0, applied to the list four--

754
00:44:11,677 --> 00:44:13,940
bang.

755
00:44:13,940 --> 00:44:15,190
So that's that step.

756
00:44:15,190 --> 00:44:18,099


757
00:44:18,099 --> 00:44:20,360
Now let's look at the next,
more interesting thing.

758
00:44:20,360 --> 00:44:23,070
What do I do to evaluate that?

759
00:44:23,070 --> 00:44:27,780
Evaluating this means
I have to evaluate--

760
00:44:27,780 --> 00:44:29,460
Well, it's not.

761
00:44:29,460 --> 00:44:31,679
It's nothing but
an application.

762
00:44:31,679 --> 00:44:33,569
It's not one of the
special things.

763
00:44:33,570 --> 00:44:37,660
If the application of this
operator, which we see here--

764
00:44:37,659 --> 00:44:40,269
here's the operator--

765
00:44:40,269 --> 00:44:46,570
applied to this operands,
that combination.

766
00:44:46,570 --> 00:44:51,390
But we know how to do that,
because that's the last case

767
00:44:51,389 --> 00:44:52,369
of the conditional.

768
00:44:52,369 --> 00:44:56,480
So substituting in for this
evaluation, it's apply of eval

769
00:44:56,480 --> 00:45:01,159
of the operator in the EVLIST
of the operands.

770
00:45:01,159 --> 00:45:12,099
Well, it's apply, of apply, of
eval, of quote, open, lambda

771
00:45:12,099 --> 00:45:23,779
of x, lambda of y, plus
x y, lambda, lambda,

772
00:45:23,780 --> 00:45:25,350
in environment e0.

773
00:45:25,349 --> 00:45:30,519


774
00:45:30,519 --> 00:45:32,730
I'm going to short circuit the
evaluation of the operands ,

775
00:45:32,730 --> 00:45:35,230
because they're the same
as they were before.

776
00:45:35,230 --> 00:45:38,079
I got a list containing
three, apply that, and

777
00:45:38,079 --> 00:45:39,329
apply that to four.

778
00:45:39,329 --> 00:45:42,779


779
00:45:42,780 --> 00:45:44,410
Well let's see.

780
00:45:44,409 --> 00:45:49,449
Eval of a lambda expression
produces a procedure object.

781
00:45:49,449 --> 00:45:52,029


782
00:45:52,030 --> 00:46:04,530
So this is apply, of apply, of
the procedure object closure,

783
00:46:04,530 --> 00:46:09,420
which contains the body of the
procedure, x, which is

784
00:46:09,420 --> 00:46:12,130
lambda-- which binds
x [UNINTELLIGIBLE]

785
00:46:12,130 --> 00:46:17,230
the internals of the body, it
returns the procedure of one

786
00:46:17,230 --> 00:46:20,630
argument y, which adds x to y.

787
00:46:20,630 --> 00:46:23,210


788
00:46:23,210 --> 00:46:27,929
Environment e0 is now captured
in it, because this was

789
00:46:27,929 --> 00:46:30,339
evaluated with respect to e0.

790
00:46:30,340 --> 00:46:33,039
e0 is part now of the
closure object.

791
00:46:33,039 --> 00:46:40,050
Apply that to open, three,
close, apply, to open, 4,

792
00:46:40,050 --> 00:46:41,300
close, apply.

793
00:46:41,300 --> 00:46:47,390


794
00:46:47,389 --> 00:46:50,219
So going from this step to this
step meant that I made up

795
00:46:50,219 --> 00:46:55,059
a procedure object which
captured in it e0 as part of

796
00:46:55,059 --> 00:46:57,150
the procedure object.

797
00:46:57,150 --> 00:46:58,619
Now, we're going to pass
those to apply.

798
00:46:58,619 --> 00:47:00,480
We have to apply this procedure

799
00:47:00,480 --> 00:47:02,710
to that set of arguments.

800
00:47:02,710 --> 00:47:07,380
Well, but that procedure
is not primitive.

801
00:47:07,380 --> 00:47:10,500
It's, in fact, a thing which has
got the tag closure, and,

802
00:47:10,500 --> 00:47:13,710
therefore, what we have
to do is do a bind.

803
00:47:13,710 --> 00:47:15,829
We have to bind.

804
00:47:15,829 --> 00:47:21,849
A new environment is made at
this point, which has as its

805
00:47:21,849 --> 00:47:26,980
parent environment the one
over here, e0, that

806
00:47:26,980 --> 00:47:28,230
environment.

807
00:47:28,230 --> 00:47:30,320


808
00:47:30,320 --> 00:47:31,570
And we'll call this one, e1.

809
00:47:31,570 --> 00:47:34,620


810
00:47:34,619 --> 00:47:36,039
Now what's bound in there?

811
00:47:36,039 --> 00:47:38,619
x is bound to three.

812
00:47:38,619 --> 00:47:41,480
So I have x equal three.

813
00:47:41,480 --> 00:47:42,730
That's what's in there.

814
00:47:42,730 --> 00:47:44,940


815
00:47:44,940 --> 00:47:46,240
And we'll call that e1.

816
00:47:46,239 --> 00:47:51,939
So what this transforms into
is an eval of the body of

817
00:47:51,940 --> 00:47:56,740
this, which is this, the body
of that procedure, in the

818
00:47:56,739 --> 00:48:00,289
environment that you just saw.

819
00:48:00,289 --> 00:48:11,480
So that's an apply, of eval,
quote, open, lambda of y, plus

820
00:48:11,480 --> 00:48:12,750
x y-- the body--

821
00:48:12,750 --> 00:48:15,269


822
00:48:15,269 --> 00:48:16,519
in e1.

823
00:48:16,519 --> 00:48:20,659


824
00:48:20,659 --> 00:48:26,039
And apply the result of that
to four, open, close, 4--

825
00:48:26,039 --> 00:48:28,679
list of arguments.

826
00:48:28,679 --> 00:48:31,599
Well, that's sensible enough
because evaluating a lambda, I

827
00:48:31,599 --> 00:48:33,110
know what to do.

828
00:48:33,110 --> 00:48:43,680
That means I apply, the
procedure which is closure,

829
00:48:43,679 --> 00:48:52,149
binds one argument y, adds x to
y, with e1 captured in it.

830
00:48:52,150 --> 00:48:55,789


831
00:48:55,789 --> 00:48:57,800
And you should really
see this.

832
00:48:57,800 --> 00:49:00,140
I somehow manufactured
a closure.

833
00:49:00,139 --> 00:49:01,789
I should've put this here.

834
00:49:01,789 --> 00:49:03,039
There was one over here too.

835
00:49:03,039 --> 00:49:06,230


836
00:49:06,230 --> 00:49:08,079
Well, there's one here now.

837
00:49:08,079 --> 00:49:13,710
I've captured e1, and this is
the procedure of one argument

838
00:49:13,710 --> 00:49:17,880
y, whatever this is.

839
00:49:17,880 --> 00:49:20,434
That's what that is there,
that closure.

840
00:49:20,434 --> 00:49:23,039


841
00:49:23,039 --> 00:49:26,230
I'm going to apply
that to four.

842
00:49:26,230 --> 00:49:30,690


843
00:49:30,690 --> 00:49:31,940
Well, that's easy enough.

844
00:49:31,940 --> 00:49:36,829


845
00:49:36,829 --> 00:49:39,719
That means I have to make a
new environment by copying

846
00:49:39,719 --> 00:49:45,029
this pointer, which was the
pointer of the procedure,

847
00:49:45,030 --> 00:49:49,540
which binds y equal 4 with
that environment.

848
00:49:49,539 --> 00:49:52,460
And here's my new environment,
which I'll call e2.

849
00:49:52,460 --> 00:49:55,869


850
00:49:55,869 --> 00:49:58,989
And, of course, this application
then is evaluate

851
00:49:58,989 --> 00:50:01,909
the body in e2.

852
00:50:01,909 --> 00:50:10,829
So this is eval, the body,
which is plus x y, in the

853
00:50:10,829 --> 00:50:13,710
environment e2.

854
00:50:13,710 --> 00:50:22,220
But this is an application, so
this is the apply, of eval,

855
00:50:22,219 --> 00:50:37,339
plus in e2, an EVLIST, quote,
open, x y, in e2.

856
00:50:37,340 --> 00:50:44,880


857
00:50:44,880 --> 00:50:45,590
Well, but let's see.

858
00:50:45,590 --> 00:50:52,480
That is apply, the
object which is a

859
00:50:52,480 --> 00:50:54,190
result of that and plus.

860
00:50:54,190 --> 00:50:57,920
So here we are in e2, plus is
not here, it's not here, oh,

861
00:50:57,920 --> 00:51:01,780
yes, but's here as some
primitive operator.

862
00:51:01,780 --> 00:51:04,745
So it's the primitive operator
for addition.

863
00:51:04,744 --> 00:51:08,489


864
00:51:08,489 --> 00:51:14,369
Apply that to the result of
evaluating x and y in e2.

865
00:51:14,369 --> 00:51:18,339
But we can see that x is
three and y is four.

866
00:51:18,340 --> 00:51:23,936
So that's a three
and four, here.

867
00:51:23,936 --> 00:51:26,280
And that magically produces
for me a seven.

868
00:51:26,280 --> 00:51:30,519


869
00:51:30,519 --> 00:51:33,460
I wanted to go through this so
you would see, essentially,

870
00:51:33,460 --> 00:51:36,960
one important ingredient, which
is what's being passed

871
00:51:36,960 --> 00:51:40,470
around, and who owns what,
and what his job is.

872
00:51:40,469 --> 00:51:41,699
So what do we have here?

873
00:51:41,699 --> 00:51:46,519
We have eval, and we have apply,
the two main players.

874
00:51:46,519 --> 00:51:49,369


875
00:51:49,369 --> 00:51:52,319
And there is a big loop the
goes around like this.

876
00:51:52,320 --> 00:52:00,780
Which is eval produces
a procedure and

877
00:52:00,780 --> 00:52:06,269
arguments for apply.

878
00:52:06,269 --> 00:52:09,710
Now some things eval
could do by itself.

879
00:52:09,710 --> 00:52:10,860
Those are little self
things here.

880
00:52:10,860 --> 00:52:12,700
They're not interesting.

881
00:52:12,699 --> 00:52:16,239
Also eval evaluates all of the
arguments, one after another.

882
00:52:16,239 --> 00:52:17,649
That's not very interesting.

883
00:52:17,650 --> 00:52:21,539
Apply can apply some procedures
like plus, not very

884
00:52:21,539 --> 00:52:22,300
interesting.

885
00:52:22,300 --> 00:52:25,519
However, if apply can't apply
a procedure like plus, it

886
00:52:25,519 --> 00:52:32,880
produces an expression and
environment for eval.

887
00:52:32,880 --> 00:52:35,470


888
00:52:35,469 --> 00:52:39,769
The procedural arguments wrap up
essentially the state of a

889
00:52:39,769 --> 00:52:43,739
computation and, certainly, the
expression of environment.

890
00:52:43,739 --> 00:52:45,599
And so what we're actually going
to do next is not the

891
00:52:45,599 --> 00:52:47,569
complete state, because
it doesn't say

892
00:52:47,570 --> 00:52:48,820
who wants the answers.

893
00:52:48,820 --> 00:52:51,280


894
00:52:51,280 --> 00:52:53,500
But what we're going to do--
it's always got something like

895
00:52:53,500 --> 00:52:56,579
an expression of environment or
procedure and arguments as

896
00:52:56,579 --> 00:52:58,969
the main loop that we're
going around.

897
00:52:58,969 --> 00:53:01,500
There are minor little sub
loops like eval through

898
00:53:01,500 --> 00:53:11,030
EVLIST, or eval through evcond,
or apply through a

899
00:53:11,030 --> 00:53:12,280
primitive apply.

900
00:53:12,280 --> 00:53:16,140


901
00:53:16,139 --> 00:53:18,500
But they're not the
essential things.

902
00:53:18,500 --> 00:53:21,860
So that's what I wanted
you to see.

903
00:53:21,860 --> 00:53:23,110
Are there any questions?

904
00:53:23,110 --> 00:53:25,930


905
00:53:25,929 --> 00:53:28,690
Yes.

906
00:53:28,690 --> 00:53:32,670
AUDIENCE: I'm trying to
understand how x got down to

907
00:53:32,670 --> 00:53:37,070
three instead of four.

908
00:53:37,070 --> 00:53:38,539
At the early part of the--

909
00:53:38,539 --> 00:53:41,309
PROFESSOR: Here.

910
00:53:41,309 --> 00:53:43,309
You want to know how x
got down to three?

911
00:53:43,309 --> 00:53:49,769
AUDIENCE: Because x is the outer
procedure, and x and y

912
00:53:49,769 --> 00:53:51,039
are the inner procedure.

913
00:53:51,039 --> 00:53:52,570
PROFESSOR: Fine.

914
00:53:52,570 --> 00:53:55,280
Well, I was very careful
and mechanical.

915
00:53:55,280 --> 00:53:57,350
First of all, I should write
those procedures again for

916
00:53:57,349 --> 00:54:00,610
you, pretty printed.

917
00:54:00,610 --> 00:54:02,260
First order of business, because
you're probably not

918
00:54:02,260 --> 00:54:03,830
reading them well.

919
00:54:03,829 --> 00:54:08,500
So I have here that
procedure of--

920
00:54:08,500 --> 00:54:11,280
was it x over there--

921
00:54:11,280 --> 00:54:12,690
which is--

922
00:54:12,690 --> 00:54:20,710
value of that procedure of y,
which adds x to y, lambda,

923
00:54:20,710 --> 00:54:25,380
lambda, applied that to three,
takes the result of that, and

924
00:54:25,380 --> 00:54:26,140
applied that to four.

925
00:54:26,139 --> 00:54:28,809
Is that not what I wrote?

926
00:54:28,809 --> 00:54:34,170
Now, you should immediately
see that here is an

927
00:54:34,170 --> 00:54:35,150
application--

928
00:54:35,150 --> 00:54:37,400
let me get a white
piece of chalk--

929
00:54:37,400 --> 00:54:40,735
here is an application,
a combination.

930
00:54:40,735 --> 00:54:44,300


931
00:54:44,300 --> 00:54:48,269
That combination has this
as the operator

932
00:54:48,269 --> 00:54:51,039
and this as the operand.

933
00:54:51,039 --> 00:54:54,900
The three is going in
for the x here.

934
00:54:54,900 --> 00:54:58,720
The result of this is a
procedure of one argument y,

935
00:54:58,719 --> 00:55:01,529
which gets applied to four.

936
00:55:01,530 --> 00:55:04,190
So you just weren't reading
the expression right.

937
00:55:04,190 --> 00:55:11,579
The way you see that over here
is that here I have the actual

938
00:55:11,579 --> 00:55:13,340
procedure object, x.

939
00:55:13,340 --> 00:55:18,980
It's getting applied to three,
the list containing three.

940
00:55:18,980 --> 00:55:20,349
What I'm left over with
is something which

941
00:55:20,349 --> 00:55:24,079
gets applied to four.

942
00:55:24,079 --> 00:55:25,329
Are there any other questions?

943
00:55:25,329 --> 00:55:28,599


944
00:55:28,599 --> 00:55:30,900
Time for our next small
break then.

945
00:55:30,900 --> 00:55:33,735
Thank you.

946
00:55:33,735 --> 00:56:08,410
[MUSIC PLAYING]

947
00:56:08,409 --> 00:56:14,730
Let's see, at this point, you
should be getting the feeling,

948
00:56:14,730 --> 00:56:16,630
what's this nonsense
this Sussman

949
00:56:16,630 --> 00:56:17,960
character is feeding me?

950
00:56:17,960 --> 00:56:20,740


951
00:56:20,739 --> 00:56:24,799
There's an awful lot of
strange nonsense here.

952
00:56:24,800 --> 00:56:28,300
After all, he purported to
explain to me Lisp, and he

953
00:56:28,300 --> 00:56:30,892
wrote me a Lisp program
on the blackboard.

954
00:56:30,891 --> 00:56:33,559
The Lisp program was intended
to be interpreted for Lisp,

955
00:56:33,559 --> 00:56:35,279
but you need a Lisp interpreter
in order to

956
00:56:35,280 --> 00:56:38,370
understand that program.

957
00:56:38,369 --> 00:56:41,159
How could that program have told
me anything there is to

958
00:56:41,159 --> 00:56:44,149
be known about Lisp?

959
00:56:44,150 --> 00:56:45,795
How is that not completely
vacuous?

960
00:56:45,795 --> 00:56:48,490


961
00:56:48,489 --> 00:56:50,989
It's a very strange thing.

962
00:56:50,989 --> 00:56:52,429
Does it tell me anything
at all?

963
00:56:52,429 --> 00:56:56,069


964
00:56:56,070 --> 00:56:59,230
Well, you see, the whole thing
is sort of like these Escher's

965
00:56:59,230 --> 00:57:03,105
hands that we see
on this slide.

966
00:57:03,105 --> 00:57:06,179


967
00:57:06,179 --> 00:57:11,750
Yes, eval and apply each sort
of draw each other and

968
00:57:11,750 --> 00:57:15,690
construct the real thing,
which can sit

969
00:57:15,690 --> 00:57:17,110
out and draw itself.

970
00:57:17,110 --> 00:57:19,300
Escher was a very brilliant man,
he just didn't know the

971
00:57:19,300 --> 00:57:20,550
names of these spirits.

972
00:57:20,550 --> 00:57:23,910


973
00:57:23,909 --> 00:57:27,699
Well, I'm going to do now, is
I'm going to try to convince

974
00:57:27,699 --> 00:57:33,059
you that both this mean
something, and, as a aside,

975
00:57:33,059 --> 00:57:36,090
I'm going to show you why you
don't need definitions.

976
00:57:36,090 --> 00:57:38,760
Just turns out that that sort of
falls out, why definitions

977
00:57:38,760 --> 00:57:42,990
are not essential in a
mathematical sense for doing

978
00:57:42,989 --> 00:57:44,889
all the things we need
to do for computing.

979
00:57:44,889 --> 00:57:49,069


980
00:57:49,070 --> 00:57:50,690
Well, let's see here.

981
00:57:50,690 --> 00:57:54,869
Consider the following small
program, what does it mean?

982
00:57:54,869 --> 00:57:57,034
This is a program for computing
exponentials.

983
00:57:57,034 --> 00:58:07,269


984
00:58:07,269 --> 00:58:13,349
The exponential of x to
the nth power is if--

985
00:58:13,349 --> 00:58:16,909


986
00:58:16,909 --> 00:58:22,069
and is zero, then the
result is one.

987
00:58:22,070 --> 00:58:29,519
Otherwise, I want the product
of x and the result of

988
00:58:29,519 --> 00:58:33,929
exponentiating x to the
n minus one power.

989
00:58:33,929 --> 00:58:42,857


990
00:58:42,858 --> 00:58:46,630
I think I got it right.

991
00:58:46,630 --> 00:58:49,470
Now this is a recursive
definition.

992
00:58:49,469 --> 00:58:53,929
It's a definition of the
exponentiation procedure in

993
00:58:53,929 --> 00:58:56,409
terms of itself.

994
00:58:56,409 --> 00:59:00,710
And, as it has been mentioned
before, your high school

995
00:59:00,710 --> 00:59:03,010
geometry teacher probably
gave you a hard time

996
00:59:03,010 --> 00:59:05,650
about things like that.

997
00:59:05,650 --> 00:59:07,910
Was that justified?

998
00:59:07,909 --> 00:59:13,429
Why does this self referential
definition make any sense?

999
00:59:13,429 --> 00:59:15,059
Well, first of all, I'm going to
convince you that your high

1000
00:59:15,059 --> 00:59:17,599
school geometry teacher was
I telling you nonsense.

1001
00:59:17,599 --> 00:59:20,369


1002
00:59:20,369 --> 00:59:24,489
Consider the following set
of definitions here.

1003
00:59:24,489 --> 00:59:33,069
x plus y equals three, and
x minus y equal one.

1004
00:59:33,070 --> 00:59:36,170
Well, gee, this tells you x in
terms of y, and this one tells

1005
00:59:36,170 --> 00:59:37,490
you y in terms of
x, presumably.

1006
00:59:37,489 --> 00:59:40,149


1007
00:59:40,150 --> 00:59:42,950
And yet this happens to have a
unique solution in x and y.

1008
00:59:42,949 --> 00:59:55,909


1009
00:59:55,909 --> 01:00:06,599
However, I could also write
two x plus two y is six.

1010
01:00:06,599 --> 01:00:09,610
These two equations have an
infinite number solutions.

1011
01:00:09,610 --> 01:00:15,730


1012
01:00:15,730 --> 01:00:21,519
And I could write you, for
example, x minus y equal 2,

1013
01:00:21,519 --> 01:00:24,070
and these two equations
have no solutions.

1014
01:00:24,070 --> 01:00:29,820


1015
01:00:29,820 --> 01:00:32,350
Well, I have here three sets
of simultaneous linear

1016
01:00:32,349 --> 01:00:39,509
equations, this set, this
set, and this set.

1017
01:00:39,510 --> 01:00:42,900
But they have different
numbers of solutions.

1018
01:00:42,900 --> 01:00:45,760
The number of solutions is not
in the form of the equations.

1019
01:00:45,760 --> 01:00:48,350
They all three sets have
the same form.

1020
01:00:48,349 --> 01:00:50,204
The number of solutions
is in the content.

1021
01:00:50,204 --> 01:00:53,000


1022
01:00:53,000 --> 01:00:55,510
I can't tell by looking at the
form of a definition whether

1023
01:00:55,510 --> 01:00:59,660
it makes sense, only by
its detailed content.

1024
01:00:59,659 --> 01:01:02,170
What are the coefficients,
for example, in the

1025
01:01:02,170 --> 01:01:05,099
case of linear equations?

1026
01:01:05,099 --> 01:01:07,440
So I shouldn't expect to be
able to tell looking at

1027
01:01:07,440 --> 01:01:11,500
something like this, from some
simple things like, oh yes,

1028
01:01:11,500 --> 01:01:16,030
EXPT is the solution of this
recursion equation.

1029
01:01:16,030 --> 01:01:22,110
Expt is the procedure which
if substituted in here,

1030
01:01:22,110 --> 01:01:26,039
gives me EXPT back.

1031
01:01:26,039 --> 01:01:30,750
I can't tell, looking at this
form, whether or not there's a

1032
01:01:30,750 --> 01:01:33,969
single, unique solution for
EXPT, an infinite number of

1033
01:01:33,969 --> 01:01:37,199
solutions, or no solutions.

1034
01:01:37,199 --> 01:01:38,929
It's got to be how it
counts and things

1035
01:01:38,929 --> 01:01:40,489
like that, the details.

1036
01:01:40,489 --> 01:01:42,899
And it's harder in programming
than linear algebra.

1037
01:01:42,900 --> 01:01:45,210
There aren't too many theorems
about it in programming.

1038
01:01:45,210 --> 01:01:48,449


1039
01:01:48,449 --> 01:01:50,989
Well, I want to rewrite these
equations a little

1040
01:01:50,989 --> 01:01:53,969
bit, these over here.

1041
01:01:53,969 --> 01:01:55,559
Because what we're
investigating is

1042
01:01:55,559 --> 01:01:56,769
equations like this.

1043
01:01:56,769 --> 01:01:58,820
But I want to play a little with
equations like this that

1044
01:01:58,820 --> 01:02:02,050
we understand, just so we
get some insight into

1045
01:02:02,050 --> 01:02:04,730
this kind of question.

1046
01:02:04,730 --> 01:02:07,869
We could rewrite our equations
here, say these two, the ones

1047
01:02:07,869 --> 01:02:17,069
that are interesting, as x
equals three minus y, and y

1048
01:02:17,070 --> 01:02:19,380
equals x minus one.

1049
01:02:19,380 --> 01:02:22,010


1050
01:02:22,010 --> 01:02:24,050
What do we call this
transformation?

1051
01:02:24,050 --> 01:02:26,095
This is a linear transformation,
t.

1052
01:02:26,094 --> 01:02:29,429


1053
01:02:29,429 --> 01:02:35,389
Then what we're getting here
is an equation x y

1054
01:02:35,389 --> 01:02:37,369
equals t of x y.

1055
01:02:37,369 --> 01:02:42,989


1056
01:02:42,989 --> 01:02:44,559
What am I looking for?

1057
01:02:44,559 --> 01:02:47,039
I'm looking for a fixed
point of t.

1058
01:02:47,039 --> 01:02:59,349
The solution is a fixed
point of t.

1059
01:02:59,349 --> 01:03:01,909


1060
01:03:01,909 --> 01:03:04,829
So the methods we should have
for looking for solutions to

1061
01:03:04,829 --> 01:03:09,230
equations, if I can do it by
fixed points, might be

1062
01:03:09,230 --> 01:03:10,880
applicable.

1063
01:03:10,880 --> 01:03:13,710
If I have a means of finding a
solution to an equations by

1064
01:03:13,710 --> 01:03:15,690
fixed points--

1065
01:03:15,690 --> 01:03:18,619
just, might not work--

1066
01:03:18,619 --> 01:03:21,159
but it might be applicable to
investigating solutions of

1067
01:03:21,159 --> 01:03:22,409
equations like this.

1068
01:03:22,409 --> 01:03:27,239


1069
01:03:27,239 --> 01:03:30,259
But what I want you to feel is
that this is an equation.

1070
01:03:30,260 --> 01:03:32,930
It's an expression with several
instances of various

1071
01:03:32,929 --> 01:03:39,019
names which puts a constraint on
the name, saying what that

1072
01:03:39,019 --> 01:03:42,769
name could have as its value,
rather than some sort of

1073
01:03:42,769 --> 01:03:45,009
mechanical process of
substitution right now.

1074
01:03:45,010 --> 01:03:47,740


1075
01:03:47,739 --> 01:03:51,219
This is an equation which I'm
going to try to solve.

1076
01:03:51,219 --> 01:03:53,959
Well, let's play around
and solve it.

1077
01:03:53,960 --> 01:03:57,800
First of all, I want to write
down the function which

1078
01:03:57,800 --> 01:04:00,320
corresponds to t.

1079
01:04:00,320 --> 01:04:02,670
First I want to write down the
function which corresponds to

1080
01:04:02,670 --> 01:04:06,960
t whose fixed point is the
answer to this question.

1081
01:04:06,960 --> 01:04:11,949


1082
01:04:11,949 --> 01:04:14,239
Well, let's consider the
following procedure f.

1083
01:04:14,239 --> 01:04:16,869


1084
01:04:16,869 --> 01:04:19,339
I claim it computes
that function.

1085
01:04:19,340 --> 01:04:26,860
f is that procedure of one
argument g, which is that

1086
01:04:26,860 --> 01:04:33,430
procedure of two arguments
x and n.

1087
01:04:33,429 --> 01:04:42,409
Which have the property that if
n is zero, then the result

1088
01:04:42,409 --> 01:04:56,049
is one, otherwise, the result
is the product of x and g,

1089
01:04:56,050 --> 01:05:00,690
applied to x, and minus n1.

1090
01:05:00,690 --> 01:05:03,369


1091
01:05:03,369 --> 01:05:07,900
g, times, else, COND,
lambda, lambda--

1092
01:05:07,900 --> 01:05:11,900


1093
01:05:11,900 --> 01:05:17,230
Here f is a procedure, which
if I had a solution to that

1094
01:05:17,230 --> 01:05:23,639
equation, if I had a good
exponentiation procedure, and

1095
01:05:23,639 --> 01:05:29,500
I applied f to that procedure,
then the result would be a

1096
01:05:29,500 --> 01:05:30,929
good exponentiation procedure.

1097
01:05:30,929 --> 01:05:37,460


1098
01:05:37,460 --> 01:05:39,420
Because, what does it do?

1099
01:05:39,420 --> 01:05:44,200
Well, all it is is exposing g
were a good exponentiation

1100
01:05:44,199 --> 01:05:48,009
procedure, well then this would
produce, as its value, a

1101
01:05:48,010 --> 01:05:51,650
procedure to arguments x and n,
such that if n were 0, the

1102
01:05:51,650 --> 01:05:53,360
result would be one, which
is certainly true of

1103
01:05:53,360 --> 01:05:54,670
exponentiation.

1104
01:05:54,670 --> 01:05:57,730
Otherwise, it will be the result
of multiplying x by the

1105
01:05:57,730 --> 01:06:01,750
exponentiation procedure given
to me with x and n minus one

1106
01:06:01,750 --> 01:06:03,469
as arguments.

1107
01:06:03,469 --> 01:06:05,679
So if this computed the correct
exponentiation for n

1108
01:06:05,679 --> 01:06:10,500
minus one, then this would be
the correct exponentiation for

1109
01:06:10,500 --> 01:06:13,369
exponent n, so this would
have been the right

1110
01:06:13,369 --> 01:06:14,619
exponentiation procedure.

1111
01:06:14,619 --> 01:06:17,500


1112
01:06:17,500 --> 01:06:26,559
So what I really want to say
here is E-X-P-T is a fixed

1113
01:06:26,559 --> 01:06:32,320
point of f.

1114
01:06:32,320 --> 01:06:37,550


1115
01:06:37,550 --> 01:06:40,060
Now our problem is there might
be more than one fixed point.

1116
01:06:40,059 --> 01:06:43,269
There might be no
fixed points.

1117
01:06:43,269 --> 01:06:44,809
I have to go hunting for
the fixed points.

1118
01:06:44,809 --> 01:06:48,289


1119
01:06:48,289 --> 01:06:49,539
Got to solve this equation.

1120
01:06:49,539 --> 01:06:52,159


1121
01:06:52,159 --> 01:06:55,579
Well there are various ways
to hunt for fixed points.

1122
01:06:55,579 --> 01:06:58,079
Of course, the one we played
with at the beginning of this

1123
01:06:58,079 --> 01:07:00,815
term worked for cosine.

1124
01:07:00,815 --> 01:07:06,079


1125
01:07:06,079 --> 01:07:09,235
Go into radians mode on your
calculator and push cosine,

1126
01:07:09,235 --> 01:07:12,990
and just keep doing it, and you
get to some number which

1127
01:07:12,989 --> 01:07:16,089
is about 0.73 or 0.74.

1128
01:07:16,090 --> 01:07:17,340
I can't remember which.

1129
01:07:17,340 --> 01:07:22,900


1130
01:07:22,900 --> 01:07:27,170
By iterating a function, whose
fixed point I'm searching for,

1131
01:07:27,170 --> 01:07:32,090
it is sometimes the case that
that function will converge in

1132
01:07:32,090 --> 01:07:33,769
producing the fixed point.

1133
01:07:33,769 --> 01:07:39,909
I think we luck out in this
case, so let's look for it.

1134
01:07:39,909 --> 01:07:48,029
Let's look at this slide.

1135
01:07:48,030 --> 01:07:51,390
Consider the following sequence
of procedures.

1136
01:07:51,389 --> 01:07:56,400


1137
01:07:56,400 --> 01:08:02,940
e0 over here is the procedure
which does nothing at all.

1138
01:08:02,940 --> 01:08:05,389
It's the procedure which
produces an error for any

1139
01:08:05,389 --> 01:08:07,779
arguments you give it.

1140
01:08:07,780 --> 01:08:09,030
It's basically useless.

1141
01:08:09,030 --> 01:08:14,480


1142
01:08:14,480 --> 01:08:20,079
Well, however, I can make
an approximation.

1143
01:08:20,079 --> 01:08:22,930
Let's consider it the worst
possible approximation to

1144
01:08:22,930 --> 01:08:26,990
exponentiation, because
it does nothing.

1145
01:08:26,989 --> 01:08:34,170
Well, supposing I substituted e0
for g by calling f, as you

1146
01:08:34,170 --> 01:08:37,380
see over here on e0.

1147
01:08:37,380 --> 01:08:40,729
So you see over here,
have e0 there.

1148
01:08:40,729 --> 01:08:43,859
Then gee, what's e1?

1149
01:08:43,859 --> 01:08:47,189
e1 is a procedure which
exponentiate things to the 0th

1150
01:08:47,189 --> 01:08:49,325
power, with no trouble.

1151
01:08:49,324 --> 01:08:52,420
It gets the right answer,
anything to the zero is one,

1152
01:08:52,420 --> 01:08:54,250
and it makes an error
on anything else.

1153
01:08:54,250 --> 01:08:57,390


1154
01:08:57,390 --> 01:09:06,039
Well, now what if I take e1 and
I substitute if for g by

1155
01:09:06,039 --> 01:09:07,310
calling f on e1?

1156
01:09:07,310 --> 01:09:10,500


1157
01:09:10,500 --> 01:09:15,670
Oh gosh, I have here a procedure
of two arguments.

1158
01:09:15,670 --> 01:09:18,250
Now remember e1 was appropriate
for taking

1159
01:09:18,250 --> 01:09:24,199
exponentiations of 0, for
raising to the 0 exponent.

1160
01:09:24,199 --> 01:09:27,909
So here, is n is 0, the result
is one, so this guy is good

1161
01:09:27,909 --> 01:09:29,519
for that too.

1162
01:09:29,520 --> 01:09:32,479
However, I can use something for
raising to the 0th power

1163
01:09:32,479 --> 01:09:35,979
to multiply it by x to raise
something to the first power.

1164
01:09:35,979 --> 01:09:39,670
So e2 is good for both
power 0 and one.

1165
01:09:39,670 --> 01:09:43,800


1166
01:09:43,800 --> 01:09:47,899
And e3 is constructed from
e2 in the same way.

1167
01:09:47,899 --> 01:09:52,240
And e3, of course, by the same
argument is good for powers 0,

1168
01:09:52,239 --> 01:09:55,119
one, and two.

1169
01:09:55,119 --> 01:10:00,140
And so I will assert for you,
without proof, because the

1170
01:10:00,140 --> 01:10:02,520
proof is horribly difficult.

1171
01:10:02,520 --> 01:10:04,050
And that's the sort of thing
that people called

1172
01:10:04,050 --> 01:10:07,710
denotational semanticists do.

1173
01:10:07,710 --> 01:10:10,265
This great idea was invented
by Scott and Strachey.

1174
01:10:10,265 --> 01:10:14,240


1175
01:10:14,239 --> 01:10:17,109
They're very famous
mathematician types who

1176
01:10:17,109 --> 01:10:21,029
invented the interpretation
for these programs that we

1177
01:10:21,029 --> 01:10:24,239
have that I'm talking to
you about right now.

1178
01:10:24,239 --> 01:10:28,949
And they proved, by topology
that there is such a fixed

1179
01:10:28,949 --> 01:10:32,220
point in the cases
that we want.

1180
01:10:32,220 --> 01:10:41,180
But the assertion is E-X-P-T
is limit as n goes

1181
01:10:41,180 --> 01:10:43,680
to infinity of em.

1182
01:10:43,680 --> 01:10:47,900
and And that we've constructed
this by the following way.

1183
01:10:47,899 --> 01:10:50,519


1184
01:10:50,520 --> 01:10:57,530
--is Well, it's f of, f
of, f of, f of, f of--

1185
01:10:57,529 --> 01:11:01,119
f applied to anything at all.

1186
01:11:01,119 --> 01:11:04,069
It didn't matter what that was,
because, in fact, this

1187
01:11:04,069 --> 01:11:05,319
always produces an error.

1188
01:11:05,319 --> 01:11:07,539


1189
01:11:07,539 --> 01:11:08,789
Applied to this--

1190
01:11:08,789 --> 01:11:12,840


1191
01:11:12,840 --> 01:11:16,380
That's by infinite
nesting of f's.

1192
01:11:16,380 --> 01:11:19,760
So now my problem is to make
some infinite things.

1193
01:11:19,760 --> 01:11:22,590


1194
01:11:22,590 --> 01:11:24,920
We need some infinite things.

1195
01:11:24,920 --> 01:11:28,980
How am I going to nest up an f
an infinite number of times?

1196
01:11:28,979 --> 01:11:32,379
I'd better construct this.

1197
01:11:32,380 --> 01:11:32,930
Well, I don't know.

1198
01:11:32,930 --> 01:11:34,810
How would I make an infinite
loop at all?

1199
01:11:34,810 --> 01:11:37,090
Let's take a very simple
infinite loop, the simplest

1200
01:11:37,090 --> 01:11:38,340
infinite loop imaginable.

1201
01:11:38,340 --> 01:11:43,550


1202
01:11:43,550 --> 01:11:48,070
If I were to take that procedure
of one argument x

1203
01:11:48,069 --> 01:11:57,579
which applies x to x and apply
that to the procedure of one

1204
01:11:57,579 --> 01:12:05,319
argument x which applies
x to x, then this

1205
01:12:05,319 --> 01:12:07,439
is an infinite loop.

1206
01:12:07,439 --> 01:12:09,979
The reason why this is an
infinite loop is as follows.

1207
01:12:09,979 --> 01:12:14,389
The way I understand this is I
substitute the argument for

1208
01:12:14,390 --> 01:12:18,850
the formal parameter
in the body.

1209
01:12:18,850 --> 01:12:22,590
But if I do that, I take for
each of these x's, I

1210
01:12:22,590 --> 01:12:25,739
substitute one of these, making
a copy of the original

1211
01:12:25,739 --> 01:12:28,409
expression I just started
with, the

1212
01:12:28,409 --> 01:12:29,659
simplest infinite loop.

1213
01:12:29,659 --> 01:12:35,439


1214
01:12:35,439 --> 01:12:40,750
Now I want to tell you about a
particular operator which is

1215
01:12:40,750 --> 01:12:43,090
constructed by a perturbation
from this infinite loop.

1216
01:12:43,090 --> 01:12:47,039


1217
01:12:47,039 --> 01:12:48,289
I'll call it y.

1218
01:12:48,289 --> 01:12:52,289


1219
01:12:52,289 --> 01:12:56,680
This is called Curry's
Paradoxical Combinator of y

1220
01:12:56,680 --> 01:13:00,510
after a fellow by the name of
Curry, who was a logician of

1221
01:13:00,510 --> 01:13:04,480
the 1930s also.

1222
01:13:04,479 --> 01:13:08,669
And if I have a procedure of
one argument f, what's it

1223
01:13:08,670 --> 01:13:09,329
going to have in it?

1224
01:13:09,329 --> 01:13:13,420
It's going to have a kind of
infinite loop in it, which is

1225
01:13:13,420 --> 01:13:21,670
that procedure of one argument
x which applies f to x of x,

1226
01:13:21,670 --> 01:13:25,819
applied to that procedure of one
argument x, which applies

1227
01:13:25,819 --> 01:13:27,898
f to f of x.

1228
01:13:27,899 --> 01:13:32,300


1229
01:13:32,300 --> 01:13:34,590
Now what's this do?

1230
01:13:34,590 --> 01:13:42,949
Suppose we apply y to F. Well,
that's easy enough.

1231
01:13:42,949 --> 01:13:46,909
That's this capital
F over here.

1232
01:13:46,909 --> 01:13:48,670
Well, the easiest thing
to say there is, I

1233
01:13:48,670 --> 01:13:49,920
substitute F for here.

1234
01:13:49,920 --> 01:13:55,319


1235
01:13:55,319 --> 01:13:58,460
So that's going to give
me, basically--

1236
01:13:58,460 --> 01:14:02,800
because then I'm going to
substitute this for x in here.

1237
01:14:02,800 --> 01:14:08,970


1238
01:14:08,970 --> 01:14:10,810
Let me actually do it in steps,
so you can see it

1239
01:14:10,810 --> 01:14:11,730
completely.

1240
01:14:11,729 --> 01:14:15,019
I'm going to be very careful.

1241
01:14:15,020 --> 01:14:27,510
This is open, open, lambda of
x , capital F, x, x, applied

1242
01:14:27,510 --> 01:14:37,909
to itself, F of x of x.

1243
01:14:37,909 --> 01:14:45,599
Substituting this for this in
here, this is F applied to--

1244
01:14:45,600 --> 01:14:47,039
what is it--

1245
01:14:47,039 --> 01:14:53,850
substituting this in here, open,
open, lambda of x, F, of

1246
01:14:53,850 --> 01:15:08,910
x and x, applied to lambda of
x, F of x of x, F, lambda,

1247
01:15:08,909 --> 01:15:11,510
pair, F.

1248
01:15:11,510 --> 01:15:13,420
Oh, but what is this?

1249
01:15:13,420 --> 01:15:17,489
This thing over here that
I just computed, is

1250
01:15:17,489 --> 01:15:20,029
this thing over here.

1251
01:15:20,029 --> 01:15:23,369
But I just wrapped another
F around it.

1252
01:15:23,369 --> 01:15:27,849
So by applying y to F, I make
an infinite series of F's.

1253
01:15:27,850 --> 01:15:30,520
If I just let this run forever,
I'll just keep making

1254
01:15:30,520 --> 01:15:33,170
more and more F's outside.

1255
01:15:33,170 --> 01:15:35,600
I ran an infinite loop which
is useless, but it doesn't

1256
01:15:35,600 --> 01:15:36,855
matter that the inside
is useless.

1257
01:15:36,854 --> 01:15:40,219


1258
01:15:40,220 --> 01:15:53,900
So y of F is F applied to y of
F. So y is a magical thing

1259
01:15:53,899 --> 01:15:58,839
which, when applied to some
function, produces the object

1260
01:15:58,840 --> 01:16:03,199
which is the fixed point of that
function, if it exists,

1261
01:16:03,199 --> 01:16:04,449
and if this all works.

1262
01:16:04,449 --> 01:16:07,909


1263
01:16:07,909 --> 01:16:10,380
Because, indeed, if I take y of
F and put it into F, I get

1264
01:16:10,380 --> 01:16:11,630
y of F out.

1265
01:16:11,630 --> 01:16:16,239


1266
01:16:16,239 --> 01:16:20,750
Now I want you to think this
in terms of the eval-apply

1267
01:16:20,750 --> 01:16:23,859
interpreter for a bit.

1268
01:16:23,859 --> 01:16:28,539
I wrote down a whole bunch of
recursion equations out there.

1269
01:16:28,539 --> 01:16:30,210
They're simultaneous in
the same way these are

1270
01:16:30,210 --> 01:16:31,470
simultaneous equations.

1271
01:16:31,470 --> 01:16:33,310
Exponentiation was not a
simultaneous equation.

1272
01:16:33,310 --> 01:16:38,150
It was only one variable I was
looking for a meaning for.

1273
01:16:38,149 --> 01:16:41,210
But what Lisp is is the fixed
point of the process which

1274
01:16:41,210 --> 01:16:44,739
says, if I knew what Lisp was
and substituted it in for

1275
01:16:44,739 --> 01:16:47,779
eval, and apply, and so on, on
the right hand sides of all

1276
01:16:47,779 --> 01:16:51,929
those recursion equations, then
if it was a real good

1277
01:16:51,930 --> 01:16:55,340
Lisp, is a real one, then
the left hand side

1278
01:16:55,340 --> 01:16:58,220
would also be Lisp.

1279
01:16:58,220 --> 01:16:59,565
So I made sense of
that definition.

1280
01:16:59,564 --> 01:17:02,419


1281
01:17:02,420 --> 01:17:05,409
Now whether or not there's an
answer isn't so obvious.

1282
01:17:05,409 --> 01:17:07,739
I can't attack that.

1283
01:17:07,739 --> 01:17:09,159
Now these arguments that
I'm giving you

1284
01:17:09,159 --> 01:17:10,659
now are quite dangerous.

1285
01:17:10,659 --> 01:17:13,569
Let's look over here.

1286
01:17:13,569 --> 01:17:14,609
These are limit arguments.

1287
01:17:14,609 --> 01:17:17,019
We're talking about limits, and
it's really calculus, or

1288
01:17:17,020 --> 01:17:21,255
topology, or something like
that, a kind of analysis.

1289
01:17:21,255 --> 01:17:23,380
Now here's an argument
that you all believe.

1290
01:17:23,380 --> 01:17:27,010
And I want to make sure you
realize that I could be

1291
01:17:27,010 --> 01:17:29,659
bullshitting you.

1292
01:17:29,659 --> 01:17:30,909
What is this?

1293
01:17:30,909 --> 01:17:34,250


1294
01:17:34,250 --> 01:17:40,300
u is the sum of 1/2, 1/4, and
1/8, and so on, the sum of a

1295
01:17:40,300 --> 01:17:42,820
geometric series.

1296
01:17:42,819 --> 01:17:44,819
And, of course, I could
play a game here.

1297
01:17:44,819 --> 01:17:47,569
u minus one is 1/2, plus 1/4,
plus 1/8, and so on.

1298
01:17:47,569 --> 01:17:53,590


1299
01:17:53,590 --> 01:17:56,190
What I could do here--

1300
01:17:56,189 --> 01:17:56,679
oops.

1301
01:17:56,680 --> 01:17:58,920
There is a parentheses
error here.

1302
01:17:58,920 --> 01:18:02,739
But I can put here two times u
minus one is one plus 1/2,

1303
01:18:02,739 --> 01:18:03,989
plus 1/4, plus 1/8.

1304
01:18:03,989 --> 01:18:07,569


1305
01:18:07,569 --> 01:18:08,819
Can I fix that?

1306
01:18:08,819 --> 01:18:14,009


1307
01:18:14,010 --> 01:18:16,125
Yes, well.

1308
01:18:16,125 --> 01:18:19,520


1309
01:18:19,520 --> 01:18:27,850
But that gives me back two
times u minus one is u,

1310
01:18:27,850 --> 01:18:30,300
therefore, we conclude
that u is two.

1311
01:18:30,300 --> 01:18:31,829
And this actually is true.

1312
01:18:31,829 --> 01:18:33,909
There's no problem like that.

1313
01:18:33,909 --> 01:18:38,539
But supposing I did something
different.

1314
01:18:38,539 --> 01:18:39,739
Supposing I start up with
something which

1315
01:18:39,739 --> 01:18:41,469
manifestly has no sum.

1316
01:18:41,470 --> 01:18:47,390
v is one, plus two, plus four,
plus 8, plus dot, dot, dot.

1317
01:18:47,390 --> 01:18:49,560
Well, v minus one is surely two,
plus four, plus eight,

1318
01:18:49,560 --> 01:18:52,010
plus dot, dot, dot.

1319
01:18:52,010 --> 01:18:57,409
v minus one over two, gee,
that looks like v again.

1320
01:18:57,409 --> 01:19:01,069
From that I should be able
to conclude that--

1321
01:19:01,069 --> 01:19:03,069
that's also wrong, apparently.

1322
01:19:03,069 --> 01:19:04,509
v equals minus one.

1323
01:19:04,510 --> 01:19:12,454


1324
01:19:12,454 --> 01:19:15,279
That should be a minus one.

1325
01:19:15,279 --> 01:19:16,734
And that's certainly
a false conclusion.

1326
01:19:16,734 --> 01:19:22,000


1327
01:19:22,000 --> 01:19:27,300
So when you play with limits,
arguments that may work in one

1328
01:19:27,300 --> 01:19:30,750
case they may not work
in some other case.

1329
01:19:30,750 --> 01:19:32,239
You have to be very careful.

1330
01:19:32,239 --> 01:19:35,751
The arguments have to
be well formed.

1331
01:19:35,752 --> 01:19:40,789
And I don't know, in general,
what the story is about

1332
01:19:40,789 --> 01:19:43,269
arguments like this.

1333
01:19:43,270 --> 01:19:46,060
We can read a pile of topology
and find out.

1334
01:19:46,060 --> 01:19:49,750
But, surely, at least you
understand now, why it might

1335
01:19:49,750 --> 01:19:52,229
be some meaning to the things
we've been writing on the

1336
01:19:52,229 --> 01:19:53,259
blackboard.

1337
01:19:53,260 --> 01:19:56,480
And you understand what
that might mean.

1338
01:19:56,479 --> 01:20:02,899
So, I suppose, it's almost about
time for you to merit

1339
01:20:02,899 --> 01:20:05,719
being made a member of the
grand recursive order of

1340
01:20:05,720 --> 01:20:09,320
lambda calculus hackers.

1341
01:20:09,319 --> 01:20:10,819
This is the badge.

1342
01:20:10,819 --> 01:20:14,539
Because you now understand, for
example, what it says at

1343
01:20:14,539 --> 01:20:21,890
the very top, y F equals
F y F. Thank you.

1344
01:20:21,890 --> 01:20:24,710
Are there any questions?

1345
01:20:24,710 --> 01:20:25,149
Yes, Lev.

1346
01:20:25,149 --> 01:20:28,250
AUDIENCE: With this, it seems
that then there's no need to

1347
01:20:28,250 --> 01:20:31,329
define, as you imply,
to just remember a

1348
01:20:31,329 --> 01:20:34,090
value, to apply it later.

1349
01:20:34,090 --> 01:20:35,850
Defines were kind of
a side-effect it

1350
01:20:35,850 --> 01:20:36,490
seemed in the language.

1351
01:20:36,489 --> 01:20:37,074
[INTERPOSING]

1352
01:20:37,074 --> 01:20:39,300
are order dependent.

1353
01:20:39,300 --> 01:20:42,820
Does this eliminate the
side-effect from the

1354
01:20:42,819 --> 01:20:43,149
[INTERPOSING]

1355
01:20:43,149 --> 01:20:46,009
PROFESSOR: The answer is, this
is not the way these things

1356
01:20:46,010 --> 01:20:49,180
were implemented.

1357
01:20:49,180 --> 01:20:53,829
Define, indeed is implemented as
an operation that actually

1358
01:20:53,829 --> 01:20:59,000
modifies an environment
structure, changes the frame

1359
01:20:59,000 --> 01:21:03,689
that the define is
executed in.

1360
01:21:03,689 --> 01:21:08,439
And there are many reasons for
that, but a lot of this has to

1361
01:21:08,439 --> 01:21:11,339
do with making an interactive
system.

1362
01:21:11,340 --> 01:21:14,750
What this is saying is that if
you've made a system, and you

1363
01:21:14,750 --> 01:21:17,210
know you're not going to do any
debugging or anything like

1364
01:21:17,210 --> 01:21:20,930
that, and you know everything
there is all at once, and you

1365
01:21:20,930 --> 01:21:21,930
want to say, what is
the meaning of a

1366
01:21:21,930 --> 01:21:24,090
final set of equations?

1367
01:21:24,090 --> 01:21:25,789
This gives you a
meaning for it.

1368
01:21:25,789 --> 01:21:27,739
But in order to make an
interactive system, where you

1369
01:21:27,739 --> 01:21:29,429
can change the meaning of one
thing without changing

1370
01:21:29,430 --> 01:21:33,579
everything else, incrementally,
you can't do

1371
01:21:33,579 --> 01:21:35,000
that by implementing
it this way.

1372
01:21:35,000 --> 01:21:40,989


1373
01:21:40,989 --> 01:21:41,859
Yes.

1374
01:21:41,859 --> 01:21:44,649
AUDIENCE: Another question
on your danger slide.

1375
01:21:44,649 --> 01:21:47,349
It seemed that the two examples
that you gave had to

1376
01:21:47,350 --> 01:21:50,300
do with convergence and
non-convergence?

1377
01:21:50,300 --> 01:21:53,380
And that may or may not have
something to do with function

1378
01:21:53,380 --> 01:21:55,600
theory in a way which would
lead you to think of it in

1379
01:21:55,600 --> 01:21:59,710
terms of linear systems, or
non-linear systems. How does

1380
01:21:59,710 --> 01:22:03,140
this convergence relate to being
able to see a priori

1381
01:22:03,140 --> 01:22:05,430
what properties of that
might be violated?

1382
01:22:05,430 --> 01:22:07,680
PROFESSOR: I don't know.

1383
01:22:07,680 --> 01:22:10,610
The answer is, I don't know
under what circumstances.

1384
01:22:10,609 --> 01:22:13,659
I don't know how to translate
that into less than an

1385
01:22:13,659 --> 01:22:16,909
hour of talk more.

1386
01:22:16,909 --> 01:22:19,849
What are the conditions under
which, for which we know that

1387
01:22:19,850 --> 01:22:22,720
these things converge?

1388
01:22:22,720 --> 01:22:25,230
And v, all that was telling you
that arguments that are

1389
01:22:25,229 --> 01:22:30,419
based on convergence are flaky
if you don't know the

1390
01:22:30,420 --> 01:22:32,810
convergence beforehand.

1391
01:22:32,810 --> 01:22:34,440
You can make wrong arguments.

1392
01:22:34,439 --> 01:22:37,809
You can make deductions, as if
you know the answer, and not

1393
01:22:37,810 --> 01:22:40,690
be stopped somewhere by some
obvious contradiction.

1394
01:22:40,689 --> 01:22:43,634
AUDIENCE: So can we say then
that if F is a convergent

1395
01:22:43,635 --> 01:22:46,230
mathematical expression,
then the recursion

1396
01:22:46,229 --> 01:22:47,689
property can be--

1397
01:22:47,689 --> 01:22:52,739
PROFESSOR: Well, I think there's
a technical kind of F,

1398
01:22:52,739 --> 01:22:55,149
there is a technical description
of those F's that

1399
01:22:55,149 --> 01:23:00,789
have the property that when
you iteratively apply them

1400
01:23:00,789 --> 01:23:03,019
like this, you converge.

1401
01:23:03,020 --> 01:23:08,470
Things that are monotonic,
and continuous, and

1402
01:23:08,470 --> 01:23:09,369
I forgot what else.

1403
01:23:09,369 --> 01:23:12,010
There is a whole bunch of little
conditions like that

1404
01:23:12,010 --> 01:23:13,430
which have this property.

1405
01:23:13,430 --> 01:23:15,820
Now the real problem is deducing
from looking at the

1406
01:23:15,819 --> 01:23:19,019
F, its definition here, whether
not it has those

1407
01:23:19,020 --> 01:23:22,010
properties, and that's
very hard.

1408
01:23:22,010 --> 01:23:23,280
The properties are easy.

1409
01:23:23,279 --> 01:23:24,579
You can write them down.

1410
01:23:24,579 --> 01:23:26,930
You can look in a book
by Joe Stoy.

1411
01:23:26,930 --> 01:23:28,659
It's a great book--

1412
01:23:28,659 --> 01:23:29,909
Stoy.

1413
01:23:29,909 --> 01:23:31,779


1414
01:23:31,779 --> 01:23:37,359
It's called, The Scott-Strachey
Method of

1415
01:23:37,359 --> 01:23:41,799
Denotational Semantics, and it's
by Joe Stoy, MIT Press.

1416
01:23:41,800 --> 01:23:47,960


1417
01:23:47,960 --> 01:23:50,630
And he works out all this in
great detail, enough to

1418
01:23:50,630 --> 01:23:51,880
horrify you.

1419
01:23:51,880 --> 01:23:55,079


1420
01:23:55,079 --> 01:23:56,329
But it really is readable.

1421
01:23:56,329 --> 01:24:09,149


1422
01:24:09,149 --> 01:24:11,489
OK, well, thank you.

1423
01:24:11,489 --> 01:24:13,779
Time for the bigger
break, I suppose.

1424
01:24:13,779 --> 01:24:36,990


