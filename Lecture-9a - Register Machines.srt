1
00:00:00,000 --> 00:00:02,189


2
00:00:02,189 --> 00:00:02,549
[MUSIC PLAYING - "JESU, JOY OF
MAN'S DESIRING" BY JOHANN

3
00:00:02,549 --> 00:00:03,799
SEBASTIAN BACH]

4
00:00:03,799 --> 00:00:17,260


5
00:00:17,260 --> 00:00:20,520
PROFESSOR: Well, up 'til now, I
suppose, we've been learning

6
00:00:20,519 --> 00:00:26,689
about a lot of techniques for
organizing big programs,

7
00:00:26,690 --> 00:00:33,179
symbolic manipulation a bit,
some of the technology that

8
00:00:33,179 --> 00:00:36,250
you use for establishing
languages, one in terms of

9
00:00:36,250 --> 00:00:39,340
another, which is used for
organizing very large

10
00:00:39,340 --> 00:00:43,160
programs. In fact, the nicest
programs I know look more like

11
00:00:43,159 --> 00:00:47,309
a pile of languages than like
a decomposition of a problem

12
00:00:47,310 --> 00:00:49,900
into parts.

13
00:00:49,899 --> 00:00:52,879
Well, I suppose at this point,
there are still, however, a

14
00:00:52,880 --> 00:00:56,260
few mysteries about how this
sort of stuff works.

15
00:00:56,259 --> 00:01:02,409
And so what we'd like to do now
is diverge from the plan

16
00:01:02,409 --> 00:01:06,060
of telling you how to organize
big programs, and rather tell

17
00:01:06,060 --> 00:01:09,870
you something about the
mechanisms by which these

18
00:01:09,870 --> 00:01:12,195
things can be made to work.

19
00:01:12,195 --> 00:01:18,652
The main reason for this is
demystification, if you will,

20
00:01:18,652 --> 00:01:21,930
that we have a lot of mysteries
left, like exactly

21
00:01:21,930 --> 00:01:27,260
how it is the case that a
program is controlled, how a

22
00:01:27,260 --> 00:01:30,760
computer knows what the next
thing to do is, or

23
00:01:30,760 --> 00:01:32,430
something like that.

24
00:01:32,430 --> 00:01:36,410
And what I'd like to do now is
make that clear to you, that

25
00:01:36,409 --> 00:01:38,579
even if you've never played
with a physical computer

26
00:01:38,579 --> 00:01:44,659
before, the mechanism is really
very simple, and that

27
00:01:44,659 --> 00:01:47,649
you can understand it completely
with no trouble.

28
00:01:47,650 --> 00:01:51,390
So I'd like to start by
imagining that we--

29
00:01:51,390 --> 00:01:53,189
well, the way we're going to do
this, by the way, is we're

30
00:01:53,189 --> 00:01:57,319
going to take some very simple
Lisp programs, very simple

31
00:01:57,319 --> 00:02:02,159
Lisp programs, and transform
them into hardware.

32
00:02:02,159 --> 00:02:05,259
I'm not going to worry about
some intermediate step of

33
00:02:05,260 --> 00:02:07,560
going through some existing
computer machine language and

34
00:02:07,560 --> 00:02:10,960
then showing you how that
computer works, because that's

35
00:02:10,960 --> 00:02:12,750
not as illuminating.

36
00:02:12,750 --> 00:02:16,310
So what I'm really going to
show you is how a piece of

37
00:02:16,310 --> 00:02:21,129
machinery can be built to do a
job that you have written down

38
00:02:21,129 --> 00:02:22,039
as a program.

39
00:02:22,039 --> 00:02:25,759
That program is, in fact, a
description of a machine.

40
00:02:25,759 --> 00:02:28,599
We're going to start with a very
simple program, proceed

41
00:02:28,599 --> 00:02:32,250
to show you some simple
mechanisms, proceed to a few

42
00:02:32,250 --> 00:02:36,659
more complicated programs, and
then later show you a not very

43
00:02:36,659 --> 00:02:40,359
complicated program, how the
evaluator transforms into a

44
00:02:40,360 --> 00:02:41,230
piece of hardware.

45
00:02:41,229 --> 00:02:43,389
And of course at that point,
you have made the universal

46
00:02:43,389 --> 00:02:47,509
transition and can execute any
program imaginable with a

47
00:02:47,509 --> 00:02:48,799
piece of well-defined
hardware.

48
00:02:48,800 --> 00:02:51,392


49
00:02:51,391 --> 00:02:54,319
Well, let's start up now, give
you a real concrete feeling

50
00:02:54,319 --> 00:02:55,439
for this sort of thing.

51
00:02:55,439 --> 00:02:59,599
Let's start with a very
simple program.

52
00:02:59,599 --> 00:03:00,849
Here's Euclid's algorithm.

53
00:03:00,849 --> 00:03:03,879


54
00:03:03,879 --> 00:03:06,139
It's actually a little
bit more modern

55
00:03:06,139 --> 00:03:06,769
than Euclid's algorithm.

56
00:03:06,770 --> 00:03:09,010
Euclid's algorithm for computing
the greatest common

57
00:03:09,009 --> 00:03:14,299
divisor of two numbers was
invented 350 BC, I think.

58
00:03:14,300 --> 00:03:15,550
It's the oldest known
algorithm.

59
00:03:15,550 --> 00:03:19,320


60
00:03:19,319 --> 00:03:23,439
But here we're going to talk
about GCD of A and B, the

61
00:03:23,439 --> 00:03:27,379
Greatest Common Divisor or two
numbers, A and B. And the

62
00:03:27,379 --> 00:03:29,500
algorithm is extremely simple.

63
00:03:29,500 --> 00:03:38,169
If B is 0, then the result is
going to be A. Otherwise, the

64
00:03:38,169 --> 00:03:52,989
result is the GCD of B and the
remainder when A is divided by

65
00:03:52,990 --> 00:03:58,530
B.

66
00:03:58,530 --> 00:04:02,030
So this we have here is a very
simple iterative process.

67
00:04:02,030 --> 00:04:05,550
This a simple recursive
procedure, recursively defined

68
00:04:05,550 --> 00:04:08,340
procedure, recursive definition,
which yields an

69
00:04:08,340 --> 00:04:09,990
iterative process.

70
00:04:09,990 --> 00:04:13,840
And the way it works is that
every step, it determines

71
00:04:13,840 --> 00:04:15,996
whether B was zero.

72
00:04:15,996 --> 00:04:21,660
And if B is 0, we got the answer
in A. Otherwise, we

73
00:04:21,660 --> 00:04:25,060
make another step where A is
the old B, and B is the

74
00:04:25,060 --> 00:04:31,110
remainder of the old A divided
by the old B. Very simple.

75
00:04:31,110 --> 00:04:33,900
Now this, I've already told you
some of the mechanism by

76
00:04:33,899 --> 00:04:34,859
just saying it that way.

77
00:04:34,860 --> 00:04:36,360
I set it in time.

78
00:04:36,360 --> 00:04:39,710
I said there are certain steps,
and that, in fact, one

79
00:04:39,709 --> 00:04:42,509
of the things you can see here
is that one of the reasons why

80
00:04:42,509 --> 00:04:46,959
this is iterative is nothing is
needed of the last step to

81
00:04:46,959 --> 00:04:49,489
get the answer.

82
00:04:49,490 --> 00:04:54,230
All of the information that's
needed to run this algorithm

83
00:04:54,230 --> 00:04:57,540
is in A and B. It has two
well-defined state variables.

84
00:04:57,540 --> 00:05:00,470


85
00:05:00,470 --> 00:05:04,370
So I'm going to define a machine
for you that can

86
00:05:04,370 --> 00:05:06,560
compute you GCDs.

87
00:05:06,560 --> 00:05:07,120
Now let's see.

88
00:05:07,120 --> 00:05:10,009
Every computer that's ever
been made that's a

89
00:05:10,009 --> 00:05:13,490
single-process computer, as
opposed to a multiprocessor of

90
00:05:13,490 --> 00:05:17,840
some sort, is made according
to the same plan.

91
00:05:17,839 --> 00:05:21,629
The plan is the computer has two
parts, a part called the

92
00:05:21,629 --> 00:05:25,909
datapaths, and a part called
the controller.

93
00:05:25,910 --> 00:05:28,960
The datapaths correspond to a
calculator that you might

94
00:05:28,959 --> 00:05:31,579
have. It contains certain
registers that remember

95
00:05:31,579 --> 00:05:33,560
things, and you've all
used calculators.

96
00:05:33,560 --> 00:05:37,030
It has some buttons on
it and some lights.

97
00:05:37,029 --> 00:05:39,009
And so by pushing the various
buttons, you can cause

98
00:05:39,009 --> 00:05:42,079
operations to happen inside
there among the registers, and

99
00:05:42,079 --> 00:05:45,159
some of the results
to be displayed.

100
00:05:45,160 --> 00:05:46,250
That's completely mechanical.

101
00:05:46,250 --> 00:05:50,899
You could imagine that box has
no intelligence in it.

102
00:05:50,899 --> 00:05:52,399
Now it might be very impressive
that it can produce

103
00:05:52,399 --> 00:05:57,669
the sine of a number, but that
at least is apparently

104
00:05:57,670 --> 00:05:58,970
possibly mechanical.

105
00:05:58,970 --> 00:06:00,685
At least, I could open that
up in the same way I'm

106
00:06:00,685 --> 00:06:02,689
about to open GCD.

107
00:06:02,689 --> 00:06:04,829
So this may have a whole
computer inside of it, but

108
00:06:04,829 --> 00:06:05,939
that's not interesting.

109
00:06:05,939 --> 00:06:08,199
Addition is certainly simple.

110
00:06:08,199 --> 00:06:10,889
That can be done without
any further mechanism.

111
00:06:10,889 --> 00:06:15,079
Now also, if we were to look
at the other half, the

112
00:06:15,079 --> 00:06:18,189
controller, that's a part
that's dumb, too.

113
00:06:18,189 --> 00:06:20,350
It pushes the buttons.

114
00:06:20,350 --> 00:06:21,920
It pushes them according to the
sequence, which is written

115
00:06:21,920 --> 00:06:26,290
down on a piece of paper,
and observes the lights.

116
00:06:26,290 --> 00:06:29,210
And every so often, it comes to
a place in a sequence that

117
00:06:29,209 --> 00:06:32,370
says, if light A is on,
do this sequence.

118
00:06:32,370 --> 00:06:34,620
Otherwise, do that sequence.

119
00:06:34,620 --> 00:06:37,949
And thereby, there's no
complexity there either.

120
00:06:37,949 --> 00:06:42,509
Well, let's just draw that and
see what we feel about that.

121
00:06:42,509 --> 00:06:48,269
So for computing GCDs, what I
want you to think about is

122
00:06:48,269 --> 00:06:50,310
that there are these
registers.

123
00:06:50,310 --> 00:06:53,240
A register is a place where I
store a number, in this case.

124
00:06:53,240 --> 00:06:56,810
And this one's called a.

125
00:06:56,810 --> 00:06:58,699
And then there's another
one for storing b.

126
00:06:58,699 --> 00:07:03,170


127
00:07:03,170 --> 00:07:04,819
Now we have to see what things
we can do with these

128
00:07:04,819 --> 00:07:08,149
registers, and they're not
entirely obvious what you can

129
00:07:08,149 --> 00:07:09,839
do with them.

130
00:07:09,839 --> 00:07:10,939
Well, we have to see
what things we

131
00:07:10,939 --> 00:07:11,889
need to do with them.

132
00:07:11,889 --> 00:07:14,029
We're looking at the problem
we're trying to solve.

133
00:07:14,029 --> 00:07:17,099
One of the important things
for designing a computer,

134
00:07:17,100 --> 00:07:20,810
which I think most designers
don't do, is you study the

135
00:07:20,810 --> 00:07:23,910
problem you want to solve and
then use what you learn from

136
00:07:23,910 --> 00:07:25,970
studying the problem you want
to solve to put in the

137
00:07:25,970 --> 00:07:28,260
mechanisms needed to solve
it in the computer you're

138
00:07:28,259 --> 00:07:32,139
building, no more no less.

139
00:07:32,139 --> 00:07:34,439
Now it may be that the problem
you're trying to solve is

140
00:07:34,439 --> 00:07:37,199
everybody's problem, in which
case you have to build in a

141
00:07:37,199 --> 00:07:40,189
universal interpreter
of some language.

142
00:07:40,189 --> 00:07:42,579
But you shouldn't put any more
in than required to build the

143
00:07:42,579 --> 00:07:44,539
universal interpreter
of some language.

144
00:07:44,540 --> 00:07:47,025
We'll worry about that
in a second.

145
00:07:47,024 --> 00:07:49,929
OK, going back to
here, let's see.

146
00:07:49,930 --> 00:07:51,639
What do we have to
be able to do?

147
00:07:51,639 --> 00:07:56,579
Well, somehow, we have to be
able to get B into A. We have

148
00:07:56,579 --> 00:07:59,259
to be able to get the old value
of B into the value of

149
00:07:59,259 --> 00:08:03,339
A. So we have to have some path
by which stuff can flow,

150
00:08:03,339 --> 00:08:07,389
whatever this information
is, from b to a.

151
00:08:07,389 --> 00:08:10,519
I'm going to draw that with by
an arrow saying that it is

152
00:08:10,519 --> 00:08:13,639
possible to move the contents
of b into a, replacing the

153
00:08:13,639 --> 00:08:15,120
value of a.

154
00:08:15,120 --> 00:08:17,660
And there's a little button
here which you push which

155
00:08:17,660 --> 00:08:19,710
allows that to happen.

156
00:08:19,709 --> 00:08:23,069
That's what the little
x is here.

157
00:08:23,069 --> 00:08:25,110
Now it's also the case that I
have to be able to compute the

158
00:08:25,110 --> 00:08:27,000
remainder of a and b.

159
00:08:27,000 --> 00:08:28,860
Now that may be a complicated
mess.

160
00:08:28,860 --> 00:08:31,960
On the other hand, I'm going
to make it a small box.

161
00:08:31,959 --> 00:08:34,889
If we have to, we may open up
that box and look inside and

162
00:08:34,889 --> 00:08:37,740
see what it is.

163
00:08:37,740 --> 00:08:39,580
So here, I'm going to have a
little box, which I'm going to

164
00:08:39,580 --> 00:08:46,440
draw this way, which we'll
call the remainder.

165
00:08:46,440 --> 00:08:48,265
And it's going to take in a.

166
00:08:48,264 --> 00:08:50,909


167
00:08:50,909 --> 00:08:54,370
That's going to take in b.

168
00:08:54,370 --> 00:08:59,659
And it's going to put out
something, the remainder of a

169
00:08:59,659 --> 00:09:02,289
divided by b.

170
00:09:02,289 --> 00:09:04,049
Another thing we have to see
here is that we have to be

171
00:09:04,049 --> 00:09:08,000
able to test whether
b is equal to 0.

172
00:09:08,000 --> 00:09:10,019
Well, that means somebody's
got to be looking at--

173
00:09:10,019 --> 00:09:13,389
a thing that's looking
at the value of b.

174
00:09:13,389 --> 00:09:17,389
I have a light bulb here which
lights up if b equals 0.

175
00:09:17,389 --> 00:09:21,110


176
00:09:21,110 --> 00:09:24,029
That's its job.

177
00:09:24,029 --> 00:09:27,250
And finally, I suppose, because
of the fact that we

178
00:09:27,250 --> 00:09:30,639
want the new value of a to be
the old value of b, and

179
00:09:30,639 --> 00:09:33,819
simultaneously the new value of
b to be something I've done

180
00:09:33,820 --> 00:09:38,160
with a, and if I plan to make
my machine such that

181
00:09:38,159 --> 00:09:41,620
everything happens one at a
time, one motion at a time,

182
00:09:41,620 --> 00:09:44,525
and I can't put two numbers in
a register, then I have to

183
00:09:44,525 --> 00:09:46,299
have another place to put one
while I'm interchanging.

184
00:09:46,299 --> 00:09:49,533


185
00:09:49,533 --> 00:09:50,000
OK?

186
00:09:50,000 --> 00:09:52,490
I can't interchange the two
things in my hands, unless I

187
00:09:52,490 --> 00:09:54,730
either put two in one hand and
then pull it back the other

188
00:09:54,730 --> 00:09:57,960
way, or unless I put one down,
pick it up, and put the other

189
00:09:57,960 --> 00:10:02,930
one, like that, unless I'm a
juggler, which I'm not, as you

190
00:10:02,929 --> 00:10:06,199
can see, in which case I have a

191
00:10:06,200 --> 00:10:08,850
possibility of timing errors.

192
00:10:08,850 --> 00:10:11,500
In fact, much of the type of
computer design people do

193
00:10:11,500 --> 00:10:15,259
involves timing errors, of some
potential timing errors,

194
00:10:15,259 --> 00:10:17,840
which I don't much like.

195
00:10:17,840 --> 00:10:22,500
So for that reason, I have to
have a place to put the second

196
00:10:22,500 --> 00:10:23,409
one of them down.

197
00:10:23,409 --> 00:10:25,819
So I have a place called t,
which is a register just for

198
00:10:25,820 --> 00:10:30,470
temporary, t, with
a button on it.

199
00:10:30,470 --> 00:10:32,450
And then I'll take the result of
that, since I have to take

200
00:10:32,450 --> 00:10:35,640
that and put into b, over here,
we'll take the result of

201
00:10:35,639 --> 00:10:39,299
that and go like this,
and a button here.

202
00:10:39,299 --> 00:10:42,429


203
00:10:42,429 --> 00:10:47,599
So that's the datapaths
of a GCD machine.

204
00:10:47,600 --> 00:10:49,740
Now what's the controller?

205
00:10:49,740 --> 00:10:52,279
Controller's a very
simple thing, too.

206
00:10:52,279 --> 00:10:53,709
The machine has a state.

207
00:10:53,710 --> 00:10:59,009
The way I like to visualize that
is that I've got a maze.

208
00:10:59,009 --> 00:11:01,679
And the maze has a
bunch of places

209
00:11:01,679 --> 00:11:04,429
connected by directed arrows.

210
00:11:04,429 --> 00:11:08,429
And what I have is a marble,
which represents the state of

211
00:11:08,429 --> 00:11:10,739
the controller.

212
00:11:10,740 --> 00:11:13,255
The marble rolls around
in the maze.

213
00:11:13,255 --> 00:11:17,149
Of course, this analogy breaks
down for energy reasons.

214
00:11:17,149 --> 00:11:19,309
I sometimes have to pump the
marble up to the top, because

215
00:11:19,309 --> 00:11:22,000
it's going to otherwise be a
perpetual motion machine.

216
00:11:22,000 --> 00:11:24,269
But not worrying about
that, this is

217
00:11:24,269 --> 00:11:26,079
not a physical analogy.

218
00:11:26,080 --> 00:11:27,680
This marble rolls around.

219
00:11:27,679 --> 00:11:30,179
And every time it rolls around
certain bumpers, like in a

220
00:11:30,179 --> 00:11:34,829
pinball machine, it pushes
one of these buttons.

221
00:11:34,830 --> 00:11:36,810
And every so often, it comes
to a place, which is a

222
00:11:36,809 --> 00:11:40,250
division, where it has
to make a choice.

223
00:11:40,250 --> 00:11:42,360
And there's a flap, which
is controlled by this.

224
00:11:42,360 --> 00:11:46,000


225
00:11:46,000 --> 00:11:48,820
So that's a really mechanical
way of thinking about it.

226
00:11:48,820 --> 00:11:50,980
Of course, controllers these
days, are not built that way

227
00:11:50,980 --> 00:11:51,840
in real computers.

228
00:11:51,840 --> 00:11:54,090
They're built with
a little bit of

229
00:11:54,090 --> 00:11:56,610
ROM and a state register.

230
00:11:56,610 --> 00:11:59,725
But there was a time, like the
DEC PDP-6, where that's how

231
00:11:59,725 --> 00:12:01,399
you built the controller
of a machine.

232
00:12:01,399 --> 00:12:06,799
There was a bit that ran around
the delay line, and it

233
00:12:06,799 --> 00:12:08,579
triggered things
as it went by.

234
00:12:08,580 --> 00:12:09,860
And it would come back
to the beginning and

235
00:12:09,860 --> 00:12:11,990
get fed round again.

236
00:12:11,990 --> 00:12:13,629
And of course, there were all
sorts of great bugs you could

237
00:12:13,629 --> 00:12:17,669
have like two bits going
around, two marbles.

238
00:12:17,669 --> 00:12:19,259
And then the machine has
lost its marbles.

239
00:12:19,259 --> 00:12:20,980
That happens, too.

240
00:12:20,980 --> 00:12:21,935
Oh, well.

241
00:12:21,934 --> 00:12:24,569
So anyway, for this machine,
what I have

242
00:12:24,570 --> 00:12:25,940
to do is the following.

243
00:12:25,940 --> 00:12:27,690
I'm going to start
my maze here.

244
00:12:27,690 --> 00:12:30,520


245
00:12:30,519 --> 00:12:35,460
And the first thing I've got
to do, in a notation which

246
00:12:35,460 --> 00:12:41,540
many of you are familiar with,
is b equal to zero, a test.

247
00:12:41,539 --> 00:12:44,539
And there's a possibility,
either yes, in

248
00:12:44,539 --> 00:12:45,789
which case I'm done.

249
00:12:45,789 --> 00:12:49,789


250
00:12:49,789 --> 00:12:53,219
Otherwise, if no, then
I'm going have to

251
00:12:53,220 --> 00:12:54,725
roll over some bumpers.

252
00:12:54,725 --> 00:12:57,420
I'm going to do it in
the following order.

253
00:12:57,419 --> 00:13:04,049
I want to do this interchange
game.

254
00:13:04,049 --> 00:13:07,359
Now first, since I need both a
and b, but then the first--

255
00:13:07,360 --> 00:13:08,669
and this is not necessary--

256
00:13:08,669 --> 00:13:11,069
I want to collect this.

257
00:13:11,070 --> 00:13:13,240
This is the thing that's
going to go into b.

258
00:13:13,240 --> 00:13:15,680
So I'm going to say, take this,
which depends upon both

259
00:13:15,679 --> 00:13:19,149
a and b, and put the remainder
into here.

260
00:13:19,149 --> 00:13:22,939
So I'm going to push this button
first. Then, I'm going

261
00:13:22,940 --> 00:13:26,460
to transfer b to a, push that
button, and then I transfer

262
00:13:26,460 --> 00:13:32,030
the temporary into b,
push that button.

263
00:13:32,029 --> 00:13:37,750
So a very sequential machine,
it's very inefficient.

264
00:13:37,750 --> 00:13:39,809
But that's fine right now.

265
00:13:39,809 --> 00:13:42,304
We're going to name the buttons,
t gets remainder.

266
00:13:42,304 --> 00:13:46,750


267
00:13:46,750 --> 00:13:50,035
a gets b.

268
00:13:50,035 --> 00:13:55,469
And b gets t.

269
00:13:55,470 --> 00:13:59,149
And then I'm going to go around
here and it's to go

270
00:13:59,149 --> 00:14:01,620
back to start.

271
00:14:01,620 --> 00:14:03,870
And if you look, what
are we seeing here?

272
00:14:03,870 --> 00:14:05,080
We're seeing the various--

273
00:14:05,080 --> 00:14:07,400
what I really have is some sort
of mechanical connection,

274
00:14:07,399 --> 00:14:13,620
where t gets r controls
this thing.

275
00:14:13,620 --> 00:14:16,830


276
00:14:16,830 --> 00:14:20,910
And I have here that a gets b
controls this fellow over

277
00:14:20,909 --> 00:14:28,120
here, and this fellow
over here.

278
00:14:28,120 --> 00:14:31,090
Boy, that's absolutely
pessimal,

279
00:14:31,090 --> 00:14:32,629
the inverse of optimal.

280
00:14:32,629 --> 00:14:34,590
Every line heads across every
other line the way I drew it.

281
00:14:34,590 --> 00:14:38,540


282
00:14:38,539 --> 00:14:41,149
I suppose this goes
here, b gets t.

283
00:14:41,149 --> 00:14:45,689


284
00:14:45,690 --> 00:14:48,040
Now I'd like to run
this machine.

285
00:14:48,039 --> 00:14:50,259
But before I run the machine,
I want to write down a

286
00:14:50,259 --> 00:14:52,242
description of this controller,
just so you can

287
00:14:52,243 --> 00:14:54,160
see that these things, of
course, as usual, can be

288
00:14:54,159 --> 00:14:56,559
written down in some nice
language, so that we don't

289
00:14:56,559 --> 00:14:59,009
have to always draw these
diagrams. One of the problems

290
00:14:59,009 --> 00:15:00,710
with diagrams is that they
take up a lot of space.

291
00:15:00,710 --> 00:15:03,220
And for a machine this small,
it takes two blackboards.

292
00:15:03,220 --> 00:15:05,690
For a machine that's the
evaluator machine, I have

293
00:15:05,690 --> 00:15:08,320
trouble putting it into
this room, even though

294
00:15:08,320 --> 00:15:09,900
it isn't very big.

295
00:15:09,899 --> 00:15:11,549
So I'm going to make a little
language for this that's just

296
00:15:11,549 --> 00:15:17,529
a description of that,
saying define a

297
00:15:17,529 --> 00:15:24,419
machine we'll call GCD.

298
00:15:24,419 --> 00:15:25,969
Of course, once we have
something like this, we have a

299
00:15:25,970 --> 00:15:27,220
simulator for it.

300
00:15:27,220 --> 00:15:29,629
And the reason why we want to
build a language in this form,

301
00:15:29,629 --> 00:15:31,500
is because all of a sudden
we can manipulate these

302
00:15:31,500 --> 00:15:33,210
expressions that I'm
writing down.

303
00:15:33,210 --> 00:15:35,970
And then of course I can write
things that can algebraically

304
00:15:35,970 --> 00:15:38,730
manipulate these things,
simulate them, all that sort

305
00:15:38,730 --> 00:15:41,254
of things that I might want to
do, perhaps transform them as

306
00:15:41,254 --> 00:15:43,629
a layout, who knows.

307
00:15:43,629 --> 00:15:48,184
Once I have a nice
representation of registers,

308
00:15:48,184 --> 00:15:56,325
it has certain registers, which
we can call A, B, and T.

309
00:15:56,326 --> 00:15:57,576
And there's a controller.

310
00:15:57,576 --> 00:16:02,190


311
00:16:02,190 --> 00:16:04,910
Actually, a better language,
which would be more explicit,

312
00:16:04,909 --> 00:16:09,439
would be one which named
every button also and

313
00:16:09,440 --> 00:16:10,420
said what it did.

314
00:16:10,419 --> 00:16:13,389
Like, this button causes the
contents of T to go to the

315
00:16:13,389 --> 00:16:16,309
contents of B. Well I don't want
to do that, because it's

316
00:16:16,309 --> 00:16:18,409
actually harder to read
to do that, and it

317
00:16:18,409 --> 00:16:19,509
takes up more space.

318
00:16:19,509 --> 00:16:21,710
So I'm going to have that in
the instructions written in

319
00:16:21,710 --> 00:16:23,290
the controller.

320
00:16:23,289 --> 00:16:26,459
It's going to be implicit
what the operations are.

321
00:16:26,460 --> 00:16:29,990
They can be deduced by reading
these and collecting together

322
00:16:29,990 --> 00:16:33,500
all the different things
that can be done.

323
00:16:33,500 --> 00:16:35,481
Well, let's just look at
what these things are.

324
00:16:35,481 --> 00:16:42,549
There's a little loop that we
go around which says branch,

325
00:16:42,549 --> 00:16:47,429
this is the representation of
the little flap that decides

326
00:16:47,429 --> 00:16:58,009
which way you go here, if 0
fetch of B, the contents of B,

327
00:16:58,009 --> 00:17:00,789
and if the contents of
B is 0, then go to a

328
00:17:00,789 --> 00:17:03,639
place called done.

329
00:17:03,639 --> 00:17:06,029
Now, one thing you're seeing
here, this looks very much

330
00:17:06,029 --> 00:17:08,170
like a traditional computer
language.

331
00:17:08,170 --> 00:17:13,099
And what you're seeing here
is things like labels that

332
00:17:13,098 --> 00:17:17,608
represent places in a sequence
written down as a sequence.

333
00:17:17,608 --> 00:17:21,699
The reason why they're needed
is because over here, I've

334
00:17:21,700 --> 00:17:23,328
written something with loops.

335
00:17:23,328 --> 00:17:26,568
But if I'm writing English text,
or something like that,

336
00:17:26,568 --> 00:17:28,579
it's hard to refer to a place.

337
00:17:28,579 --> 00:17:31,439
I don't have arrows.

338
00:17:31,440 --> 00:17:33,450
Arrows are represented by giving
names to the places

339
00:17:33,450 --> 00:17:35,680
where the arrows terminate, and
then referring to them by

340
00:17:35,680 --> 00:17:37,620
those names.

341
00:17:37,619 --> 00:17:39,859
Now this is just an encoding.

342
00:17:39,859 --> 00:17:43,149
There's nothing magical about
things like that.

343
00:17:43,150 --> 00:17:45,310
Next thing we're going to do is
we're going to say, how do

344
00:17:45,309 --> 00:17:46,839
we do T gets R?

345
00:17:46,839 --> 00:17:49,029
Oh, that's easy enough,
assign.

346
00:17:49,029 --> 00:17:51,930


347
00:17:51,930 --> 00:17:56,400
We assign to T the remainder.

348
00:17:56,400 --> 00:18:01,470
Assign is the name
of the button.

349
00:18:01,470 --> 00:18:03,140
That's the button-pusher.

350
00:18:03,140 --> 00:18:05,910
Assign to T the remainder, and
here's the representation of

351
00:18:05,910 --> 00:18:17,550
the operation, when we divide
the fetch of A by the fetch of

352
00:18:17,549 --> 00:18:23,478
B.

353
00:18:23,478 --> 00:18:35,560
And we're also going to assign
to A the fetch of B, assign to

354
00:18:35,559 --> 00:18:50,139
B the result of getting the
contents of T. And now I have

355
00:18:50,140 --> 00:18:53,280
to refer to the beginning
here.

356
00:18:53,279 --> 00:18:55,759
I see, why don't I call that
loop like I have here?

357
00:18:55,759 --> 00:19:05,390


358
00:19:05,390 --> 00:19:07,610
So that's that reference
to that arrow.

359
00:19:07,609 --> 00:19:08,949
And when we're done,
we're done.

360
00:19:08,950 --> 00:19:14,340
We go to here, which is
the end of the thing.

361
00:19:14,339 --> 00:19:18,089
So here's just a written
representation of this

362
00:19:18,089 --> 00:19:21,659
fragment of machinery that
we've drawn here.

363
00:19:21,660 --> 00:19:25,490
Now the next thing I'd like
to do is run this.

364
00:19:25,490 --> 00:19:27,620
I want us to feel it running.

365
00:19:27,619 --> 00:19:31,009
Never done this before,
you got to do it once.

366
00:19:31,009 --> 00:19:33,099
So let's take a particular
problem.

367
00:19:33,099 --> 00:19:38,579
Suppose we want to compute
the GCD of a equals 30

368
00:19:38,579 --> 00:19:42,210
and b equals 42.

369
00:19:42,210 --> 00:19:45,860
I have no idea what
that is right now.

370
00:19:45,859 --> 00:19:50,529
But a 30 and b is 42.

371
00:19:50,529 --> 00:19:52,410
So that's how I start
this thing up.

372
00:19:52,410 --> 00:19:54,240
Well, what's the first
thing I do?

373
00:19:54,240 --> 00:19:57,589
I say is B equal to 0, no.

374
00:19:57,589 --> 00:20:01,500
Then assign to T the remainder
of the fetch of A and the

375
00:20:01,500 --> 00:20:05,640
fetch of B. Well the remainder
of 30 when divided by

376
00:20:05,640 --> 00:20:11,130
42 is itself 30.

377
00:20:11,130 --> 00:20:12,920
Push that button.

378
00:20:12,920 --> 00:20:17,100
Now the marble has
rolled to here.

379
00:20:17,099 --> 00:20:21,219
A gets B. That pushes
this button.

380
00:20:21,220 --> 00:20:26,360
So 42 moves into here.

381
00:20:26,359 --> 00:20:29,869
B gets C. Push that button.

382
00:20:29,869 --> 00:20:32,224
The 30 goes here.

383
00:20:32,224 --> 00:20:34,659
Let met just interchange them.

384
00:20:34,660 --> 00:20:38,279
Now let's see, go back
to the beginning.

385
00:20:38,279 --> 00:20:40,200
B 0, no.

386
00:20:40,200 --> 00:20:43,230
T gets the remainder.

387
00:20:43,230 --> 00:20:47,240
I suppose the remainder when
dividing 42 by 30 is 12.

388
00:20:47,240 --> 00:20:48,529
I push that one.

389
00:20:48,529 --> 00:20:54,359
Next thing I do is allow the
30 to go to here, push this

390
00:20:54,359 --> 00:20:55,949
one, allow the 12
to go to here.

391
00:20:55,950 --> 00:20:59,549


392
00:20:59,549 --> 00:21:00,379
Go around this thing.

393
00:21:00,380 --> 00:21:01,530
Is that done?

394
00:21:01,529 --> 00:21:02,359
No.

395
00:21:02,359 --> 00:21:05,079
How about--

396
00:21:05,079 --> 00:21:08,849
so now I have to find out the
remainder of 30 divided by 12.

397
00:21:08,849 --> 00:21:12,419
And I believe that's 6.

398
00:21:12,420 --> 00:21:15,916
So 6 goes here on this
button push.

399
00:21:15,915 --> 00:21:18,549
Then the next thing I push
is this one, which the

400
00:21:18,549 --> 00:21:23,730
12 goes into here.

401
00:21:23,730 --> 00:21:25,089
Then I push this button.

402
00:21:25,089 --> 00:21:26,339
The 6 gets into here.

403
00:21:26,339 --> 00:21:29,849


404
00:21:29,849 --> 00:21:32,099
Is 6 equal to 0?

405
00:21:32,099 --> 00:21:33,419
No.

406
00:21:33,420 --> 00:21:34,380
OK.

407
00:21:34,380 --> 00:21:38,380
So then at that point, the next
thing to do is divide it.

408
00:21:38,380 --> 00:21:40,660
Ooh, this has got a
remainder of 0.

409
00:21:40,660 --> 00:21:42,360
Looks like we're almost done.

410
00:21:42,359 --> 00:21:44,359
Move the 6 over here next.

411
00:21:44,359 --> 00:21:47,229


412
00:21:47,230 --> 00:21:49,089
0 over here.

413
00:21:49,089 --> 00:21:50,199
Is the answer 0?

414
00:21:50,200 --> 00:21:51,340
Yes.

415
00:21:51,339 --> 00:21:54,470
B is 0, therefore the
answer is in A.

416
00:21:54,470 --> 00:21:56,610
The answer is 6.

417
00:21:56,609 --> 00:21:58,399
And indeed that's right, because
if we look at the

418
00:21:58,400 --> 00:22:07,060
original problem, what we have
is 30 is 2 times 3 times 5,

419
00:22:07,059 --> 00:22:11,669
and 42 is 2 times 3 times 7.

420
00:22:11,670 --> 00:22:15,090
So the greatest common divisor
is 2 times 3, which is 6.

421
00:22:15,089 --> 00:22:18,379


422
00:22:18,380 --> 00:22:20,780
Now normally, we write one other
little line here, just

423
00:22:20,779 --> 00:22:23,769
to make it a little bit clearer,
which is that we

424
00:22:23,769 --> 00:22:29,759
leave in a connection saying
that this light is the guy

425
00:22:29,759 --> 00:22:31,009
that that flap looks at.

426
00:22:31,009 --> 00:22:34,049


427
00:22:34,049 --> 00:22:38,440
Of course, any real machine
has a lot more complicated

428
00:22:38,440 --> 00:22:41,350
things in it than what
I've just shown you.

429
00:22:41,349 --> 00:22:47,980
Let's look for a second at
the first still store.

430
00:22:47,980 --> 00:22:50,190
Wow.

431
00:22:50,190 --> 00:22:52,850
Well you see, for example, one
thing we might want to do is

432
00:22:52,849 --> 00:22:56,839
worry about the operations
that are of IO form.

433
00:22:56,839 --> 00:23:01,980
And we may have to collect
something from the outside.

434
00:23:01,980 --> 00:23:06,309
So a state machine that we might
have, the controller may

435
00:23:06,309 --> 00:23:11,190
have to, for example, get a
value from something and put

436
00:23:11,190 --> 00:23:13,490
register a to load it up.

437
00:23:13,490 --> 00:23:17,069
I have to master load up
register b with another value.

438
00:23:17,069 --> 00:23:19,899
And then later, when I'm done,
I might want to print the

439
00:23:19,900 --> 00:23:20,970
answer out.

440
00:23:20,970 --> 00:23:26,250
And of course, that might be
either simple or complicated.

441
00:23:26,250 --> 00:23:28,319
I'm writing, assuming print
is very simple, and

442
00:23:28,319 --> 00:23:29,879
read is very simple.

443
00:23:29,880 --> 00:23:31,700
But in fact, in the real
world, those are very

444
00:23:31,700 --> 00:23:34,930
complicated operations, usually
much, much larger and

445
00:23:34,930 --> 00:23:37,080
more complicated than the thing
you're doing as your

446
00:23:37,079 --> 00:23:38,329
problem you're trying
to solve.

447
00:23:38,329 --> 00:23:41,669


448
00:23:41,670 --> 00:23:45,060
On the other hand, I can
remember a time when, I

449
00:23:45,059 --> 00:23:49,319
remember using IBM 7090 computer
of sorts, where

450
00:23:49,319 --> 00:23:53,599
things like read and write of
a single object, a single

451
00:23:53,599 --> 00:23:58,039
number, a number, is a primitive
operation of the IO

452
00:23:58,039 --> 00:23:59,065
controller.

453
00:23:59,065 --> 00:24:00,400
OK?

454
00:24:00,400 --> 00:24:02,330
And so we have that kind
of thing in there.

455
00:24:02,329 --> 00:24:08,359
And in such a machine, well,
what are we really doing?

456
00:24:08,359 --> 00:24:11,109
We're just saying that there's
a source over here called

457
00:24:11,109 --> 00:24:14,659
"read," which is an operation
which always has a value.

458
00:24:14,660 --> 00:24:17,480
We have to think about this as
always having a value which

459
00:24:17,480 --> 00:24:21,660
can be gated into either
register a or b.

460
00:24:21,660 --> 00:24:24,290
And print is some sort of thing
which when you gate it

461
00:24:24,289 --> 00:24:27,409
appropriately, when you push the
button on it, will cause a

462
00:24:27,410 --> 00:24:31,660
print of the value that's
currently in register a.

463
00:24:31,660 --> 00:24:33,050
Nothing very exciting.

464
00:24:33,049 --> 00:24:36,109
So that's one sort of thing you
might want to have. But

465
00:24:36,109 --> 00:24:37,259
these are also other
things that are

466
00:24:37,259 --> 00:24:38,319
a little bit worrisome.

467
00:24:38,319 --> 00:24:41,049
Like I've used here some
complicated mechanisms.

468
00:24:41,049 --> 00:24:43,849
What you see here
is remainder.

469
00:24:43,849 --> 00:24:44,689
What is that?

470
00:24:44,690 --> 00:24:46,920
That may not be so obvious
how to compute.

471
00:24:46,920 --> 00:24:49,860
It may be something which when
you open it up, you get a

472
00:24:49,859 --> 00:24:51,879
whole machine.

473
00:24:51,880 --> 00:24:52,720
OK?

474
00:24:52,720 --> 00:24:54,539
In fact, that's true.

475
00:24:54,539 --> 00:24:59,569
For example, if I write down the
program for remainder, the

476
00:24:59,569 --> 00:25:04,480
simplest program for it is
by repeated subtraction.

477
00:25:04,480 --> 00:25:06,380
Because of course, division
can be done by repeated

478
00:25:06,380 --> 00:25:09,800
subtraction of numbers,
of integers.

479
00:25:09,799 --> 00:25:30,269
So the remainder of N divided by
D is nothing more than if N

480
00:25:30,269 --> 00:25:34,920
is less than D, then the result
is N. Otherwise, it's

481
00:25:34,920 --> 00:25:48,350
the remainder when we subtract
D from N with respect to D,

482
00:25:48,349 --> 00:25:52,159
when divided by D. Gee,
this looks just

483
00:25:52,160 --> 00:25:56,890
like the GCD program.

484
00:25:56,890 --> 00:25:59,750
Of course, it's not a very nice
way to do remainders.

485
00:25:59,750 --> 00:26:01,525
You'd really want to use
something like binary notation

486
00:26:01,525 --> 00:26:05,550
and shift and things like that
in a practical computer.

487
00:26:05,549 --> 00:26:09,059
But the point of that is that
if I open this thing up, I

488
00:26:09,059 --> 00:26:11,879
might find inside of
it a computer.

489
00:26:11,880 --> 00:26:13,510
Oh, we know how to do that.

490
00:26:13,509 --> 00:26:15,640
We just made one.

491
00:26:15,640 --> 00:26:17,400
And it could be another
thing just like this.

492
00:26:17,400 --> 00:26:20,030
On the other hand, we might want
to make a more efficient

493
00:26:20,029 --> 00:26:22,809
or better-structured machine,
or maybe make use of some of

494
00:26:22,809 --> 00:26:25,339
the registers more than once,
or some horrible mess like

495
00:26:25,339 --> 00:26:27,549
that that hardware designers
like to do, and

496
00:26:27,549 --> 00:26:29,250
for very good reasons.

497
00:26:29,250 --> 00:26:32,990
So for example, here's a machine
that you see, which

498
00:26:32,990 --> 00:26:35,049
you're not supposed to
be able to read.

499
00:26:35,049 --> 00:26:37,519
It's a little bit complicated.

500
00:26:37,519 --> 00:26:41,829
But what it is is the
integration of the remainder

501
00:26:41,829 --> 00:26:44,210
into the GCD machine.

502
00:26:44,210 --> 00:26:46,019
And it takes, in fact,
no more registers.

503
00:26:46,019 --> 00:26:48,359
There are three registers
in the datapaths.

504
00:26:48,359 --> 00:26:49,049
OK?

505
00:26:49,049 --> 00:26:51,549
But now there's a subtractor.

506
00:26:51,549 --> 00:26:53,019
There are two things
that are tested.

507
00:26:53,019 --> 00:26:57,250
Is b equal to 0, or
is t less than b?

508
00:26:57,250 --> 00:27:00,799
And then the controller, which
you see over here, is not much

509
00:27:00,799 --> 00:27:01,849
more complicated.

510
00:27:01,849 --> 00:27:07,039
But it has two loops in it, one
of which is the main one

511
00:27:07,039 --> 00:27:10,369
for doing the GCD, and one of
which is the subtraction loop

512
00:27:10,369 --> 00:27:14,029
for doing the remainder
sub-operation.

513
00:27:14,029 --> 00:27:17,190
And there are ways, of course,
of, if you think about it,

514
00:27:17,190 --> 00:27:19,920
taking the remainder program.

515
00:27:19,920 --> 00:27:22,269
If I take remainder, as you see
over there, as a lambda

516
00:27:22,269 --> 00:27:25,920
expression, substitute it in for
remainder over here in the

517
00:27:25,920 --> 00:27:30,910
GCD program, then do some
simplification by substituting

518
00:27:30,910 --> 00:27:34,670
a and b for remainder
in there, then I

519
00:27:34,670 --> 00:27:36,630
can unwind this loop.

520
00:27:36,630 --> 00:27:41,660
And I can get this piece of
machinery by basically, a

521
00:27:41,660 --> 00:27:44,700
little bit of algebraic
simplification on the lambda

522
00:27:44,700 --> 00:27:45,950
expressions.

523
00:27:45,950 --> 00:27:48,549


524
00:27:48,549 --> 00:27:50,139
So I suppose you've seen
your first very

525
00:27:50,140 --> 00:27:52,280
simple machines now.

526
00:27:52,279 --> 00:27:53,529
Are there any questions?

527
00:27:53,529 --> 00:28:02,700


528
00:28:02,700 --> 00:28:05,360
Good.

529
00:28:05,359 --> 00:28:06,609
This looks easy, doesn't it?

530
00:28:06,609 --> 00:28:10,199


531
00:28:10,200 --> 00:28:10,549
Thank you.

532
00:28:10,549 --> 00:28:11,349
I suppose, take a break.

533
00:28:11,349 --> 00:28:11,759
[MUSIC PLAYING - "JESU, JOY OF
MAN'S DESIRING" BY JOHANN

534
00:28:11,759 --> 00:28:13,009
SEBASTIAN BACH]

535
00:28:13,009 --> 00:28:47,309


536
00:28:47,309 --> 00:28:49,480
PROFESSOR: Well, let's see.

537
00:28:49,480 --> 00:28:52,750
Now you know how to make an
iterative procedure, or a

538
00:28:52,750 --> 00:28:53,930
procedure that yields
an iterative

539
00:28:53,930 --> 00:28:57,769
process, turn into a machine.

540
00:28:57,769 --> 00:28:59,750
I suppose the next thing we
want to do is worry about

541
00:28:59,750 --> 00:29:02,690
things that reveal recursive
processes.

542
00:29:02,690 --> 00:29:04,695
So let's play with a simple
factorial procedure.

543
00:29:04,694 --> 00:29:10,894


544
00:29:10,894 --> 00:29:24,690
We define factorial of N to be
if n is 1, the result is 1,

545
00:29:24,690 --> 00:29:26,830
using 1 right now to decrease
the amount of work I have to

546
00:29:26,829 --> 00:29:33,939
do to simulate it, else it's
times N factorial N minus 1.

547
00:29:33,940 --> 00:29:42,519


548
00:29:42,519 --> 00:29:47,440
And what's different with this
program, as you know, is that

549
00:29:47,440 --> 00:29:51,049
after I've computed factorial
of N minus 1 here, I have to

550
00:29:51,049 --> 00:29:52,259
do something to the result.

551
00:29:52,259 --> 00:29:56,000
I have to multiply it by N.

552
00:29:56,000 --> 00:30:00,160
So the only way I can visualize
what this machine is

553
00:30:00,160 --> 00:30:02,360
doing, because of the fact--

554
00:30:02,359 --> 00:30:05,319
think of it this way, that I
have a machine out here which

555
00:30:05,319 --> 00:30:07,529
somehow needs a factorial
machine in order to compute

556
00:30:07,529 --> 00:30:09,319
its answer.

557
00:30:09,319 --> 00:30:12,549
But this machine, the outer
machine, has to exist before

558
00:30:12,549 --> 00:30:16,799
and after the factorial machine,
which is inside.

559
00:30:16,799 --> 00:30:20,079
Whereas in the iterative case,
the outer machine doesn't need

560
00:30:20,079 --> 00:30:25,169
to exist after the inner machine
is running, because

561
00:30:25,170 --> 00:30:26,580
you never need to go
back to the outer

562
00:30:26,579 --> 00:30:28,639
machine to do anything.

563
00:30:28,640 --> 00:30:31,200
So here we have a problem where
we have a machine which

564
00:30:31,200 --> 00:30:34,090
has the same machine
inside of it, an

565
00:30:34,089 --> 00:30:35,339
infinitely large machine.

566
00:30:35,339 --> 00:30:40,389


567
00:30:40,390 --> 00:30:42,310
And it's got other things
inside of it, like a

568
00:30:42,309 --> 00:30:47,240
multiplier, which takes some
inputs, and there's a minus 1

569
00:30:47,240 --> 00:30:50,690
box, and things like that.

570
00:30:50,690 --> 00:30:54,370
You can imagine that's
what it looks like.

571
00:30:54,369 --> 00:30:57,339
But the important thing is that
here I have something

572
00:30:57,339 --> 00:31:00,359
that happens before and after,
in the outer machine, the

573
00:31:00,359 --> 00:31:02,539
execution of the
inner machine.

574
00:31:02,539 --> 00:31:05,569
So this machine has
to have a life.

575
00:31:05,569 --> 00:31:13,490
It has to exist on both times
sides of this machine.

576
00:31:13,490 --> 00:31:16,769
So somehow, I have to have a
place to store the things that

577
00:31:16,769 --> 00:31:20,029
this thing needs to run.

578
00:31:20,029 --> 00:31:24,139
Infinite objects don't exist
in the real world.

579
00:31:24,140 --> 00:31:27,020
What we have to do is arrange
an illusion that we have an

580
00:31:27,019 --> 00:31:28,539
infinite object, we
have an infinite

581
00:31:28,539 --> 00:31:31,829
amount of hardware somewhere.

582
00:31:31,829 --> 00:31:36,279
Now of course, illusion's
all that really matters.

583
00:31:36,279 --> 00:31:39,369
If we can arrange that every
time you look at some infinite

584
00:31:39,369 --> 00:31:44,799
object, the part of it that
you look at is there, then

585
00:31:44,799 --> 00:31:47,389
it's as infinite as
you need it to be.

586
00:31:47,390 --> 00:31:49,830
And of course, one of the things
we might want to do,

587
00:31:49,829 --> 00:31:53,889
just look at this thing over
here, is the organization that

588
00:31:53,890 --> 00:32:01,390
we've had so far involves having
a part of the machine,

589
00:32:01,390 --> 00:32:05,140
which is the controller, which
sits right over here, which is

590
00:32:05,140 --> 00:32:09,170
perfectly finite and
very simple.

591
00:32:09,170 --> 00:32:11,070
We have some datapaths,
which consist of

592
00:32:11,069 --> 00:32:13,079
registers and operators.

593
00:32:13,079 --> 00:32:16,189
And what I propose to do here is
decompose the machine into

594
00:32:16,190 --> 00:32:19,259
two parts, such that there is a
part which is fundamentally

595
00:32:19,259 --> 00:32:22,769
finite, and some part where a
certain amount of infinite

596
00:32:22,769 --> 00:32:24,230
stuff can be kept.

597
00:32:24,230 --> 00:32:27,049
On the other hand this is very
simple and really isn't

598
00:32:27,049 --> 00:32:29,430
infinite, but it's
just very large.

599
00:32:29,430 --> 00:32:31,840
But it's so simple that it could
be cheaply reproduced in

600
00:32:31,839 --> 00:32:37,549
such large amounts, we call it
memory, that we can make a

601
00:32:37,549 --> 00:32:40,710
structure called a stack out of
it which will allow us to,

602
00:32:40,710 --> 00:32:43,279
in fact, simulate the existence
of an infinite

603
00:32:43,279 --> 00:32:44,649
machine which is made
out of a recursive

604
00:32:44,650 --> 00:32:48,340
nest of many machines.

605
00:32:48,339 --> 00:32:51,759
And the way it's going to work
is that we're going to store

606
00:32:51,759 --> 00:32:56,289
in this place called the stack
the information required after

607
00:32:56,289 --> 00:33:00,399
the inner machine runs to resume
the operation of the

608
00:33:00,400 --> 00:33:01,650
outer machine.

609
00:33:01,650 --> 00:33:03,840


610
00:33:03,839 --> 00:33:06,759
So it will remember the
important things about the

611
00:33:06,759 --> 00:33:09,509
life of the outer machine that
will be needed for this

612
00:33:09,509 --> 00:33:11,390
computation.

613
00:33:11,390 --> 00:33:15,380
Since, of course, these machines
are nested in a

614
00:33:15,380 --> 00:33:20,320
recursive manner, then in fact
the stack will only be

615
00:33:20,319 --> 00:33:25,329
accessed in a manner which is
the last thing that goes in is

616
00:33:25,329 --> 00:33:26,579
the first thing that
comes out.

617
00:33:26,579 --> 00:33:29,329


618
00:33:29,329 --> 00:33:31,509
So we'll only need to access
some little part

619
00:33:31,509 --> 00:33:34,930
of this stack memory.

620
00:33:34,930 --> 00:33:36,810
OK, well, let's do it.

621
00:33:36,809 --> 00:33:38,750
I'm going to build you a
datapath now, and I'm going to

622
00:33:38,750 --> 00:33:40,369
write the controller.

623
00:33:40,369 --> 00:33:42,089
And then we're going
to execute this to

624
00:33:42,089 --> 00:33:43,509
see how you do it.

625
00:33:43,509 --> 00:33:47,900
So the factorial machine
isn't so bad.

626
00:33:47,900 --> 00:33:52,660
It's going to have a register
called the value, where the

627
00:33:52,660 --> 00:33:59,890
answer is going to be stored,
and a registered called N,

628
00:33:59,890 --> 00:34:02,330
which is where the number I'm
taking factorial will be

629
00:34:02,329 --> 00:34:04,164
stored, factorial of.

630
00:34:04,164 --> 00:34:09,779
And it will be necessary in some
instances to connect VAL

631
00:34:09,780 --> 00:34:11,760
to N.

632
00:34:11,760 --> 00:34:16,389
In fact, one nice case of this
is if I just said over here,

633
00:34:16,389 --> 00:34:19,139
N, because that would be
right for N equal 1N.

634
00:34:19,139 --> 00:34:21,389
And I could just move
the answer over

635
00:34:21,389 --> 00:34:23,909
there if that's important.

636
00:34:23,909 --> 00:34:26,980
I'm not worried about
that right now.

637
00:34:26,980 --> 00:34:29,059
And there are things I have
to be able to do.

638
00:34:29,059 --> 00:34:32,650
Like I have to be able to, as
we see here, multiply N by

639
00:34:32,650 --> 00:34:36,349
something in VAL, because
VAL is the result

640
00:34:36,349 --> 00:34:38,289
of computing factorial.

641
00:34:38,289 --> 00:34:41,429
And I have to put the result
back into VAL.

642
00:34:41,429 --> 00:34:45,639
So here we can see that the
result of computing a

643
00:34:45,639 --> 00:34:48,070
factorial is N times the result

644
00:34:48,070 --> 00:34:50,690
of computing a factorial.

645
00:34:50,690 --> 00:34:52,769
VAL will be the representation
of the answer

646
00:34:52,769 --> 00:34:55,199
of the inner factorial.

647
00:34:55,199 --> 00:35:02,525
And so I'm going to have to have
a multiplier here, which

648
00:35:02,525 --> 00:35:09,349
is going to sample the value of
N and the value of VAL and

649
00:35:09,349 --> 00:35:17,170
put the result back into
VAL like that.

650
00:35:17,170 --> 00:35:20,617
I'm also going to have to be
able to see if N is 1.

651
00:35:20,617 --> 00:35:22,230
So I need a light bulb.

652
00:35:22,230 --> 00:35:28,199


653
00:35:28,199 --> 00:35:31,269
And I suppose the other thing
I'm going to need to have is a

654
00:35:31,269 --> 00:35:38,259
way of decrementing N. So I'm
going to have a decrementer,

655
00:35:38,260 --> 00:35:46,620
which takes N and is going to
put back the result into N.

656
00:35:46,619 --> 00:35:49,549
That's pretty much what
I need in my machine.

657
00:35:49,550 --> 00:35:51,985
Now, there's a little
bit else I need.

658
00:35:51,985 --> 00:35:55,620
It's a little bit more
complicated, because I'm also

659
00:35:55,619 --> 00:35:58,924
going to need a way to store, to
save away, the things that

660
00:35:58,925 --> 00:36:02,600
are going to be needed for
resuming the computation of a

661
00:36:02,599 --> 00:36:06,250
factorial after I've done
a sub-factorial.

662
00:36:06,250 --> 00:36:07,230
What's that?

663
00:36:07,230 --> 00:36:09,849
One thing I need is N.

664
00:36:09,849 --> 00:36:11,869
So I'm going to build here
a thing called a stack.

665
00:36:11,869 --> 00:36:14,699


666
00:36:14,699 --> 00:36:24,129
The stack is a bunch of stuff
that I'm going to write in

667
00:36:24,130 --> 00:36:25,380
sequentially.

668
00:36:25,380 --> 00:36:27,410


669
00:36:27,409 --> 00:36:28,915
I don't how long it is.

670
00:36:28,916 --> 00:36:32,890
The longer it is, the better
my illusion of infinity.

671
00:36:32,889 --> 00:36:36,036
And I'm going to have to have a
way of getting stuff out of

672
00:36:36,036 --> 00:36:39,514
N and into the stack
and vice versa.

673
00:36:39,514 --> 00:36:44,739
So I'm going to need a
connection like this, which is

674
00:36:44,739 --> 00:36:52,500
two-way, whereby I can save
the value of N and then

675
00:36:52,500 --> 00:36:55,820
restore it some other time
through that connection.

676
00:36:55,820 --> 00:36:58,100
This is the stack.

677
00:36:58,099 --> 00:37:02,789
I also need a way of remembering
where I was in the

678
00:37:02,789 --> 00:37:08,529
computation of factorial
in the outer program.

679
00:37:08,530 --> 00:37:11,090
Now in the case of
this machine, it

680
00:37:11,090 --> 00:37:14,090
isn't very much a problem.

681
00:37:14,090 --> 00:37:18,019
Factorial always returns, has to
go back to the place where

682
00:37:18,019 --> 00:37:21,650
we multiply by N, except for the
last time, when it has to

683
00:37:21,650 --> 00:37:23,110
return to whatever needs
the factorial or

684
00:37:23,110 --> 00:37:25,660
go to done or stop.

685
00:37:25,659 --> 00:37:28,244
However, in general, I'm going
to have to remember where I

686
00:37:28,244 --> 00:37:30,569
have been, because I might have
computed factorial from

687
00:37:30,570 --> 00:37:31,769
somewhere else.

688
00:37:31,769 --> 00:37:36,070
I have to go back to that place
and continue there.

689
00:37:36,070 --> 00:37:37,990
So I'm going to have to have
some way of taking the place

690
00:37:37,989 --> 00:37:41,500
where the marble is in the
finite state controller, the

691
00:37:41,500 --> 00:37:45,389
state of the controller,
and storing that in

692
00:37:45,389 --> 00:37:47,400
the stack as well.

693
00:37:47,400 --> 00:37:49,840
And I'm going to have to have
ways of restoring that back to

694
00:37:49,840 --> 00:37:51,870
the state of the-- the marble.

695
00:37:51,869 --> 00:37:53,569
So I have to have something that
moves the marble to the

696
00:37:53,570 --> 00:37:54,309
right place.

697
00:37:54,309 --> 00:37:57,461
Well, we're going to have a
place which is the marble now.

698
00:37:57,461 --> 00:38:09,219
And it's called the continue
register, called continue,

699
00:38:09,219 --> 00:38:11,480
which is the place to
put the marble next

700
00:38:11,480 --> 00:38:14,260
time I go to continue.

701
00:38:14,260 --> 00:38:16,140
That's what that's for.

702
00:38:16,139 --> 00:38:17,989
And so there's got to be some
path from that into the

703
00:38:17,989 --> 00:38:19,239
controller.

704
00:38:19,239 --> 00:38:22,909


705
00:38:22,909 --> 00:38:29,074
I also have to have some way of
saving that on the stack.

706
00:38:29,074 --> 00:38:32,119
And I have to have some way
of setting that up to have

707
00:38:32,119 --> 00:38:36,859
various constants, a certain
fixed number of constants.

708
00:38:36,860 --> 00:38:38,840
And that's very easy
to arrange.

709
00:38:38,840 --> 00:38:40,180
So let's have some
constants here.

710
00:38:40,179 --> 00:38:41,429
We'll call this one
after-fact.

711
00:38:41,429 --> 00:38:47,429


712
00:38:47,429 --> 00:38:50,889
And that's a constant which
we'll get into the continue

713
00:38:50,889 --> 00:38:54,009
register, and also another
one called fact-done.

714
00:38:54,010 --> 00:39:05,210


715
00:39:05,210 --> 00:39:08,130
So this is the machine
I want to build.

716
00:39:08,130 --> 00:39:10,809
That's its datapaths, at least.
And it mixes a little

717
00:39:10,809 --> 00:39:12,789
with the controller here,
because of the fact that I

718
00:39:12,789 --> 00:39:15,219
have to remember where
I was and restore

719
00:39:15,219 --> 00:39:17,299
myself to that place.

720
00:39:17,300 --> 00:39:19,310
But let's write the program
now which represents the

721
00:39:19,309 --> 00:39:20,389
controller.

722
00:39:20,389 --> 00:39:22,759
I'm not going to write the
define machine thing and the

723
00:39:22,760 --> 00:39:24,890
register list, because that's
not very interesting.

724
00:39:24,889 --> 00:39:28,019
I'm just going to write down the
sequence of instructions

725
00:39:28,019 --> 00:39:30,920
that constitute the
controller.

726
00:39:30,920 --> 00:39:41,510
So we have assign, to set
up, continue to done.

727
00:39:41,510 --> 00:39:44,476


728
00:39:44,476 --> 00:40:01,150
We have a loop which says branch
if equal 1 fetch N, if

729
00:40:01,150 --> 00:40:06,300
N is 1, then go to the base
step of the induction, the

730
00:40:06,300 --> 00:40:08,050
simple case.

731
00:40:08,050 --> 00:40:10,740
Otherwise, I have to remember
the things that are necessary

732
00:40:10,739 --> 00:40:14,264
to perform a sub-factorial.

733
00:40:14,264 --> 00:40:16,279
I'm going to go over here,
and I have to perform a

734
00:40:16,280 --> 00:40:17,570
sub-factorial.

735
00:40:17,570 --> 00:40:21,750
So I have to remember what's
needed after I will

736
00:40:21,750 --> 00:40:24,000
be done with that.

737
00:40:24,000 --> 00:40:25,510
See, I'm about to do
something terrible.

738
00:40:25,510 --> 00:40:29,430
I'm about to change the value of
N. But this guy has to know

739
00:40:29,429 --> 00:40:32,779
the old value of N. But
in order to make the

740
00:40:32,780 --> 00:40:35,790
sub-factorial work, I have to
change the value of N. So I

741
00:40:35,789 --> 00:40:38,000
have to remember
the old value.

742
00:40:38,000 --> 00:40:40,849
And I also have to remember
where I've been.

743
00:40:40,849 --> 00:40:42,099
So I save up continue.

744
00:40:42,099 --> 00:40:47,704


745
00:40:47,704 --> 00:40:50,259
And this is an instruction
that says, put

746
00:40:50,260 --> 00:40:53,580
something in the stack.

747
00:40:53,579 --> 00:40:56,759
Save the contents of the
continuation register, which

748
00:40:56,760 --> 00:40:59,830
in this case is done, because
later I'm going to change

749
00:40:59,829 --> 00:41:00,969
that, too, because I
need to go back to

750
00:41:00,969 --> 00:41:03,549
after-fact, as well.

751
00:41:03,550 --> 00:41:05,039
We'll see that.

752
00:41:05,039 --> 00:41:10,380
We save N, because I'm going
to need that for later.

753
00:41:10,380 --> 00:41:31,422
Assign to N the decrement of
fetch N. Assign continue,

754
00:41:31,422 --> 00:41:37,690
we're going to look at this now,
to after, we'll call it.

755
00:41:37,690 --> 00:41:39,889
That's a good name for this, a
little bit easier and shorter,

756
00:41:39,889 --> 00:41:41,139
and fits in here.

757
00:41:41,139 --> 00:41:52,771


758
00:41:52,771 --> 00:41:55,329
Now look what I'm doing here.

759
00:41:55,329 --> 00:42:00,065
I'm saying, if the answer
is 1, I'm done.

760
00:42:00,065 --> 00:42:02,150
I'm going to have to just
get the answer.

761
00:42:02,150 --> 00:42:06,160
Otherwise, I'm going to save the
continuation, save N, make

762
00:42:06,159 --> 00:42:08,940
N one less than N, remember
I'm going to come back to

763
00:42:08,940 --> 00:42:10,530
someplace else, and
go back and start

764
00:42:10,530 --> 00:42:11,780
doing another factorial.

765
00:42:11,780 --> 00:42:13,980


766
00:42:13,980 --> 00:42:16,050
However, I've got a different
machine [? in me ?] now.

767
00:42:16,050 --> 00:42:18,380
N is 1, and continue
is something else.

768
00:42:18,380 --> 00:42:22,160


769
00:42:22,159 --> 00:42:23,589
N is N minus 1.

770
00:42:23,590 --> 00:42:28,660
Now after I'm done with
that, I can go there.

771
00:42:28,659 --> 00:42:34,129
I will restore the old value of
N, which is the opposite of

772
00:42:34,130 --> 00:42:38,360
this save over here.

773
00:42:38,360 --> 00:42:39,610
I will restore the
continuation.

774
00:42:39,610 --> 00:42:49,660


775
00:42:49,659 --> 00:42:54,319
I will then go to here.

776
00:42:54,320 --> 00:43:03,309
I will assign to the VAL
register the product

777
00:43:03,309 --> 00:43:08,130
of N and fetch VAL.

778
00:43:08,130 --> 00:43:13,519


779
00:43:13,519 --> 00:43:19,789
VAL fetch product assign.

780
00:43:19,789 --> 00:43:21,440
And then I will be done.

781
00:43:21,440 --> 00:43:26,570
I will have my answer to the
sub-factorial in VAL.

782
00:43:26,570 --> 00:43:30,140
At that point, I'm going to
return by going to the place

783
00:43:30,139 --> 00:43:33,639
where the continuation
is pointing.

784
00:43:33,639 --> 00:43:35,299
That says, go to
fetch continue.

785
00:43:35,300 --> 00:43:45,870


786
00:43:45,869 --> 00:43:49,469
And then I have finally
a base step, which is

787
00:43:49,469 --> 00:43:50,730
the immediate answer.

788
00:43:50,730 --> 00:44:02,570
Assign to VAL fetch N, and
go to fetch continue.

789
00:44:02,570 --> 00:44:12,670


790
00:44:12,670 --> 00:44:13,920
And then I'm done.

791
00:44:13,920 --> 00:44:18,639


792
00:44:18,639 --> 00:44:20,819
Now let's see how this executes
on a very simple

793
00:44:20,820 --> 00:44:25,570
case, because then we'll see
the use of this stack to do

794
00:44:25,570 --> 00:44:26,890
the job we need.

795
00:44:26,889 --> 00:44:28,819
This is statically what it's
doing, but we have look

796
00:44:28,820 --> 00:44:31,340
dynamically at this.

797
00:44:31,340 --> 00:44:32,300
So let's see.

798
00:44:32,300 --> 00:44:36,730
First thing we do is
continue gets done.

799
00:44:36,730 --> 00:44:38,300
The way that happened
is I pushed this.

800
00:44:38,300 --> 00:44:40,122
Let's call that done
the way I have it.

801
00:44:40,121 --> 00:44:46,389


802
00:44:46,389 --> 00:44:47,029
I push that button.

803
00:44:47,030 --> 00:44:48,950
Done goes into there.

804
00:44:48,949 --> 00:44:52,549
Now I also have to set
this thing up to

805
00:44:52,550 --> 00:44:53,850
have an initial value.

806
00:44:53,849 --> 00:45:00,192
Let's consider a factorial
of three, a simple case.

807
00:45:00,192 --> 00:45:03,010
And we're going to start
out with our stack

808
00:45:03,010 --> 00:45:05,900
growing over here.

809
00:45:05,900 --> 00:45:08,519
Stacks have their own little
internal state saying where

810
00:45:08,519 --> 00:45:12,769
they are, where the next place
I'm going to write is.

811
00:45:12,769 --> 00:45:14,590
So now we say, is N 1?

812
00:45:14,590 --> 00:45:16,110
The answer is no.

813
00:45:16,110 --> 00:45:19,066
So now I'm going to save
continue, bang.

814
00:45:19,065 --> 00:45:22,079
Now that done goes in here.

815
00:45:22,079 --> 00:45:26,659
And this moves to here, the next
place I'm going to write.

816
00:45:26,659 --> 00:45:29,949
Save N 3.

817
00:45:29,949 --> 00:45:30,750
OK?

818
00:45:30,750 --> 00:45:34,239
Assign to N the decrement
of N. That means

819
00:45:34,239 --> 00:45:35,939
I've pushed this button.

820
00:45:35,940 --> 00:45:37,320
This becomes 2.

821
00:45:37,320 --> 00:45:40,400


822
00:45:40,400 --> 00:45:42,579
Assign to continue aft.

823
00:45:42,579 --> 00:45:43,610
So I've pushed that button.

824
00:45:43,610 --> 00:45:44,860
Aft goes in here.

825
00:45:44,860 --> 00:45:49,140


826
00:45:49,139 --> 00:45:54,829
OK, now go to loop, bang,
so up to here.

827
00:45:54,829 --> 00:45:56,569
Is N 1?

828
00:45:56,570 --> 00:45:57,780
No.

829
00:45:57,780 --> 00:45:59,490
So I have to save continue.

830
00:45:59,489 --> 00:46:00,599
What's continue?

831
00:46:00,599 --> 00:46:01,529
Continue is aft.

832
00:46:01,530 --> 00:46:02,780
Push this button.

833
00:46:02,780 --> 00:46:04,030
So this moves to here.

834
00:46:04,030 --> 00:46:08,490


835
00:46:08,489 --> 00:46:11,459
I have to save N.
N is over here.

836
00:46:11,460 --> 00:46:12,280
I got to 2.

837
00:46:12,280 --> 00:46:13,655
Push that button.

838
00:46:13,655 --> 00:46:16,050
So a 2 gets written there.

839
00:46:16,050 --> 00:46:20,060
And then this thing
moves down here.

840
00:46:20,059 --> 00:46:24,213
OK, save N. Assign N to
the decrement of N.

841
00:46:24,213 --> 00:46:25,463
This becomes a 1.

842
00:46:25,463 --> 00:46:29,239


843
00:46:29,239 --> 00:46:31,369
Assign continue to aft.

844
00:46:31,369 --> 00:46:34,960
A-F-T gets written
there again.

845
00:46:34,960 --> 00:46:36,519
Go to loop.

846
00:46:36,519 --> 00:46:37,929
Is N equal to 1?

847
00:46:37,929 --> 00:46:41,159
Oh, yes, the answer is 1.

848
00:46:41,159 --> 00:46:44,159
OK, go to base step.

849
00:46:44,159 --> 00:46:51,099
Assign to VAL fetch of N. Bang,
1 gets put in there.

850
00:46:51,099 --> 00:46:52,199
Go to fetch continue.

851
00:46:52,199 --> 00:46:53,679
So we look in continue.

852
00:46:53,679 --> 00:46:55,349
Basically, I'm pushing a button
over here that goes to

853
00:46:55,349 --> 00:46:57,130
the controller.

854
00:46:57,130 --> 00:46:59,579
The continue becomes aft, and
all of a sudden, the program's

855
00:46:59,579 --> 00:47:02,639
running here.

856
00:47:02,639 --> 00:47:06,650
I now have to restore the outer
version of factorial.

857
00:47:06,650 --> 00:47:07,550
So we go here.

858
00:47:07,550 --> 00:47:12,410
We say, restore N. So restore
N means take the contents

859
00:47:12,409 --> 00:47:13,940
that's here.

860
00:47:13,940 --> 00:47:19,190
Push this button, and it goes
into here, 2, and the

861
00:47:19,190 --> 00:47:22,230
pointer moves up.

862
00:47:22,230 --> 00:47:24,809
Restore continue, pretty easy.

863
00:47:24,809 --> 00:47:27,019
Go push this button.

864
00:47:27,019 --> 00:47:31,280
And then aft gets written
in here again.

865
00:47:31,280 --> 00:47:32,640
That means this thing
moves up.

866
00:47:32,639 --> 00:47:35,190
I've gotten rid of something
else on my stack.

867
00:47:35,190 --> 00:47:42,240


868
00:47:42,239 --> 00:47:45,929
Right, then I go to here, which
says, assign to VAL the

869
00:47:45,929 --> 00:47:47,849
product of N an VAL.

870
00:47:47,849 --> 00:47:50,969
So I push this button
over here, bang.

871
00:47:50,969 --> 00:47:55,919
2 times 1 gives me a 2,
get written there.

872
00:47:55,920 --> 00:47:57,539
Go to fetch continue.

873
00:47:57,539 --> 00:47:59,190
Continue is aft.

874
00:47:59,190 --> 00:48:01,289
I go to aft.

875
00:48:01,289 --> 00:48:06,639
Aft says restore N. Do your
restore N, means I take the

876
00:48:06,639 --> 00:48:11,029
value over here, which is 3,
push this up to here, and move

877
00:48:11,030 --> 00:48:17,715
it into here, N. Now it's
pushing that button.

878
00:48:17,715 --> 00:48:20,200
The next thing I do is
restore continue.

879
00:48:20,199 --> 00:48:22,829
Continue is now going
to become done.

880
00:48:22,829 --> 00:48:27,259
So this moves up here when
I push this button.

881
00:48:27,260 --> 00:48:30,470
Done may or may be there
anymore, I'm not interested,

882
00:48:30,469 --> 00:48:31,719
but it certainly is here.

883
00:48:31,719 --> 00:48:35,799


884
00:48:35,800 --> 00:48:39,590
Next thing I do is assign to VAL
the product of the fetch

885
00:48:39,590 --> 00:48:41,440
of N and the fetch of VAL.

886
00:48:41,440 --> 00:48:44,300
That's pushing this button
over here, bang.

887
00:48:44,300 --> 00:48:46,519
2 times 3 is 6.

888
00:48:46,519 --> 00:48:47,869
So I get a 6 over here.

889
00:48:47,869 --> 00:48:52,019


890
00:48:52,019 --> 00:48:54,139
And go to fetch continue,
whoops, I go to

891
00:48:54,139 --> 00:48:55,019
done, and I'm done.

892
00:48:55,019 --> 00:48:58,949
And my answer is 6, as you can
see in the VAL register.

893
00:48:58,949 --> 00:49:02,379
And in fact, the stack
is in the state it

894
00:49:02,380 --> 00:49:03,630
originally was in.

895
00:49:03,630 --> 00:49:07,735


896
00:49:07,735 --> 00:49:09,849
Now there's a bit of discipline
in using these

897
00:49:09,849 --> 00:49:13,619
things like stacks that we
have to be careful of.

898
00:49:13,619 --> 00:49:16,259
And we'll see that in
the next segment.

899
00:49:16,260 --> 00:49:17,340
But first I want to ask
if there are any

900
00:49:17,340 --> 00:49:18,590
questions for this.

901
00:49:18,590 --> 00:49:28,559


902
00:49:28,559 --> 00:49:30,170
Are there any questions?

903
00:49:30,170 --> 00:49:30,630
Yes, Ron.

904
00:49:30,630 --> 00:49:32,780
AUDIENCE: What happens when you
roll off the end of the

905
00:49:32,780 --> 00:49:33,640
stack with--

906
00:49:33,639 --> 00:49:35,029
PROFESSOR: What do you
mean, roll off of?

907
00:49:35,030 --> 00:49:36,090
AUDIENCE: Well, the
largest number--

908
00:49:36,090 --> 00:49:38,860
a larger starting point of N
requires more memory, correct?

909
00:49:38,860 --> 00:49:39,440
PROFESSOR: Oh, yes.

910
00:49:39,440 --> 00:49:41,530
Well, I need to have a
long enough stack.

911
00:49:41,530 --> 00:49:43,843
You say, what if I violate
my illusion?

912
00:49:43,842 --> 00:49:44,549
AUDIENCE: Yes.

913
00:49:44,550 --> 00:49:48,210
PROFESSOR: Well, then the
magic doesn't work.

914
00:49:48,210 --> 00:49:51,639
The truth of the matter is that
every machine is finite.

915
00:49:51,639 --> 00:49:56,480
And for a procedure like this,
there's a limit to the number

916
00:49:56,480 --> 00:49:59,949
of sub-factorials
I could have.

917
00:49:59,949 --> 00:50:02,969
Remember when we were doing the
y-operator a while ago, we

918
00:50:02,969 --> 00:50:05,750
pointed out that there was a
sequence of exponentiation

919
00:50:05,750 --> 00:50:07,389
procedures, each of which was
a little better than the

920
00:50:07,389 --> 00:50:08,349
previous one.

921
00:50:08,349 --> 00:50:10,529
Well, we're now seeing
how we implement that

922
00:50:10,530 --> 00:50:13,090
mathematical idea.

923
00:50:13,090 --> 00:50:15,620
The limiting process is only
so good as as far as

924
00:50:15,619 --> 00:50:17,989
you take the limit.

925
00:50:17,989 --> 00:50:19,419
If you think about it,
what am I using here?

926
00:50:19,420 --> 00:50:26,340
I'm using about two pieces of
memory for every recursion of

927
00:50:26,340 --> 00:50:29,100
this process.

928
00:50:29,099 --> 00:50:31,920
If we try to compute factorial
of 10,000, that's

929
00:50:31,920 --> 00:50:33,180
not a lot of memory.

930
00:50:33,179 --> 00:50:36,079
On the other hand, it's
an awful big number.

931
00:50:36,079 --> 00:50:39,179
So the question is, is that a
valuable thing in this case.

932
00:50:39,179 --> 00:50:42,480
But it really turns out not to
be a terrible limit, because

933
00:50:42,480 --> 00:50:45,085
memory is el cheapo, and people
are pretty expensive.

934
00:50:45,085 --> 00:50:48,130


935
00:50:48,130 --> 00:50:51,050
OK, thank you, let's
take a break.

936
00:50:51,050 --> 00:50:51,410
[MUSIC PLAYING - "JESU, JOY OF
MAN'S DESIRING" BY JOHANN

937
00:50:51,409 --> 00:50:52,659
SEBASTIAN BACH]

938
00:50:52,659 --> 00:51:55,175


939
00:51:55,175 --> 00:51:58,351
PROFESSOR: Well, let's see.

940
00:51:58,351 --> 00:52:02,769
What I've shown you now is how
to do a simple iterative

941
00:52:02,769 --> 00:52:05,639
process and a simple
recursive process.

942
00:52:05,639 --> 00:52:09,759
I just want to summarize the
design of simple machines for

943
00:52:09,760 --> 00:52:12,470
specific applications by showing
you a little bit more

944
00:52:12,469 --> 00:52:15,869
complicated design, that of
a thing that does doubly

945
00:52:15,869 --> 00:52:19,014
recursive Fibonacci, because
it will indicate to us, and

946
00:52:19,014 --> 00:52:22,869
we'll understand, a bit about
the conventions required for

947
00:52:22,869 --> 00:52:26,400
making stacks operate
correctly.

948
00:52:26,400 --> 00:52:27,110
So let's see.

949
00:52:27,110 --> 00:52:28,829
I'm just going to write down,
first of all, the program I'm

950
00:52:28,829 --> 00:52:30,079
going to translate.

951
00:52:30,079 --> 00:52:34,150


952
00:52:34,150 --> 00:52:41,190
I need a Fibonacci procedure,
it's very simple, which says,

953
00:52:41,190 --> 00:52:50,389
if N is less than 2, the result
is N, otherwise it's

954
00:52:50,389 --> 00:52:59,964
the sum of Fib of N minus
1 and Fib of N minus 2.

955
00:52:59,965 --> 00:53:07,240


956
00:53:07,239 --> 00:53:09,289
That's the plan I have here.

957
00:53:09,289 --> 00:53:11,179
And we're just going
to write down the

958
00:53:11,179 --> 00:53:13,069
controller for such a machine.

959
00:53:13,070 --> 00:53:16,240
We're going to assume that there
are registers, N, which

960
00:53:16,239 --> 00:53:20,509
holds the number we're taking
Fibonacci of, VAL, which is

961
00:53:20,510 --> 00:53:23,630
where the answer is going to get
put, and continue, which

962
00:53:23,630 --> 00:53:26,809
is the thing that's linked to
the controller, like before.

963
00:53:26,809 --> 00:53:31,739
But I'm not going to draw
another physical datapath,

964
00:53:31,739 --> 00:53:32,994
because it's pretty much
the same as the

965
00:53:32,994 --> 00:53:34,359
last one you've seen.

966
00:53:34,360 --> 00:53:37,070
And of course, one of the most
amazing things about

967
00:53:37,070 --> 00:53:40,700
computation is that after a
while, you build up a little

968
00:53:40,699 --> 00:53:42,125
more features and a few more
features, and all of the

969
00:53:42,126 --> 00:53:44,860
sudden, you've got everything
you need.

970
00:53:44,860 --> 00:53:48,289
So it's remarkable that it just
gets there so fast. I

971
00:53:48,289 --> 00:53:51,809
don't need much more to make
a universal computer.

972
00:53:51,809 --> 00:53:53,630
But in any case, let's look
at the controller for the

973
00:53:53,630 --> 00:53:55,059
Fibonacci thing.

974
00:53:55,059 --> 00:54:01,679
First thing I want to do is
start the thing up by assign

975
00:54:01,679 --> 00:54:10,230
to continue a place called done,
called Fib-done here.

976
00:54:10,230 --> 00:54:13,708


977
00:54:13,708 --> 00:54:16,629
So that means that somewhere
over here, I'm going to have a

978
00:54:16,630 --> 00:54:21,610
label, Fib-done, which is the
place where I go when I want

979
00:54:21,610 --> 00:54:24,120
the machine to stop.

980
00:54:24,119 --> 00:54:25,394
That's what that is.

981
00:54:25,394 --> 00:54:26,795
And I'm going to
make up a loop.

982
00:54:26,795 --> 00:54:31,110


983
00:54:31,110 --> 00:54:33,490
It's a place I'm going to go
to in order to start up

984
00:54:33,489 --> 00:54:35,469
computing a Fib.

985
00:54:35,469 --> 00:54:38,209
Whatever is in N at this point,
Fibonacci will be

986
00:54:38,210 --> 00:54:41,320
computed of, and we will return
to the place specified

987
00:54:41,320 --> 00:54:42,570
by continue.

988
00:54:42,570 --> 00:54:46,070


989
00:54:46,070 --> 00:54:48,640
So what you're going to see
here at this place, what I

990
00:54:48,639 --> 00:54:52,650
want here is the contract that
says, I'm going to write this

991
00:54:52,650 --> 00:55:00,230
with a comment syntax, the
contract is N contains arg,

992
00:55:00,230 --> 00:55:02,099
the argument.

993
00:55:02,099 --> 00:55:09,324
Continue is the recipient.

994
00:55:09,324 --> 00:55:12,811


995
00:55:12,811 --> 00:55:14,289
And that's where it is.

996
00:55:14,289 --> 00:55:17,369


997
00:55:17,369 --> 00:55:20,429
At this point, if I ever go to
this place, I'm expecting this

998
00:55:20,429 --> 00:55:24,819
to be true, the argument for
computing the Fibonacci.

999
00:55:24,820 --> 00:55:26,450
Now the next thing I want
to do is to branch.

1000
00:55:26,449 --> 00:55:30,219


1001
00:55:30,219 --> 00:55:32,069
And if N is less than 2--

1002
00:55:32,070 --> 00:55:34,930


1003
00:55:34,929 --> 00:55:38,730
by the way, I'm using what
looks like Lisp syntax.

1004
00:55:38,730 --> 00:55:41,309
This is not Lisp.

1005
00:55:41,309 --> 00:55:42,750
This does not run.

1006
00:55:42,750 --> 00:55:46,119
What I'm writing here does not
run as a simple Lisp program.

1007
00:55:46,119 --> 00:55:49,710
This is a representation
of another language.

1008
00:55:49,710 --> 00:55:52,030
The reason I'm using the syntax
of parentheses and so

1009
00:55:52,030 --> 00:55:56,100
on is because I tend to use
a Lisp system to write an

1010
00:55:56,099 --> 00:55:59,380
interpreter for this which
allows me to simulate the

1011
00:55:59,380 --> 00:56:03,380
machine I'm trying to build.

1012
00:56:03,380 --> 00:56:05,170
I don't want to confuse
this to think that

1013
00:56:05,170 --> 00:56:06,940
this is Lisp code.

1014
00:56:06,940 --> 00:56:09,510
It's just I'm using a lot
of the pieces of Lisp.

1015
00:56:09,510 --> 00:56:12,880
I'm embedding a language in
Lisp, using Lisp as pieces to

1016
00:56:12,880 --> 00:56:16,619
make my process of making
my simulator easy.

1017
00:56:16,619 --> 00:56:18,900
So I'm inheriting from Lisp
all of its properties.

1018
00:56:18,900 --> 00:56:22,700
Fetch of N 2, I want
to go to a place

1019
00:56:22,699 --> 00:56:25,984
called immediate answer.

1020
00:56:25,985 --> 00:56:27,235
It's the base step.

1021
00:56:27,235 --> 00:56:33,150


1022
00:56:33,150 --> 00:56:37,750
Now, that's somewhere over
here, just above done.

1023
00:56:37,750 --> 00:56:39,329
And we'll see it later.

1024
00:56:39,329 --> 00:56:41,480
Now, in the general case, which
is the part I'm going to

1025
00:56:41,480 --> 00:56:44,860
write down now, let's
just do it.

1026
00:56:44,860 --> 00:56:46,370
Well, first of all, I'm
going to have to

1027
00:56:46,369 --> 00:56:49,420
call Fibonacci twice.

1028
00:56:49,420 --> 00:56:51,300
In each case--

1029
00:56:51,300 --> 00:56:53,640
well, in one case at least, I'm
going to have to know what

1030
00:56:53,639 --> 00:56:56,309
to do to come back and
do the next one.

1031
00:56:56,309 --> 00:57:01,599
I have to remember, have I done
the first Fib, or have I

1032
00:57:01,599 --> 00:57:04,500
done the second one?

1033
00:57:04,500 --> 00:57:06,630
Do I have to come back to the
place where I do the second

1034
00:57:06,630 --> 00:57:08,240
Fib, or do I have to come
back to the place

1035
00:57:08,239 --> 00:57:09,489
where I do the add?

1036
00:57:09,489 --> 00:57:12,139


1037
00:57:12,139 --> 00:57:14,809
In the first case, over the
first Fibonacci, I'm going to

1038
00:57:14,809 --> 00:57:16,980
need the value of N for
computing for the second one.

1039
00:57:16,980 --> 00:57:20,010


1040
00:57:20,010 --> 00:57:22,996
So I have to store some
of these things up.

1041
00:57:22,996 --> 00:57:25,820
So first I'm going
to save continue.

1042
00:57:25,820 --> 00:57:27,265
That's who needs the answer.

1043
00:57:27,264 --> 00:57:31,319


1044
00:57:31,320 --> 00:57:33,559
And the reason I'm doing that is
because I'm about to assign

1045
00:57:33,559 --> 00:57:42,869
continue to the place
which is the place I

1046
00:57:42,869 --> 00:57:44,130
want to go to after.

1047
00:57:44,130 --> 00:57:46,869


1048
00:57:46,869 --> 00:57:52,509
Let's call it Fib-N-minus-1,
big long name,

1049
00:57:52,510 --> 00:57:53,760
classic Lisp name.

1050
00:57:53,760 --> 00:57:57,700


1051
00:57:57,699 --> 00:58:00,899
Because I'm going to compute
the first Fib of N minus 1,

1052
00:58:00,900 --> 00:58:02,440
and then after that, I
want to come back and

1053
00:58:02,440 --> 00:58:03,960
do something else.

1054
00:58:03,960 --> 00:58:08,050
That's the place I want to go
to after I've done the first

1055
00:58:08,050 --> 00:58:11,106
Fibonacci calculation.

1056
00:58:11,106 --> 00:58:15,030
And I want to do a save of N,
because I'm going to need it

1057
00:58:15,030 --> 00:58:19,130
later, after that.

1058
00:58:19,130 --> 00:58:21,480
Now I'm going to, at this point,
get ready to do the

1059
00:58:21,480 --> 00:58:23,230
Fibonacci of N minus 1.

1060
00:58:23,230 --> 00:58:33,949
So assign to N the difference
of the fetch of N and 1.

1061
00:58:33,949 --> 00:58:38,109


1062
00:58:38,110 --> 00:58:40,269
Now I'm ready to go back
to doing the Fib loop.

1063
00:58:40,269 --> 00:58:47,630


1064
00:58:47,630 --> 00:58:50,195
Have I satisfied my contract?

1065
00:58:50,195 --> 00:58:51,769
And the answer is yes.

1066
00:58:51,769 --> 00:58:57,210
N contains N minus 1, which
is what I need.

1067
00:58:57,210 --> 00:59:01,369
Continue contains a place I want
to go to when I'm done

1068
00:59:01,369 --> 00:59:04,099
with calculating N minus 1.

1069
00:59:04,099 --> 00:59:05,440
So I've satisfied
the contract.

1070
00:59:05,440 --> 00:59:11,579
And therefore, I can write
down here a label,

1071
00:59:11,579 --> 00:59:12,829
after-Fib-N-minus-1.

1072
00:59:12,829 --> 00:59:20,489


1073
00:59:20,489 --> 00:59:22,689
Now what am I going
to do here?

1074
00:59:22,690 --> 00:59:25,659
Here's a place where I now
have to get ready to do

1075
00:59:25,659 --> 00:59:26,909
Fib of N minus 2.

1076
00:59:26,909 --> 00:59:29,269


1077
00:59:29,269 --> 00:59:31,780
But in order to do a Fib of N
minus 2, look, I don't know.

1078
00:59:31,780 --> 00:59:33,810
I've clobbered my N over here.

1079
00:59:33,809 --> 00:59:36,610
And presumably my N is counted
down all the way to 1 or 0 or

1080
00:59:36,610 --> 00:59:39,780
something at this point.

1081
00:59:39,780 --> 00:59:43,030
So I don't know what the value
of N in the N register is.

1082
00:59:43,030 --> 00:59:45,640
I want the value of N that was
on the stack that I saved over

1083
00:59:45,639 --> 00:59:49,519
here so that could restore
it over here.

1084
00:59:49,519 --> 00:59:53,880
I saved up the value of N, which
is this value of N at

1085
00:59:53,880 --> 00:59:56,340
this point, so that I could
restore it after computing Fib

1086
00:59:56,340 --> 00:59:59,360
of N minus 1, so that I could
count that down to N minus 2

1087
00:59:59,360 --> 01:00:01,809
and then compute Fib
of N minus 2.

1088
01:00:01,809 --> 01:00:03,059
So let's restore that.

1089
01:00:03,059 --> 01:00:08,829


1090
01:00:08,829 --> 01:00:11,130
Restore of N.

1091
01:00:11,130 --> 01:00:16,200
Now I'm about to do something
which is superstitious, and we

1092
01:00:16,199 --> 01:00:18,519
will remove it shortly.

1093
01:00:18,519 --> 01:00:22,389
I am about to finish the
sequence of doing the

1094
01:00:22,389 --> 01:00:24,799
subroutine call, if you will.

1095
01:00:24,800 --> 01:00:28,510
I'm going to say, well, I also
saved up the continuation,

1096
01:00:28,510 --> 01:00:31,600
since I'm going to
restore it now.

1097
01:00:31,599 --> 01:00:32,969
But actually, I don't have
to, because I'm not

1098
01:00:32,969 --> 01:00:34,609
going to need it.

1099
01:00:34,610 --> 01:00:36,260
We'll fix that in a second.

1100
01:00:36,260 --> 01:00:46,590
So we'll do a restore of
continue, which is what I

1101
01:00:46,590 --> 01:00:48,019
would in general need to do.

1102
01:00:48,019 --> 01:00:50,239
And we're just going to see
what you would call in the

1103
01:00:50,239 --> 01:00:52,539
compiler world a peephole
optimization, which says,

1104
01:00:52,539 --> 01:00:55,420
whoops, you didn't
have to do that.

1105
01:00:55,420 --> 01:00:59,720
OK, so the next thing I see
here is that I have to get

1106
01:00:59,719 --> 01:01:02,769
ready now to do Fibonacci
of N minus 2.

1107
01:01:02,769 --> 01:01:05,050
But I don't have to
save N anymore.

1108
01:01:05,050 --> 01:01:07,140
The reason why I don't have to
save N anymore is because I

1109
01:01:07,139 --> 01:01:09,690
don't need N after I've done Fib
of N minus 2, because the

1110
01:01:09,690 --> 01:01:13,539
next thing I do is add.

1111
01:01:13,539 --> 01:01:16,500
So I'm just going to set
up my N that way.

1112
01:01:16,500 --> 01:01:28,989
Assign N minus difference
of fetch N and 2.

1113
01:01:28,989 --> 01:01:31,849


1114
01:01:31,849 --> 01:01:35,440
Now I have to finish the
setup for calling

1115
01:01:35,440 --> 01:01:36,950
Fibonacci of N minus 2.

1116
01:01:36,949 --> 01:01:48,329
Well, I have to save up continue
and assign continue,

1117
01:01:48,329 --> 01:02:03,049
continue, to the place which is
after Fib N 2, that place

1118
01:02:03,050 --> 01:02:05,320
over here somewhere.

1119
01:02:05,320 --> 01:02:08,650
However, I've got to
be very careful.

1120
01:02:08,650 --> 01:02:12,470
The old value, the value of Fib
of N minus 1, I'm going to

1121
01:02:12,469 --> 01:02:15,299
need later.

1122
01:02:15,300 --> 01:02:18,480
The value of Fibonacci of N
minus 1, I'm going to need.

1123
01:02:18,480 --> 01:02:21,880
And I can't clobber it, because
I'm going to have to

1124
01:02:21,880 --> 01:02:24,150
add it to the value of
Fib of N minus 2.

1125
01:02:24,150 --> 01:02:27,720
That's in the value register,
so I'm going to save it.

1126
01:02:27,719 --> 01:02:33,779
So I have to save this right
now, save up VAL.

1127
01:02:33,780 --> 01:02:39,547
And now I can go off to my
subroutine, go to Fib loop.

1128
01:02:39,547 --> 01:02:44,219


1129
01:02:44,219 --> 01:02:49,459
Now before I go any further
and finish this program, I

1130
01:02:49,460 --> 01:02:52,340
just want to look at this
segment so far and see, oh

1131
01:02:52,340 --> 01:02:55,519
yes, there's a sequence of
instructions here, if you

1132
01:02:55,519 --> 01:03:01,579
will, that I can do
something about.

1133
01:03:01,579 --> 01:03:06,009
Here I have a restore of
continue, a save of continue,

1134
01:03:06,010 --> 01:03:09,200
and then an assign of continue,
with no other

1135
01:03:09,199 --> 01:03:10,639
references to continue
in between.

1136
01:03:10,639 --> 01:03:13,839


1137
01:03:13,840 --> 01:03:15,519
The restore followed
by the save

1138
01:03:15,519 --> 01:03:16,769
leaves the stack unchanged.

1139
01:03:16,769 --> 01:03:19,090


1140
01:03:19,090 --> 01:03:21,250
The only difference is that I
set the continue register to a

1141
01:03:21,250 --> 01:03:24,329
value, which is the value
that was on the stack.

1142
01:03:24,329 --> 01:03:27,360
Since I now clobber that value,
as in it was never

1143
01:03:27,360 --> 01:03:31,710
referenced, these instructions
are unnecessary.

1144
01:03:31,710 --> 01:03:35,389
So we will remove these.

1145
01:03:35,389 --> 01:03:38,549


1146
01:03:38,550 --> 01:03:40,210
But I couldn't have seen
that unless I had

1147
01:03:40,210 --> 01:03:41,460
written them down.

1148
01:03:41,460 --> 01:03:43,780


1149
01:03:43,780 --> 01:03:45,590
Was that really true?

1150
01:03:45,590 --> 01:03:48,610
Well, I don't know.

1151
01:03:48,610 --> 01:03:51,559
OK, so we've now gone
off to compute

1152
01:03:51,559 --> 01:03:53,659
Fibonacci of N minus 2.

1153
01:03:53,659 --> 01:04:05,069
So after that, what are
we going to do?

1154
01:04:05,070 --> 01:04:07,010
Well, I suppose the first
thing we have to do--

1155
01:04:07,010 --> 01:04:07,960
we've got two things.

1156
01:04:07,960 --> 01:04:09,460
We've got a thing in
the value register

1157
01:04:09,460 --> 01:04:10,920
which is now valuable.

1158
01:04:10,920 --> 01:04:12,610
We also have a thing on the
stack that can be restored

1159
01:04:12,610 --> 01:04:14,815
into the value register.

1160
01:04:14,815 --> 01:04:17,630
And what I have to be careful
with now is I want to shuffle

1161
01:04:17,630 --> 01:04:19,470
this right so I can
do the multiply.

1162
01:04:19,469 --> 01:04:21,599
Now there are various
conventions I might use, but

1163
01:04:21,599 --> 01:04:24,509
I'm going to be very picky and
say, I'm only going to restore

1164
01:04:24,510 --> 01:04:26,740
into a register I've
saved from.

1165
01:04:26,739 --> 01:04:30,019
If that's the case, I have
to do a shuffle here.

1166
01:04:30,019 --> 01:04:32,949
It's the same problem with how
many hands I have. So I'm

1167
01:04:32,949 --> 01:04:37,799
going to assign to N, because
I'm not going to need N

1168
01:04:37,800 --> 01:04:45,440
anymore, N is useless, the
current value of VAL, which

1169
01:04:45,440 --> 01:04:47,340
was the value of Fib
of N minus 2.

1170
01:04:47,340 --> 01:04:52,950


1171
01:04:52,949 --> 01:04:56,179
And I'm going to restore
the value register now.

1172
01:04:56,179 --> 01:05:01,849


1173
01:05:01,849 --> 01:05:06,289
This restore matches this
save. And if you're very

1174
01:05:06,289 --> 01:05:09,820
careful and examine very
carefully what goes on,

1175
01:05:09,820 --> 01:05:13,840
restores and saves are
always matched.

1176
01:05:13,840 --> 01:05:15,660
Now there's an outstanding save,
of course, that we have

1177
01:05:15,659 --> 01:05:19,000
to get rid of soon.

1178
01:05:19,000 --> 01:05:20,590
And so I restored the
value register.

1179
01:05:20,590 --> 01:05:34,850
Now I restore the continue one,
which matches this one,

1180
01:05:34,849 --> 01:05:41,299
dot, dot, dot, dot, dot, dot,
dot, down to here, restoring

1181
01:05:41,300 --> 01:05:42,860
that continuation.

1182
01:05:42,860 --> 01:05:46,599
That continuation is a
continuation of Fib of N,

1183
01:05:46,599 --> 01:05:48,329
which is the problem I was
trying to solve, a major

1184
01:05:48,329 --> 01:05:49,664
problem I'm trying to solve.

1185
01:05:49,664 --> 01:05:52,670
So that's the guy I have to go
back to who wants Fib of N. I

1186
01:05:52,670 --> 01:05:55,470
saved them all the way up here
when I realized N was

1187
01:05:55,469 --> 01:05:57,359
not less than 2.

1188
01:05:57,360 --> 01:06:00,840
And so I had to do a complicated
operation.

1189
01:06:00,840 --> 01:06:03,240
Now I've got everything
I need to do it.

1190
01:06:03,239 --> 01:06:17,469
So I'm going to restore that,
assign to VAL the sum of fetch

1191
01:06:17,469 --> 01:06:28,334
VAL and fetch of N, and
go to continue.

1192
01:06:28,335 --> 01:06:38,260


1193
01:06:38,260 --> 01:06:45,750
So now I've returned from
computing Fibonacci of N, the

1194
01:06:45,750 --> 01:06:47,110
general case.

1195
01:06:47,110 --> 01:06:51,230
Now what's left is we have to
fix up a few details, like

1196
01:06:51,230 --> 01:07:03,750
there's the base case of this
induction, immediate answer,

1197
01:07:03,750 --> 01:07:13,710
which is nothing more than
assign to VAL fetch of N,

1198
01:07:13,710 --> 01:07:17,119
because N was less than 2, and
therefore, the answer is N in

1199
01:07:17,119 --> 01:07:26,094
our original program, and
return continue--

1200
01:07:26,094 --> 01:07:31,459


1201
01:07:31,460 --> 01:07:34,800
bobble, bobble almost--

1202
01:07:34,800 --> 01:07:36,130
and finally Fib done.

1203
01:07:36,130 --> 01:07:43,460


1204
01:07:43,460 --> 01:07:45,639
So that's a fairly complicated
program.

1205
01:07:45,639 --> 01:07:47,949
And the reason I wanted you see
to that is because I want

1206
01:07:47,949 --> 01:07:51,739
you to see the particular
flavors of stack discipline

1207
01:07:51,739 --> 01:07:52,964
that I was obeying.

1208
01:07:52,965 --> 01:07:57,240
It was first of all, I don't
want to take anything that I'm

1209
01:07:57,239 --> 01:08:00,394
not going to need later.

1210
01:08:00,394 --> 01:08:01,849
I was being very careful.

1211
01:08:01,849 --> 01:08:03,940
And it's very important.

1212
01:08:03,940 --> 01:08:07,095
And there are all sorts of other
disciplines people make

1213
01:08:07,094 --> 01:08:10,519
with frames and things like that
of some sort, where you

1214
01:08:10,519 --> 01:08:12,280
save all sorts of junk you're
not going to need later and

1215
01:08:12,280 --> 01:08:15,830
restore it because, in some
sense, it's easier to do that.

1216
01:08:15,829 --> 01:08:19,109
That's going to lead to various
disasters, which we'll

1217
01:08:19,109 --> 01:08:21,740
see a little later.

1218
01:08:21,739 --> 01:08:23,559
It's crucial to say exactly
what you're

1219
01:08:23,560 --> 01:08:24,810
going to need later.

1220
01:08:24,810 --> 01:08:26,899


1221
01:08:26,899 --> 01:08:29,859
It's an important idea.

1222
01:08:29,859 --> 01:08:34,020
And the responsibility of that
is whoever saves something is

1223
01:08:34,020 --> 01:08:36,930
the guy who restores it,
because he needs it.

1224
01:08:36,930 --> 01:08:40,130
And in such discipline, you
can see what things are

1225
01:08:40,130 --> 01:08:46,940
unnecessary, operations
that are unimportant.

1226
01:08:46,939 --> 01:08:49,949
Now, one other thing I want to
tell you about that's very

1227
01:08:49,949 --> 01:08:54,119
simple is that, of course, the
picture you see is not the

1228
01:08:54,119 --> 01:08:55,349
whole picture.

1229
01:08:55,350 --> 01:08:58,430
Supposing I had systems that
had things like other

1230
01:08:58,430 --> 01:09:06,079
operations, CAR, CDR, cons,
building a vector and

1231
01:09:06,079 --> 01:09:10,000
referencing the nth element of
it, or things like that.

1232
01:09:10,000 --> 01:09:14,229
Well, at this level of detail,
whatever it is, we can

1233
01:09:14,229 --> 01:09:15,520
conceptualize those
as primitive

1234
01:09:15,520 --> 01:09:18,299
operations in the datapath.

1235
01:09:18,298 --> 01:09:21,019
In other words, we could say
that some machine that, for

1236
01:09:21,020 --> 01:09:25,460
example, has the append machine,
which has to do cons

1237
01:09:25,460 --> 01:09:29,869
of the CAR of x with the append
of the CDR of x and y,

1238
01:09:29,869 --> 01:09:31,149
well, gee, that's exactly
the same as

1239
01:09:31,149 --> 01:09:33,630
the factorial structure.

1240
01:09:33,630 --> 01:09:36,132
Well, it's got about
the same structure.

1241
01:09:36,132 --> 01:09:37,269
And what do we have?

1242
01:09:37,270 --> 01:09:41,590
We have some sort of things in
it which may be registers, x

1243
01:09:41,590 --> 01:09:45,489
and y, and then x has to somehow
move to y sometimes, x

1244
01:09:45,489 --> 01:09:46,938
has to get the value of y.

1245
01:09:46,939 --> 01:09:48,000
And then we may have
to be able to do

1246
01:09:48,000 --> 01:09:51,699
something which is a cons.

1247
01:09:51,699 --> 01:09:57,760
I don't remember if I need to
like this is in this system,

1248
01:09:57,760 --> 01:10:01,420
but cons is sort of like
subtract or add or something.

1249
01:10:01,420 --> 01:10:03,800
It combines two things,
producing a thing which is the

1250
01:10:03,800 --> 01:10:07,600
cons, which we may then
think goes into there.

1251
01:10:07,600 --> 01:10:14,920
And then maybe a thing called
the CAR, which will produce--

1252
01:10:14,920 --> 01:10:16,920
I can get the CAR
or something.

1253
01:10:16,920 --> 01:10:20,149
And maybe I can get the CDR
of something, and so on.

1254
01:10:20,149 --> 01:10:22,729
But we shouldn't be too afraid
of saying things this way,

1255
01:10:22,729 --> 01:10:27,329
because the worst that could
happen is if we open up cons,

1256
01:10:27,329 --> 01:10:31,769
what we're going to find
is some machine.

1257
01:10:31,770 --> 01:10:33,750
And cons may in fact overlap
with CAR and CDR, and it

1258
01:10:33,750 --> 01:10:38,659
always does, in the same way
that plus and minus overlap,

1259
01:10:38,659 --> 01:10:41,210
and really the same business.

1260
01:10:41,210 --> 01:10:42,949
Cons, CAR, and CDR are going to
overlap, and we're going to

1261
01:10:42,949 --> 01:10:48,630
find a little controller, a
little datapath, which may

1262
01:10:48,630 --> 01:10:53,300
have some registers in it,
some stuff like that.

1263
01:10:53,300 --> 01:10:56,650
And maybe inside it, there may
also be an infinite part, a

1264
01:10:56,649 --> 01:10:59,439
part that's semi-infinite or
something, which is a lot of

1265
01:10:59,439 --> 01:11:02,029
very uniform stuff, which
we'll call memory.

1266
01:11:02,029 --> 01:11:06,569


1267
01:11:06,569 --> 01:11:09,329
And I wouldn't be so horrified
if that were the way it works.

1268
01:11:09,329 --> 01:11:13,319
In fact, it does, and we'll
talk about that later.

1269
01:11:13,319 --> 01:11:14,569
So are there any questions?

1270
01:11:14,569 --> 01:11:24,340


1271
01:11:24,340 --> 01:11:25,664
Gee, what an unquestioning
audience.

1272
01:11:25,664 --> 01:11:28,670


1273
01:11:28,670 --> 01:11:30,329
Suppose I tell you a horrible
pile of lies.

1274
01:11:30,329 --> 01:11:39,689


1275
01:11:39,689 --> 01:11:41,989
OK.

1276
01:11:41,989 --> 01:11:42,519
Well, thank you.

1277
01:11:42,520 --> 01:11:44,230
Let's take our break.

1278
01:11:44,229 --> 01:11:47,229
[MUSIC PLAYING - "JESU, JOY OF
MAN'S DESIRING" BY JOHANN

1279
01:11:47,229 --> 01:11:48,779
SEBASTIAN BACH]

1280
01:11:48,779 --> 01:11:56,123


