1
00:00:00,000 --> 00:00:20,969


2
00:00:20,969 --> 00:00:24,579
PROFESSOR: OK, well, we've been
looking at streams, this

3
00:00:24,579 --> 00:00:28,869
signal processing way of putting
systems together.

4
00:00:28,870 --> 00:00:35,200
And remember, the key idea is
that we decouple the apparent

5
00:00:35,200 --> 00:00:38,480
order of events in our programs
from the actual order

6
00:00:38,479 --> 00:00:40,634
of events in the computer.

7
00:00:40,634 --> 00:00:43,629
And that means that we can start
dealing with very long

8
00:00:43,630 --> 00:00:46,340
streams and only having
to generate

9
00:00:46,340 --> 00:00:47,500
the elements on demand.

10
00:00:47,500 --> 00:00:50,310
That sort of on-demand
computation is built into the

11
00:00:50,310 --> 00:00:51,560
stream's data structure.

12
00:00:51,560 --> 00:00:54,450


13
00:00:54,450 --> 00:00:55,990
So if we have a very long
stream, we only

14
00:00:55,990 --> 00:00:58,039
compute what we need.

15
00:00:58,039 --> 00:01:00,750
The things only get computed
when we actually ask for them.

16
00:01:00,750 --> 00:01:02,109
Well, what are examples?

17
00:01:02,109 --> 00:01:04,799
Are they actually
asking for them?

18
00:01:04,799 --> 00:01:11,049
For instance, we might ask for
the n-th element of a stream.

19
00:01:11,049 --> 00:01:16,359


20
00:01:16,359 --> 00:01:18,129
Here's a procedure that
computes the n-th

21
00:01:18,129 --> 00:01:20,399
element of a stream.

22
00:01:20,400 --> 00:01:23,810
An integer n, the n-th element
of some stream s, and we just

23
00:01:23,810 --> 00:01:25,570
recursively walk down
the stream.

24
00:01:25,569 --> 00:01:27,959
And the end of 0, we
compute the head.

25
00:01:27,959 --> 00:01:32,349
Otherwise, it's the n-th the
minus 1 element of the tail of

26
00:01:32,349 --> 00:01:34,309
the stream.

27
00:01:34,310 --> 00:01:36,570
Those two are just like for
Lisp, but the difference is

28
00:01:36,569 --> 00:01:39,579
those elements aren't going to
get computed until we walk

29
00:01:39,579 --> 00:01:41,700
down, taking successive n-ths.

30
00:01:41,700 --> 00:01:43,630
So that's one way
that the stream

31
00:01:43,629 --> 00:01:45,909
elements might get forced.

32
00:01:45,909 --> 00:01:47,979
And another way, here's
a little procedure

33
00:01:47,980 --> 00:01:49,299
that prints a stream.

34
00:01:49,299 --> 00:01:54,149
We say print a stream, so
to print a stream s.

35
00:01:54,150 --> 00:01:55,315
Well, what do we do?

36
00:01:55,314 --> 00:01:58,269
We print the head of the stream,
and that will cause

37
00:01:58,269 --> 00:01:59,719
the head to be computed.

38
00:01:59,719 --> 00:02:04,989
And then we recursively print
stream the tail of the stream.

39
00:02:04,989 --> 00:02:07,189
And if we're already done,
maybe we have to return

40
00:02:07,189 --> 00:02:09,659
something about the
message done.

41
00:02:09,659 --> 00:02:12,250
OK, and then so if you make a
stream, you could say here's

42
00:02:12,250 --> 00:02:14,310
the stream, this very
long stream.

43
00:02:14,310 --> 00:02:16,990
And then you say print the
stream, and the elements of

44
00:02:16,990 --> 00:02:20,550
the stream will get computed
successively as that print

45
00:02:20,550 --> 00:02:21,320
calls them.

46
00:02:21,319 --> 00:02:24,680
They won't get all computed
initially.

47
00:02:24,680 --> 00:02:30,189
So in this way, we can deal with
some very long streams.

48
00:02:30,189 --> 00:02:33,599
Well, how long can
a stream be?

49
00:02:33,599 --> 00:02:36,359
Well, it can be infinitely
long.

50
00:02:36,360 --> 00:02:38,920
Let's look at an example
here on the computer.

51
00:02:38,919 --> 00:02:43,399
I could walk up to this
computer, and I could say--

52
00:02:43,400 --> 00:02:52,270
how about we'll define the
stream of integers starting

53
00:02:52,270 --> 00:02:56,170
with some number N, the stream
of positive integers starting

54
00:02:56,169 --> 00:02:57,419
with some number n.

55
00:02:57,419 --> 00:02:59,759


56
00:02:59,759 --> 00:03:12,989
And that's cons-stream
of n onto the

57
00:03:12,990 --> 00:03:19,010
integers from one more.

58
00:03:19,009 --> 00:03:24,679


59
00:03:24,680 --> 00:03:25,930
So there are the integers.

60
00:03:25,930 --> 00:03:28,800


61
00:03:28,800 --> 00:03:31,500
Then I could say let's
get all the integers.

62
00:03:31,500 --> 00:03:34,409


63
00:03:34,409 --> 00:03:43,329
define the stream of integers
to be the integers

64
00:03:43,330 --> 00:03:44,580
starting with 1.

65
00:03:44,580 --> 00:03:48,840


66
00:03:48,840 --> 00:03:54,950
And now if I say something like
what's the what's the

67
00:03:54,949 --> 00:04:02,994
20th integer.

68
00:04:02,995 --> 00:04:07,270
So it's 21 because we
start counting at 0.

69
00:04:07,270 --> 00:04:09,450
Or I can do more complicated
things.

70
00:04:09,449 --> 00:04:10,839
Let me to define a little
predicate here.

71
00:04:10,840 --> 00:04:13,740


72
00:04:13,740 --> 00:04:19,160
How about define no-seven.

73
00:04:19,160 --> 00:04:22,126
It's going to test an
integer, and it's

74
00:04:22,125 --> 00:04:23,375
going to say it's not.

75
00:04:23,375 --> 00:04:28,819


76
00:04:28,819 --> 00:04:38,175
I take the remainder of
x by 7, I don't get 0.

77
00:04:38,175 --> 00:04:41,889


78
00:04:41,889 --> 00:04:50,360
And then I could say define the
integers with no sevens to

79
00:04:50,360 --> 00:04:58,884
be, take all the integers and
filter them to have no sevens.

80
00:04:58,884 --> 00:05:11,569


81
00:05:11,569 --> 00:05:14,060
So now I've got the stream of
all the integers that are not

82
00:05:14,060 --> 00:05:16,360
divisible by seven.

83
00:05:16,360 --> 00:05:25,420
So if I say what's the 100th
integer and the list not

84
00:05:25,420 --> 00:05:28,319
divisible by seven, I get 117.

85
00:05:28,319 --> 00:05:35,269
Or if I'd like to say well,
gee, what are all of them?

86
00:05:35,269 --> 00:05:39,810
So I could say print stream
all these integers with no

87
00:05:39,810 --> 00:05:41,699
seven, it goes off printing.

88
00:05:41,699 --> 00:05:45,099


89
00:05:45,100 --> 00:05:47,070
You may have to wait a very
long time to see them all.

90
00:05:47,069 --> 00:05:52,670


91
00:05:52,670 --> 00:05:56,040
Well, you can start asking, gee,
is it really true that

92
00:05:56,040 --> 00:05:59,080
this data structure with
the integers is

93
00:05:59,079 --> 00:06:01,099
really all the integers?

94
00:06:01,100 --> 00:06:04,052
And let me draw a picture of
that program I just wrote.

95
00:06:04,052 --> 00:06:08,170


96
00:06:08,170 --> 00:06:09,980
Here's the definition of the
integers again that I just

97
00:06:09,980 --> 00:06:14,850
typed in, Right it's a cons of
the first integer under the

98
00:06:14,850 --> 00:06:18,120
integer starting with the
rest. Now, we can make a

99
00:06:18,120 --> 00:06:19,774
picture of that and see
what it looks like.

100
00:06:19,774 --> 00:06:22,719


101
00:06:22,720 --> 00:06:26,270
Conceptually, what I have is
a box that's the integer

102
00:06:26,269 --> 00:06:27,419
starting with n.

103
00:06:27,420 --> 00:06:31,900
It takes in some number
n, and it's going to

104
00:06:31,899 --> 00:06:35,049
return a stream of--

105
00:06:35,050 --> 00:06:37,704
this infinite stream of all
integers starting with n.

106
00:06:37,704 --> 00:06:38,689
And what do I do?

107
00:06:38,689 --> 00:06:42,469
Well, this is an integers
from box.

108
00:06:42,470 --> 00:06:45,070


109
00:06:45,069 --> 00:06:45,800
What's it got in it?

110
00:06:45,800 --> 00:06:54,110
Well, it takes in this n,
and it increments it.

111
00:06:54,110 --> 00:06:58,030


112
00:06:58,029 --> 00:07:01,919
And then it puts the result
into recursively another

113
00:07:01,920 --> 00:07:03,170
integer's from box.

114
00:07:03,170 --> 00:07:06,870


115
00:07:06,870 --> 00:07:10,629
It takes the result of that and
the original n and puts

116
00:07:10,629 --> 00:07:14,269
those together with a cons
and forms a stream.

117
00:07:14,269 --> 00:07:18,529
So that's a picture of
that program I wrote.

118
00:07:18,529 --> 00:07:18,779
Let's see.

119
00:07:18,779 --> 00:07:21,379
These kind of diagrams we
first saw drawn by Peter

120
00:07:21,379 --> 00:07:23,319
Henderson, the same guy who
did the Escher language.

121
00:07:23,319 --> 00:07:26,170
We call them Henderson diagrams.
And the convention

122
00:07:26,170 --> 00:07:28,530
here is that you put these
things together.

123
00:07:28,529 --> 00:07:33,259
And the solid lines are things
coming out are streams, and

124
00:07:33,259 --> 00:07:37,269
dotted lines are initial
values going in.

125
00:07:37,269 --> 00:07:39,439
So this one has the shape of--

126
00:07:39,439 --> 00:07:41,819
it takes in some integer,
some initial value,

127
00:07:41,819 --> 00:07:43,069
and outputs a stream.

128
00:07:43,069 --> 00:07:46,409


129
00:07:46,410 --> 00:07:48,380
Again, you can ask.

130
00:07:48,379 --> 00:07:49,709
Is that data structure integers

131
00:07:49,709 --> 00:07:52,339
really all the integers?

132
00:07:52,339 --> 00:07:55,189
Or is it is something that's
cleverly arranged so that

133
00:07:55,189 --> 00:07:58,189
whenever you look for an integer
you find it there?

134
00:07:58,189 --> 00:07:59,779
That's sort of a philosophical
question, right?

135
00:07:59,779 --> 00:08:03,089
If something is there whenever
you look, is it

136
00:08:03,089 --> 00:08:04,449
really there or not?

137
00:08:04,449 --> 00:08:07,969
It's sort of the same sense
in which the money in your

138
00:08:07,970 --> 00:08:09,420
savings account is
in the bank.

139
00:08:09,420 --> 00:08:12,379


140
00:08:12,379 --> 00:08:19,829
Well, let me do another
example.

141
00:08:19,829 --> 00:08:22,039
Gee, we started the course
with an algorithm from

142
00:08:22,040 --> 00:08:25,910
Alexandria, which was Heron of
Alexandria's algorithm for

143
00:08:25,910 --> 00:08:28,470
computing the square root.

144
00:08:28,470 --> 00:08:32,029
Let's take a look at another
Alexandrian algorithm.

145
00:08:32,029 --> 00:08:37,860
This one is Eratosthenes method
for computing all of

146
00:08:37,860 --> 00:08:39,110
the primes.

147
00:08:39,110 --> 00:08:41,168


148
00:08:41,168 --> 00:08:42,829
It is called the Sieve
of Eratosthenes.

149
00:08:42,830 --> 00:08:51,830
And what you do is you start
out, and you list all the

150
00:08:51,830 --> 00:08:53,879
integers, say, starting
with 2.

151
00:08:53,879 --> 00:08:55,889
And then you take the first
integer, and you say, oh,

152
00:08:55,889 --> 00:08:57,309
that's prime.

153
00:08:57,309 --> 00:08:59,599
And then you go look at the
rest, and you cross out all

154
00:08:59,600 --> 00:09:01,230
the things divisible by 2.

155
00:09:01,230 --> 00:09:05,250
So I cross out this
and this and this.

156
00:09:05,250 --> 00:09:07,259
This takes a long time because
I have to do it

157
00:09:07,259 --> 00:09:11,159
for all of the integers.

158
00:09:11,159 --> 00:09:19,679
So I go through the entire list
of integers, crossing the

159
00:09:19,679 --> 00:09:22,009
ones divisible by 2.

160
00:09:22,009 --> 00:09:25,399
And now when I finish with all
of the integers, I go back and

161
00:09:25,399 --> 00:09:27,039
look and say what
am I left with?

162
00:09:27,039 --> 00:09:29,329
Well, the first thing that
starts there is 3.

163
00:09:29,330 --> 00:09:30,770
So 3 is a prime.

164
00:09:30,769 --> 00:09:33,949
And now I go back through what
I'm left with, and I cross out

165
00:09:33,950 --> 00:09:35,120
all the things divisible by 3.

166
00:09:35,120 --> 00:09:44,049
So let's see, 9 and 15 and 21
and 27 and 33 and so on.

167
00:09:44,049 --> 00:09:45,349
I won't finish.

168
00:09:45,350 --> 00:09:47,250
Then I see what I'm left with.

169
00:09:47,250 --> 00:09:50,860
And the next one I have is 5.

170
00:09:50,860 --> 00:09:53,470
Now I can through the rest,
and I find the first one

171
00:09:53,470 --> 00:09:54,540
that's divisible by 5.

172
00:09:54,539 --> 00:09:56,589
I cross out from the remainder
all the ones that are

173
00:09:56,590 --> 00:09:58,030
divisible by 5.

174
00:09:58,029 --> 00:10:01,889
And I do that, and then I
go through and find 7.

175
00:10:01,889 --> 00:10:04,169
Go through all the rest, cross
out things divisible 7, and I

176
00:10:04,169 --> 00:10:06,809
keep doing that forever.

177
00:10:06,809 --> 00:10:08,099
And when I'm done, what
I'm left with is a

178
00:10:08,100 --> 00:10:10,120
list of all the primes.

179
00:10:10,120 --> 00:10:15,429
So that's the Sieve
of Eratosthenes.

180
00:10:15,429 --> 00:10:17,929
Let's look at it as a
computer program.

181
00:10:17,929 --> 00:10:19,549
It's a procedure called sieve.

182
00:10:19,549 --> 00:10:27,909


183
00:10:27,909 --> 00:10:30,480
Now, I just write what I did.

184
00:10:30,480 --> 00:10:34,509
I'll say to sieve
some stream s.

185
00:10:34,509 --> 00:10:38,769


186
00:10:38,769 --> 00:10:41,279
I'm going to build a stream
whose first element is the

187
00:10:41,279 --> 00:10:41,870
head of this.

188
00:10:41,870 --> 00:10:44,929
Remember, I always found the
first thing I was left with,

189
00:10:44,929 --> 00:10:48,479
and the rest of it is the result
of taking the tail of

190
00:10:48,480 --> 00:10:54,029
this, filtering it to throw away
all the things that are

191
00:10:54,029 --> 00:10:59,019
divisible by the head of this,
and now sieving the result.

192
00:10:59,019 --> 00:11:01,980
That's just what I did.

193
00:11:01,980 --> 00:11:05,560
And now to get the infinite
stream of times, we just sieve

194
00:11:05,559 --> 00:11:06,899
all the integers starting
from 2.

195
00:11:06,899 --> 00:11:14,919


196
00:11:14,919 --> 00:11:16,299
Let's try that.

197
00:11:16,299 --> 00:11:19,759
We can actually do it.

198
00:11:19,759 --> 00:11:23,169
I typed in the definition of
sieve before, I hope, so I can

199
00:11:23,169 --> 00:11:35,339
say something like define the
primes to be the result of

200
00:11:35,340 --> 00:11:41,350
sieving the integers
starting with 2.

201
00:11:41,350 --> 00:11:46,759


202
00:11:46,759 --> 00:11:48,100
So now I've got this
list of primes.

203
00:11:48,100 --> 00:11:50,990
That's all of the
primes, right?

204
00:11:50,990 --> 00:12:01,009
So, if for example, what's the
20th prime in that list?

205
00:12:01,009 --> 00:12:02,539
73.

206
00:12:02,539 --> 00:12:05,079
See, and that little pause, it
was only at the point when I

207
00:12:05,080 --> 00:12:06,500
started asking for
the 20th prime is

208
00:12:06,500 --> 00:12:07,750
that it started computing.

209
00:12:07,750 --> 00:12:10,370


210
00:12:10,370 --> 00:12:14,960
Or I can say here let's look
at all of the primes.

211
00:12:14,960 --> 00:12:22,780


212
00:12:22,779 --> 00:12:25,350
And there it goes computing
all of the primes.

213
00:12:25,350 --> 00:12:26,970
Of course, it will take a while
again if I want to look

214
00:12:26,970 --> 00:12:28,570
at all of them, so
let's stop it.

215
00:12:28,570 --> 00:12:32,030


216
00:12:32,029 --> 00:12:33,129
Let me draw you a
picture of that.

217
00:12:33,129 --> 00:12:34,889
Well, I've got a picture
of that.

218
00:12:34,889 --> 00:12:37,899
What's that program
really look like?

219
00:12:37,899 --> 00:12:39,549
Again, some practice with
these diagrams, I

220
00:12:39,549 --> 00:12:42,609
have a sieve box.

221
00:12:42,610 --> 00:12:43,560
How does sieve work?

222
00:12:43,559 --> 00:12:44,809
It takes in a stream.

223
00:12:44,809 --> 00:12:48,849


224
00:12:48,850 --> 00:12:50,870
It splits off the head
from the tail.

225
00:12:50,870 --> 00:12:53,500
And the first thing that's going
to come out of the sieve

226
00:12:53,500 --> 00:12:54,970
is the head of the
original stream.

227
00:12:54,970 --> 00:12:57,796


228
00:12:57,796 --> 00:13:02,550
Then it also takes the
head and uses that.

229
00:13:02,549 --> 00:13:03,849
It takes the stream.

230
00:13:03,850 --> 00:13:07,290
It filters the tail and uses
the head to filter for

231
00:13:07,289 --> 00:13:09,151
nondivisibility.

232
00:13:09,152 --> 00:13:11,710
It takes the result of
nondivisibility and puts it

233
00:13:11,710 --> 00:13:15,129
through another sieve box and
puts the result together.

234
00:13:15,129 --> 00:13:17,889
So you can think of this sieve a
filter, but notice that it's

235
00:13:17,889 --> 00:13:19,649
an infinitely recursive
filter.

236
00:13:19,649 --> 00:13:23,559
Because inside the sieve box
is another sieve box, and

237
00:13:23,559 --> 00:13:27,129
inside that is another sieve
box and another sieve box.

238
00:13:27,129 --> 00:13:28,960
So you see we start getting
some very powerful things.

239
00:13:28,960 --> 00:13:32,389
We're starting to mix this
signal processing view of the

240
00:13:32,389 --> 00:13:35,759
world with things like recursion
that come from

241
00:13:35,759 --> 00:13:36,689
computation.

242
00:13:36,690 --> 00:13:39,210
And there are all sorts of
interesting things you can do

243
00:13:39,210 --> 00:13:40,970
that are like this.

244
00:13:40,970 --> 00:13:42,220
All right, any questions?

245
00:13:42,220 --> 00:13:48,190


246
00:13:48,190 --> 00:13:49,440
OK, let's take a break.

247
00:13:49,440 --> 00:14:28,820


248
00:14:28,820 --> 00:14:31,440
Well, we've been looking at a
couple of examples of stream

249
00:14:31,440 --> 00:14:32,690
programming.

250
00:14:32,690 --> 00:14:34,790


251
00:14:34,789 --> 00:14:39,919
All the stream procedures that
we've looked at so far have

252
00:14:39,919 --> 00:14:41,490
the same kind of character.

253
00:14:41,490 --> 00:14:44,470
We've been writing these
recursive procedures that kind

254
00:14:44,470 --> 00:14:46,820
of generate these stream
elements one at a time and put

255
00:14:46,820 --> 00:14:50,030
them together in cons-streams.
So we've been thinking a lot

256
00:14:50,029 --> 00:14:51,000
about generators.

257
00:14:51,000 --> 00:14:53,970
There's another way to think
about stream processing, and

258
00:14:53,970 --> 00:14:57,840
that's to focus not on programs
that sort of process

259
00:14:57,840 --> 00:15:00,840
these elements as you walk down
the stream, but on things

260
00:15:00,840 --> 00:15:07,350
that kind of process the
streams all at once.

261
00:15:07,350 --> 00:15:09,950
To show you what I mean, let
me start by defining two

262
00:15:09,950 --> 00:15:12,410
procedures that will
come in handy.

263
00:15:12,409 --> 00:15:17,579
The first one's called add
streams. Add streams takes two

264
00:15:17,580 --> 00:15:22,330
streams: s1 and s2.

265
00:15:22,330 --> 00:15:22,460
and.

266
00:15:22,460 --> 00:15:27,240
It's going to produce a stream
whose elements are the are the

267
00:15:27,240 --> 00:15:32,970
corresponding sums. We just sort
of add them element-wise.

268
00:15:32,970 --> 00:15:36,810
If either stream is empty, we
just return the other one.

269
00:15:36,809 --> 00:15:42,000
Otherwise, we're going to make a
new stream whose head is the

270
00:15:42,000 --> 00:15:46,889
sum of the two heads and whose
tail is the result of

271
00:15:46,889 --> 00:15:50,090
recursively adding the tails.

272
00:15:50,090 --> 00:15:52,100
So that will produce the
element-wise sum of two

273
00:15:52,100 --> 00:15:53,149
streams.

274
00:15:53,149 --> 00:15:55,829
And then another useful
thing to have

275
00:15:55,830 --> 00:15:57,500
around is scale stream.

276
00:15:57,500 --> 00:16:04,149
Scale stream takes some constant
number in a stream s

277
00:16:04,149 --> 00:16:08,139
and is going to produce the
stream of elements of s

278
00:16:08,139 --> 00:16:09,710
multiplied by this constant.

279
00:16:09,710 --> 00:16:14,320
And that's easy, that's just
a map of the function of an

280
00:16:14,320 --> 00:16:17,040
element that multiplies it by
the constant, and we map that

281
00:16:17,039 --> 00:16:18,289
down the stream.

282
00:16:18,289 --> 00:16:20,519


283
00:16:20,519 --> 00:16:23,629
So given those two, let me
show you what I mean by

284
00:16:23,629 --> 00:16:27,909
programs that operate on
streams all at once.

285
00:16:27,909 --> 00:16:30,199
Let's look at this.

286
00:16:30,200 --> 00:16:31,680
Suppose I write this.

287
00:16:31,679 --> 00:16:32,929
I say define--

288
00:16:32,929 --> 00:16:36,617


289
00:16:36,618 --> 00:16:39,590
I'll call it ones--

290
00:16:39,590 --> 00:16:52,190
to be cons-stream
of 1 onto ones.

291
00:16:52,190 --> 00:16:54,860


292
00:16:54,860 --> 00:16:56,950
What's that?

293
00:16:56,950 --> 00:17:00,530
That's going to be an infinite
stream of ones because the

294
00:17:00,529 --> 00:17:03,329
first thing is 1.

295
00:17:03,330 --> 00:17:07,818
And the tail of it is a thing
whose first thing is 1 and

296
00:17:07,818 --> 00:17:11,220
whose tail is a thing whose
first thing is 1 and so on and

297
00:17:11,220 --> 00:17:11,779
so on and so on.

298
00:17:11,779 --> 00:17:15,129
So that's an infinite
stream of ones.

299
00:17:15,130 --> 00:17:17,380
And now using that, let me give
you another definition of

300
00:17:17,380 --> 00:17:18,599
the integers.

301
00:17:18,598 --> 00:17:28,269
We can define the
integers to be--

302
00:17:28,269 --> 00:17:32,819
well, the first integer we'll
take to be 1, this cons-stream

303
00:17:32,819 --> 00:17:42,789
of 1 onto the element-wise sum
onto add streams of the

304
00:17:42,789 --> 00:17:48,269
integers to ones.

305
00:17:48,269 --> 00:17:54,950


306
00:17:54,950 --> 00:18:01,240
The integers are a thing whose
first element is 1, and the

307
00:18:01,240 --> 00:18:04,940
rest of them you get by taking
those integers and

308
00:18:04,940 --> 00:18:06,640
incrementing each one by one.

309
00:18:06,640 --> 00:18:10,400
So the second element of the
integers is the first element

310
00:18:10,400 --> 00:18:13,940
of the integers incremented
by one.

311
00:18:13,940 --> 00:18:15,830
And the rest of that is the
next one, and the third

312
00:18:15,829 --> 00:18:19,689
element of that is the same as
the first element of the tail

313
00:18:19,690 --> 00:18:25,049
of the integers incremented by
one, which is the same as the

314
00:18:25,049 --> 00:18:28,930
first element of the original
integers incremented by one

315
00:18:28,930 --> 00:18:31,250
and incremented by one
again and so on.

316
00:18:31,250 --> 00:18:35,240


317
00:18:35,240 --> 00:18:36,309
That looks pretty suspicious.

318
00:18:36,309 --> 00:18:40,149
See, notice that it works
because of delay.

319
00:18:40,150 --> 00:18:42,480
See, this looks like--

320
00:18:42,480 --> 00:18:43,870
let's take a look at ones.

321
00:18:43,869 --> 00:18:46,809
This looks like it couldn't even
be processed because it's

322
00:18:46,809 --> 00:18:49,409
suddenly saying in order to know
what ones is, I say it's

323
00:18:49,410 --> 00:18:51,130
cons-stream of something
onto ones.

324
00:18:51,130 --> 00:18:53,220
The reason that works is because
of that very sneaky

325
00:18:53,220 --> 00:18:55,250
hidden delay in there.

326
00:18:55,250 --> 00:18:58,869
Because what this really is,
remember, cons-stream is just

327
00:18:58,869 --> 00:19:00,289
an abbreviation.

328
00:19:00,289 --> 00:19:08,784
This really is cons of
1 onto delay of ones.

329
00:19:08,785 --> 00:19:12,140


330
00:19:12,140 --> 00:19:15,500
So how does that work?

331
00:19:15,500 --> 00:19:18,019
You say I'm going
to define ones.

332
00:19:18,019 --> 00:19:20,700
First I see what ones is
supposed to be defined as.

333
00:19:20,700 --> 00:19:27,319
Well, ones is supposed to be
defined as a cons whose first

334
00:19:27,319 --> 00:19:30,069
part is 1 and whose second part
is, well, it's a promise

335
00:19:30,069 --> 00:19:32,710
to compute something that
I don't worry about yet.

336
00:19:32,710 --> 00:19:34,680
So it doesn't bother me that
at the point I do this

337
00:19:34,680 --> 00:19:37,269
definition, ones
isn't defined.

338
00:19:37,269 --> 00:19:40,670
Having run the definition
now, ones is defined.

339
00:19:40,670 --> 00:19:44,920
So that when I go and look at
the tail of it, it's defined.

340
00:19:44,920 --> 00:19:46,590
It's very sneaky.

341
00:19:46,589 --> 00:19:48,470
And an integer is
the same way.

342
00:19:48,470 --> 00:19:52,059
I can refer to integers here
because hidden way down--

343
00:19:52,059 --> 00:19:53,210
because of this cons-stream.

344
00:19:53,210 --> 00:19:56,200
It's the cons-stream of 1
onto something that I

345
00:19:56,200 --> 00:19:57,049
don't worry that yet.

346
00:19:57,049 --> 00:19:58,970
So I don't look at it, and I
don't notice that integers

347
00:19:58,970 --> 00:20:01,319
isn't defined at the point
where I try and run the

348
00:20:01,319 --> 00:20:02,569
definition.

349
00:20:02,569 --> 00:20:06,319


350
00:20:06,319 --> 00:20:08,700
OK, let me draw a picture of
that integers thing because it

351
00:20:08,700 --> 00:20:12,430
still maybe seems a
little bit shaky.

352
00:20:12,430 --> 00:20:15,019
What do I do?

353
00:20:15,019 --> 00:20:23,490
I've got the stream of ones, and
that sort of comes in and

354
00:20:23,490 --> 00:20:25,339
goes into an adder that's
going to be

355
00:20:25,339 --> 00:20:26,589
this add streams thing.

356
00:20:26,589 --> 00:20:29,309


357
00:20:29,309 --> 00:20:33,259
And that goes in--

358
00:20:33,259 --> 00:20:35,759
that's going to put
out the integers.

359
00:20:35,759 --> 00:20:40,759


360
00:20:40,759 --> 00:20:45,279
And the other thing that goes
into the adder here is the

361
00:20:45,279 --> 00:20:48,059
integer, so there's a little
feedback loop.

362
00:20:48,059 --> 00:20:51,929
And all I need to start it off
is someplace I've got a stick

363
00:20:51,930 --> 00:20:53,180
that initial 1.

364
00:20:53,180 --> 00:20:57,100


365
00:20:57,099 --> 00:21:00,000
In a real signal processing
thing, this might be a delay

366
00:21:00,000 --> 00:21:02,910
element with that was
initialized to 1.

367
00:21:02,910 --> 00:21:07,860
But there's a picture of
that ones program.

368
00:21:07,859 --> 00:21:09,859
And in fact, that looks
a lot like--

369
00:21:09,859 --> 00:21:13,909
if you've seen real signal block
diagram things, that

370
00:21:13,910 --> 00:21:17,360
looks a lot like accumulators,
finite state accumulators.

371
00:21:17,359 --> 00:21:21,639
And in fact, we can modify this
a little bit to change

372
00:21:21,640 --> 00:21:25,700
this into something that
integrates a stream or a

373
00:21:25,700 --> 00:21:27,440
finite state accumulator,
however you like

374
00:21:27,440 --> 00:21:28,440
to think about it.

375
00:21:28,440 --> 00:21:30,370
So instead of the ones coming
in and getting out the

376
00:21:30,369 --> 00:21:35,459
integers, what we'll do is say
there's a stream s coming in,

377
00:21:35,460 --> 00:21:43,210
and we're going to get out the
integral of this, successive

378
00:21:43,210 --> 00:21:45,700
values of that, and it looks
almost the same.

379
00:21:45,700 --> 00:21:49,220
The only thing we're going to
do is when s comes in here,

380
00:21:49,220 --> 00:21:53,009
before we just add it in we're
going to multiply it

381
00:21:53,009 --> 00:21:54,259
by some number dt.

382
00:21:54,259 --> 00:21:57,680


383
00:21:57,680 --> 00:21:58,789
And now what we have
here, this is

384
00:21:58,789 --> 00:22:00,000
exactly the same thing.

385
00:22:00,000 --> 00:22:04,019
We have a box, which
is an integrator.

386
00:22:04,019 --> 00:22:09,789


387
00:22:09,789 --> 00:22:15,250
And it takes in a stream s, and
instead of 1 here, we can

388
00:22:15,250 --> 00:22:19,980
put the additional value
for the integral.

389
00:22:19,980 --> 00:22:23,940
And that one looks very much
like a signal processing block

390
00:22:23,940 --> 00:22:25,269
diagram program.

391
00:22:25,269 --> 00:22:27,980
In fact, here's the procedure
that looks exactly like that.

392
00:22:27,980 --> 00:22:31,490


393
00:22:31,490 --> 00:22:34,009
Find the integral of a stream.

394
00:22:34,009 --> 00:22:36,349
So an integral's going to take
a stream and produce a new

395
00:22:36,349 --> 00:22:39,559
stream, and it takes
in an initial value

396
00:22:39,559 --> 00:22:42,230
and some time constant.

397
00:22:42,230 --> 00:22:43,039
And what do we do?

398
00:22:43,039 --> 00:22:45,559
Well, we internally define this
thing int, and we make

399
00:22:45,559 --> 00:22:47,849
this internal name so
we can feed it back,

400
00:22:47,849 --> 00:22:49,399
loop it around itself.

401
00:22:49,400 --> 00:22:52,380
And int is defined to be
something that starts out at

402
00:22:52,380 --> 00:22:58,500
the initial value, and
the rest of it is

403
00:22:58,500 --> 00:23:01,279
gotten by adding together.

404
00:23:01,279 --> 00:23:03,980
We take our input stream,
scale it by dt,

405
00:23:03,980 --> 00:23:06,880
and add that to int.

406
00:23:06,880 --> 00:23:09,130
And now we'll return from all
that the value of integral is

407
00:23:09,130 --> 00:23:10,690
this thing int.

408
00:23:10,690 --> 00:23:13,240
And we use this internal
definition syntax so we could

409
00:23:13,240 --> 00:23:14,670
write a little internal
definition

410
00:23:14,670 --> 00:23:15,920
that refers to itself.

411
00:23:15,920 --> 00:23:21,880


412
00:23:21,880 --> 00:23:23,710
Well, there are all sorts
of things we can do.

413
00:23:23,710 --> 00:23:25,500
Let's try this one.

414
00:23:25,500 --> 00:23:26,894
how about the Fibonacci
numbers.

415
00:23:26,894 --> 00:23:32,625
You can say define fibs.

416
00:23:32,625 --> 00:23:36,349


417
00:23:36,349 --> 00:23:37,984
Well, what are the Fibonacci
numbers?

418
00:23:37,984 --> 00:23:48,839
They're something that starts
out with 0, and

419
00:23:48,839 --> 00:23:50,089
the next one is 1.

420
00:23:50,089 --> 00:23:56,259


421
00:23:56,259 --> 00:24:06,470
And the rest of the Fibonacci
numbers are gotten by adding

422
00:24:06,470 --> 00:24:11,000
the Fibonacci numbers
to their own tail.

423
00:24:11,000 --> 00:24:17,569


424
00:24:17,569 --> 00:24:20,579
There's a definition of
the Fibonacci numbers.

425
00:24:20,579 --> 00:24:21,429
How does that work?

426
00:24:21,430 --> 00:24:25,519
Well, we start off, and someone
says compute for us

427
00:24:25,519 --> 00:24:30,490
the Fibonacci numbers, and we're
going to tell you it

428
00:24:30,490 --> 00:24:31,870
starts out with 0 and 1.

429
00:24:31,869 --> 00:24:35,789


430
00:24:35,789 --> 00:24:40,319
And everything after the 0 and
1 is gotten by summing two

431
00:24:40,319 --> 00:24:44,579
streams. One is the fibs
themselves, and the other one

432
00:24:44,579 --> 00:24:45,829
is the tail of the fibs.

433
00:24:45,829 --> 00:24:48,869


434
00:24:48,869 --> 00:24:52,429
So if I know that these start
out with 0 and 1, I know that

435
00:24:52,430 --> 00:24:56,435
the fibs now start out with 0
and 1, and the tail of the

436
00:24:56,434 --> 00:24:58,359
fibs start out with 1.

437
00:24:58,359 --> 00:25:00,849
So as soon as I know that, I
know that the next one here is

438
00:25:00,849 --> 00:25:04,599
0 plus 1 is 1, and that tells me
that the next one here is 1

439
00:25:04,599 --> 00:25:06,299
and the next one here is 1.

440
00:25:06,299 --> 00:25:09,389
And as soon as I know that, I
know that the next one is 2.

441
00:25:09,390 --> 00:25:11,700
So the next one here is 2 and
the next one here is 2.

442
00:25:11,700 --> 00:25:12,950
And this is 3.

443
00:25:12,950 --> 00:25:14,720


444
00:25:14,720 --> 00:25:18,529
This one goes to 3,
and this is 5.

445
00:25:18,529 --> 00:25:21,500
So it's a perfectly sensible
definition.

446
00:25:21,500 --> 00:25:22,829
It's a one-line definition.

447
00:25:22,829 --> 00:25:25,589
And again, I could walk over to
the computer and type that

448
00:25:25,589 --> 00:25:28,649
in, exactly that, and then say
print stream the Fibonacci

449
00:25:28,650 --> 00:25:30,150
numbers, and they all
come flying out.

450
00:25:30,150 --> 00:25:32,790


451
00:25:32,789 --> 00:25:34,119
See, this is a lot
like learning

452
00:25:34,119 --> 00:25:36,809
about recursion again.

453
00:25:36,809 --> 00:25:41,349
Instead of thinking that
recursive procedures, we have

454
00:25:41,349 --> 00:25:45,159
recursively defined
data objects.

455
00:25:45,160 --> 00:25:48,150
But that shouldn't surprise you
at all, because by now,

456
00:25:48,150 --> 00:25:50,019
you should be coming to really
believe that there's no

457
00:25:50,019 --> 00:25:53,089
difference really between
procedures and data.

458
00:25:53,089 --> 00:25:55,549
In fact, in some sense, the
underlying streams are

459
00:25:55,549 --> 00:25:57,240
procedures sitting there,
although we don't think of

460
00:25:57,240 --> 00:25:58,210
them that way.

461
00:25:58,210 --> 00:26:00,910
So the fact that we have
recursive procedures, well,

462
00:26:00,910 --> 00:26:03,630
then it should be natural that
we have recursive data, too.

463
00:26:03,630 --> 00:26:07,840


464
00:26:07,839 --> 00:26:09,720
OK, well, this is
all pretty neat.

465
00:26:09,720 --> 00:26:13,120
Unfortunately, there are
problems that streams aren't

466
00:26:13,119 --> 00:26:14,989
going to solve.

467
00:26:14,990 --> 00:26:17,579
Let me show you one of them.

468
00:26:17,579 --> 00:26:21,189
See, in the same way, let's
imagine that we're building an

469
00:26:21,190 --> 00:26:26,809
analog computer to solve some
differential equation like,

470
00:26:26,809 --> 00:26:33,720
say, we want to solve the
equation y prime dy dt is y

471
00:26:33,720 --> 00:26:36,390
squared, and I'm going to give
you some initial value.

472
00:26:36,390 --> 00:26:38,030
I'll tell you y of 0 equals 1.

473
00:26:38,029 --> 00:26:41,059


474
00:26:41,059 --> 00:26:43,690
Let's say dt is equal
to something.

475
00:26:43,690 --> 00:26:46,769


476
00:26:46,769 --> 00:26:49,529
Now, in the old days, people
built analog computers to

477
00:26:49,529 --> 00:26:51,039
solve these kinds of things.

478
00:26:51,039 --> 00:26:53,019
And the way you do that
is really simple.

479
00:26:53,019 --> 00:27:01,029
You get yourself an integrator,
like that one, an

480
00:27:01,029 --> 00:27:03,055
integrator box.

481
00:27:03,055 --> 00:27:08,529
And we put in the initial
value y of 0 is 1.

482
00:27:08,529 --> 00:27:10,899
And now if we feed something
in and get something out,

483
00:27:10,900 --> 00:27:13,890
we'll say, gee, what we're
getting out is the answer.

484
00:27:13,890 --> 00:27:18,420
And what we're going to feed in
is the derivative, and the

485
00:27:18,420 --> 00:27:21,490
derivative is supposed to be
the square of the answer.

486
00:27:21,490 --> 00:27:31,069
So if we take these values and
map using square, and if I

487
00:27:31,069 --> 00:27:38,750
feed this around, that's how I
build a block diagram for an

488
00:27:38,750 --> 00:27:42,910
analog computer that solves this
differential equation.

489
00:27:42,910 --> 00:27:45,630
Now, what we'd like to do is
write a stream program that

490
00:27:45,630 --> 00:27:47,230
looks exactly like that.

491
00:27:47,230 --> 00:27:49,390
And what do I mean exactly
like that?

492
00:27:49,390 --> 00:28:08,100
Well, I'd say define y to be the
integral of dy starting at

493
00:28:08,099 --> 00:28:13,789
1 with 0.001 as a time step.

494
00:28:13,789 --> 00:28:16,805
And I'd like to say
that says this.

495
00:28:16,805 --> 00:28:19,634
And then I'd like to say, well,
dy is gotten by mapping

496
00:28:19,634 --> 00:28:20,849
the square along y.

497
00:28:20,849 --> 00:28:33,509
So define dy to be map
square along y.

498
00:28:33,509 --> 00:28:36,269
So there's a stream description
of this analog

499
00:28:36,269 --> 00:28:41,410
computer, and unfortunately,
it doesn't work.

500
00:28:41,410 --> 00:28:43,715
And you can see why it doesn't
work because when I come in

501
00:28:43,714 --> 00:28:49,549
and say define y to be the
integral of dy, it says, oh,

502
00:28:49,549 --> 00:28:51,190
the integral of y-- huh?

503
00:28:51,190 --> 00:28:53,710
Oh, that's undefined.

504
00:28:53,710 --> 00:28:56,860
So I can't write this definition
before I've

505
00:28:56,859 --> 00:28:58,769
written this one.

506
00:28:58,769 --> 00:29:00,599
On the other hand, if I try and
write this one first, it

507
00:29:00,599 --> 00:29:03,579
says, oh, I define y to be the
map of square along y?

508
00:29:03,579 --> 00:29:05,769
Oh, that's not defined yet.

509
00:29:05,769 --> 00:29:07,730
So I can't write this one first,
and I can't write that

510
00:29:07,730 --> 00:29:11,579
one first. So I can't quite
play this game.

511
00:29:11,579 --> 00:29:17,559


512
00:29:17,559 --> 00:29:20,460
Well, is there a way out?

513
00:29:20,460 --> 00:29:22,200
See, we can do that with ones.

514
00:29:22,200 --> 00:29:27,819
See, over here, we did this
thing ones, and we were able

515
00:29:27,819 --> 00:29:30,990
to define ones in terms of ones
because of this delay

516
00:29:30,990 --> 00:29:34,769
that was built inside because
cons-stream had a delay.

517
00:29:34,769 --> 00:29:36,069
Now, why's it sensible?

518
00:29:36,069 --> 00:29:37,970
Why's it sensible for
cons-stream to be built with

519
00:29:37,970 --> 00:29:40,730
this delay?

520
00:29:40,730 --> 00:29:43,940
The reason is that cons-stream
can do a useful thing without

521
00:29:43,940 --> 00:29:45,950
looking at its tail.

522
00:29:45,950 --> 00:29:49,049
See, if I say this is
cons-stream of 1 onto

523
00:29:49,049 --> 00:29:52,339
something without knowing
anything about something, I

524
00:29:52,339 --> 00:29:54,869
know that the stream
starts off with 1.

525
00:29:54,869 --> 00:29:56,659
That's why it was sensible
to build something like

526
00:29:56,660 --> 00:29:57,910
cons-stream.

527
00:29:57,910 --> 00:29:59,960


528
00:29:59,960 --> 00:30:02,610
So we put a delay in there,
and that allows us to have

529
00:30:02,609 --> 00:30:06,319
this sort of self-referential
definition.

530
00:30:06,319 --> 00:30:08,189
Well, integral is a little
bit the same way.

531
00:30:08,190 --> 00:30:14,620
See, notice for an
integral, I can--

532
00:30:14,619 --> 00:30:17,579
let's go back and look at
integral for a second.

533
00:30:17,579 --> 00:30:24,009
See, notice integral, it makes
sense to say what's the first

534
00:30:24,009 --> 00:30:27,390
thing in the integral without
knowing the stream that you're

535
00:30:27,390 --> 00:30:28,970
integrating.

536
00:30:28,970 --> 00:30:30,769
Because the first thing in the
integral is always going to be

537
00:30:30,769 --> 00:30:33,139
the initial value that
you're handed.

538
00:30:33,140 --> 00:30:37,090
So integral could be a procedure
like cons-stream.

539
00:30:37,089 --> 00:30:39,829
You could define it, and then
even before it knows what it's

540
00:30:39,829 --> 00:30:44,359
supposed to be integrating, it
knows enough to say what its

541
00:30:44,359 --> 00:30:46,709
initial value is.

542
00:30:46,710 --> 00:30:49,150
So we can make a smarter
integral, which is aha, you're

543
00:30:49,150 --> 00:30:51,390
going to give me a stream to
integrate and an initial

544
00:30:51,390 --> 00:30:54,140
value, but I really don't have
to look at that stream that

545
00:30:54,140 --> 00:30:56,430
I'm supposed to integrate until
you ask me to work down

546
00:30:56,430 --> 00:30:58,430
the stream.

547
00:30:58,430 --> 00:31:00,870
In other words, integral can be
like cons-stream, and you

548
00:31:00,869 --> 00:31:02,689
can expect that there's
going to be a

549
00:31:02,690 --> 00:31:03,710
delay around its integrand.

550
00:31:03,710 --> 00:31:05,610
And we can write that.

551
00:31:05,609 --> 00:31:07,649
Here's a procedure
that does that.

552
00:31:07,650 --> 00:31:09,810
Another version of integral,
and this is almost like the

553
00:31:09,809 --> 00:31:13,960
previous one, except the stream
it's going to get in is

554
00:31:13,960 --> 00:31:17,110
going to expect to be
a delayed object.

555
00:31:17,109 --> 00:31:18,849
And how does this
integral work?

556
00:31:18,849 --> 00:31:21,339
Well, the little thing it's
going to define inside of

557
00:31:21,339 --> 00:31:25,349
itself says on the cons-stream,
the initial value

558
00:31:25,349 --> 00:31:29,750
is the initial value, but only
inside of that cons-stream,

559
00:31:29,750 --> 00:31:32,299
and remember, there's going to
be a hidden delay inside here.

560
00:31:32,299 --> 00:31:34,950


561
00:31:34,950 --> 00:31:38,259
Only inside of that cons-stream
will I start

562
00:31:38,259 --> 00:31:43,180
looking at what the actual
delayed object is.

563
00:31:43,180 --> 00:31:45,970
So my answer is the first
thing's the initial value.

564
00:31:45,970 --> 00:31:50,279
If anybody now asks me for my
tail, at that point, I'm going

565
00:31:50,279 --> 00:31:52,680
to force that delayed object--

566
00:31:52,680 --> 00:31:54,500
and I'll call that s--

567
00:31:54,500 --> 00:31:58,299
and I do the add streams. So
this is an integral which is

568
00:31:58,299 --> 00:31:59,259
sort of like cons-stream.

569
00:31:59,259 --> 00:32:04,119
It's not going to actually try
and see what you handed it as

570
00:32:04,119 --> 00:32:06,079
the thing to integrate
until you look

571
00:32:06,079 --> 00:32:07,329
past the first element.

572
00:32:07,329 --> 00:32:10,119


573
00:32:10,119 --> 00:32:13,899
And if we do that and we can
make this work, all we have to

574
00:32:13,900 --> 00:32:24,120
do here is say define y to the
integral of delay of y, of

575
00:32:24,119 --> 00:32:27,089
delay of dy.

576
00:32:27,089 --> 00:32:33,379
So y is going to be the integral
of delay of dy

577
00:32:33,380 --> 00:32:35,280
starting at 1, and now
this will work.

578
00:32:35,279 --> 00:32:38,190
Because I type in the definition
of y, and that

579
00:32:38,190 --> 00:32:40,840
says, oh, I'm supposed to use
the integral of something I

580
00:32:40,839 --> 00:32:44,599
don't care about right now
because it's a delay.

581
00:32:44,599 --> 00:32:46,319
And these things, now
you define dy.

582
00:32:46,319 --> 00:32:47,549
Now, y is defined.

583
00:32:47,549 --> 00:32:51,700
So when I define dy, it can
see that definition for y.

584
00:32:51,700 --> 00:32:52,840
Everything is now started up.

585
00:32:52,839 --> 00:32:54,919
Both streams have their
first element.

586
00:32:54,920 --> 00:32:57,029
And then when I start mapping
down, looking at successive

587
00:32:57,029 --> 00:33:00,589
elements, both y and
dy are defined.

588
00:33:00,589 --> 00:33:02,819
So there's a little game you
can play that goes a little

589
00:33:02,819 --> 00:33:06,700
bit beyond just using the delay
that's hidden inside

590
00:33:06,700 --> 00:33:08,660
streams. Questions?

591
00:33:08,660 --> 00:33:13,178


592
00:33:13,178 --> 00:33:14,428
OK, let's take a break.

593
00:33:14,428 --> 00:34:07,300


594
00:34:07,299 --> 00:34:11,739
Well, just before the break,
I'm not sure if you noticed

595
00:34:11,739 --> 00:34:14,320
it, but something nasty
started to happen.

596
00:34:14,320 --> 00:34:21,039
We've been going along with the
streams and divorcing time

597
00:34:21,039 --> 00:34:24,579
in the programs from time in
the computers, and all that

598
00:34:24,579 --> 00:34:27,840
divorcing got hidden inside the
streams. And then at the

599
00:34:27,840 --> 00:34:30,429
very end, we saw that sometimes
in order to really

600
00:34:30,429 --> 00:34:32,579
take advantage of this
method, you have to

601
00:34:32,579 --> 00:34:34,389
pull out other delays.

602
00:34:34,389 --> 00:34:36,480
You have to write some explicit
delays that are not

603
00:34:36,480 --> 00:34:39,030
hidden inside that
cons-stream.

604
00:34:39,030 --> 00:34:41,400
And I did a very simple example
with differential

605
00:34:41,400 --> 00:34:44,150
equations, but if you have some
very complicated system

606
00:34:44,150 --> 00:34:47,309
with all kinds of self-loops,
it becomes very, very

607
00:34:47,309 --> 00:34:49,929
difficult to see where you
need those delays.

608
00:34:49,929 --> 00:34:52,389
And if you leave them out by
mistake, it becomes very, very

609
00:34:52,389 --> 00:34:55,550
difficult to see why the thing
maybe isn't working.

610
00:34:55,550 --> 00:35:00,330
So that's kind of mess, that
by getting this power and

611
00:35:00,329 --> 00:35:03,029
allowing us to use delay,
we end up with some very

612
00:35:03,030 --> 00:35:05,080
complicated programming
sometimes, because it can't

613
00:35:05,079 --> 00:35:08,690
all be hidden inside
the streams.

614
00:35:08,690 --> 00:35:11,036
Well, is there a way
out of that?

615
00:35:11,036 --> 00:35:13,480
Yeah, there is a way
out of that.

616
00:35:13,480 --> 00:35:17,230
We could change the language so
that all procedures acted

617
00:35:17,230 --> 00:35:22,320
like cons-stream, so that every
procedure automatically

618
00:35:22,320 --> 00:35:25,450
has an implicit delay around
its arguments.

619
00:35:25,449 --> 00:35:27,519
And what would that mean?

620
00:35:27,519 --> 00:35:30,759
That would mean when you call
a procedure, the arguments

621
00:35:30,760 --> 00:35:32,210
wouldn't get evaluated.

622
00:35:32,210 --> 00:35:34,820
Instead, they'd only be
evaluated when you need them,

623
00:35:34,820 --> 00:35:36,830
so they might be passed off to
some other procedure, which

624
00:35:36,829 --> 00:35:39,259
wouldn't evaluate them either.

625
00:35:39,260 --> 00:35:42,150
So all these procedures would
be passing promises around.

626
00:35:42,150 --> 00:35:44,970
And then finally maybe when you
finally got down to having

627
00:35:44,969 --> 00:35:48,039
to look at the value of
something that was handed to a

628
00:35:48,039 --> 00:35:50,719
primitive operator would you
actually start calling in all

629
00:35:50,719 --> 00:35:52,379
those promises.

630
00:35:52,380 --> 00:35:54,400
If we did that, since everything
would have a

631
00:35:54,400 --> 00:35:58,220
uniform delay, then you wouldn't
have to write any

632
00:35:58,219 --> 00:36:00,369
explicit delays, because it
would be automatically built

633
00:36:00,369 --> 00:36:02,920
into the way the
language works.

634
00:36:02,920 --> 00:36:05,869
Or another way to say that,
technically what I'm

635
00:36:05,869 --> 00:36:09,130
describing is what's called--

636
00:36:09,130 --> 00:36:12,720
if we did that, our language
would be so-called

637
00:36:12,719 --> 00:36:22,269
normal-order evaluation language
versus what we've

638
00:36:22,269 --> 00:36:24,259
actually been working
with, which is

639
00:36:24,260 --> 00:36:25,510
called applicative order--

640
00:36:25,510 --> 00:36:31,240


641
00:36:31,239 --> 00:36:34,559
versus applicative-order
evaluation.

642
00:36:34,559 --> 00:36:36,835
And remember the substitution
model for applicative order.

643
00:36:36,835 --> 00:36:40,690
It says when you go and evaluate
a combination, you

644
00:36:40,690 --> 00:36:43,590
find the values of
all the pieces.

645
00:36:43,590 --> 00:36:46,430
You evaluate the arguments and
then you substitute them in

646
00:36:46,429 --> 00:36:47,599
the body of the procedure.

647
00:36:47,599 --> 00:36:49,889
Normal order says no,
don't do that.

648
00:36:49,889 --> 00:36:53,980
What you do is effectively
substitute in the body of the

649
00:36:53,980 --> 00:36:56,639
procedure, but instead of
evaluating the arguments, you

650
00:36:56,639 --> 00:36:58,639
just put a promise to
compute them there.

651
00:36:58,639 --> 00:37:01,029
Or another way to say that is
you take the expressions for

652
00:37:01,030 --> 00:37:03,370
the arguments, if you like,
and substitute them in the

653
00:37:03,369 --> 00:37:06,319
body of the procedure and go on,
and never really simplify

654
00:37:06,320 --> 00:37:09,340
anything until you get down
to a primitive operator.

655
00:37:09,340 --> 00:37:11,840
So that would be a normal-order
language.

656
00:37:11,840 --> 00:37:13,490
Well, why don't we do that?

657
00:37:13,489 --> 00:37:16,549
Because if we did, we'd get all
the advantages of delayed

658
00:37:16,550 --> 00:37:18,940
evaluation with none
of the mess.

659
00:37:18,940 --> 00:37:22,250
In fact, if we did that and
cons was just a delayed

660
00:37:22,250 --> 00:37:24,710
procedure, that would make cons
the same as cons-stream.

661
00:37:24,710 --> 00:37:27,240
We wouldn't need streams of
all because lists would

662
00:37:27,239 --> 00:37:30,674
automatically be streams. That's
how lists would behave,

663
00:37:30,675 --> 00:37:32,350
and data structures would
behave that way.

664
00:37:32,349 --> 00:37:35,269
Everything would behave
that way, right?

665
00:37:35,269 --> 00:37:38,509
You'd never really do any
computation until you actually

666
00:37:38,510 --> 00:37:41,020
needed the answer.

667
00:37:41,019 --> 00:37:42,780
You wouldn't have to worry
about all these explicit

668
00:37:42,780 --> 00:37:44,790
annoying delays.

669
00:37:44,789 --> 00:37:47,159
Well, why don't we do that?

670
00:37:47,159 --> 00:37:49,230
First of all, I should say
people do do that.

671
00:37:49,230 --> 00:37:51,849
There's some very beautiful
languages.

672
00:37:51,849 --> 00:37:56,170
One of the very nicest is a
language called Miranda, which

673
00:37:56,170 --> 00:38:00,710
is developed by David Turner
at the University of Kent.

674
00:38:00,710 --> 00:38:01,929
And that's how this
language works.

675
00:38:01,929 --> 00:38:06,429
It's a normal-order language and
its data structures, which

676
00:38:06,429 --> 00:38:09,250
look like lists, are actually
streams. And you write

677
00:38:09,250 --> 00:38:11,710
ordinary procedures in Miranda,
and they do these

678
00:38:11,710 --> 00:38:13,949
prime things and eight
queens things, just

679
00:38:13,949 --> 00:38:14,969
without anything special.

680
00:38:14,969 --> 00:38:17,789
It's all built in there.

681
00:38:17,789 --> 00:38:19,039
But there's a price.

682
00:38:19,039 --> 00:38:21,190


683
00:38:21,190 --> 00:38:23,170
Remember how we got here.

684
00:38:23,170 --> 00:38:26,380
We're decoupling time
in the programs

685
00:38:26,380 --> 00:38:27,480
from time in the machines.

686
00:38:27,480 --> 00:38:30,400
And if we put delay, that sort
of decouples it everywhere,

687
00:38:30,400 --> 00:38:33,139
not just in streams. Remember
what we're trying to do.

688
00:38:33,139 --> 00:38:36,900
We're trying to think about
programming as a way to

689
00:38:36,900 --> 00:38:39,300
specify processes.

690
00:38:39,300 --> 00:38:41,690
And if we give up too much time,
our language becomes

691
00:38:41,690 --> 00:38:47,030
more elegant, but it becomes a
little bit less expressive.

692
00:38:47,030 --> 00:38:51,480
There are certain distinctions
that we can't draw.

693
00:38:51,480 --> 00:38:53,980
One of them, for instance,
is iteration.

694
00:38:53,980 --> 00:38:58,630
Remember this old procedure,
iterative factorial, that we

695
00:38:58,630 --> 00:39:01,230
looked at quite a
long time ago.

696
00:39:01,230 --> 00:39:03,409
Iterative factorial had a thing,
and it said there was

697
00:39:03,409 --> 00:39:06,289
an internal procedure, and there
was a state which was a

698
00:39:06,289 --> 00:39:09,969
product and a counter,
and we iterate that

699
00:39:09,969 --> 00:39:12,119
going around the loop.

700
00:39:12,119 --> 00:39:13,880
And we said that was an
iterative procedure because it

701
00:39:13,880 --> 00:39:15,730
didn't build up state.

702
00:39:15,730 --> 00:39:19,630
And the reason it didn't build
up state is because this iter

703
00:39:19,630 --> 00:39:23,900
that's called is just passing
these things around to itself.

704
00:39:23,900 --> 00:39:26,130
Or in the substitution model,
you could see in the

705
00:39:26,130 --> 00:39:29,480
substitution model that Jerry
did, that in an iterative

706
00:39:29,480 --> 00:39:31,659
procedure, that state doesn't
have to grow.

707
00:39:31,659 --> 00:39:33,029
And in fact, we said
it doesn't,

708
00:39:33,030 --> 00:39:34,840
so this is an iteration.

709
00:39:34,840 --> 00:39:37,890
But now think about this exact
same text if we had a

710
00:39:37,889 --> 00:39:41,150
normal-order language.

711
00:39:41,150 --> 00:39:44,230
What would happen is this
would no longer be an

712
00:39:44,230 --> 00:39:45,650
iterative procedure?

713
00:39:45,650 --> 00:39:47,789
And if you really think about
the details of the

714
00:39:47,789 --> 00:39:51,460
substitution model, which I'm
not going to do here, this

715
00:39:51,460 --> 00:39:52,329
expression would grow.

716
00:39:52,329 --> 00:39:53,279
Why would it grow?

717
00:39:53,280 --> 00:39:56,740
It's because when iter calls
itself, it calls itself with

718
00:39:56,739 --> 00:39:58,079
this product.

719
00:39:58,079 --> 00:40:00,210
If it's a normal-order language,
that multiplication

720
00:40:00,210 --> 00:40:02,510
is not going to get done.

721
00:40:02,510 --> 00:40:04,790
That's going to say I'm to call
myself with a promise to

722
00:40:04,789 --> 00:40:06,670
compute this product.

723
00:40:06,670 --> 00:40:09,760
And now iter goes
around again.

724
00:40:09,760 --> 00:40:13,680
And I'm going to call myself
with a promise to compute this

725
00:40:13,679 --> 00:40:18,399
product where now one of the
one factors is a promise.

726
00:40:18,400 --> 00:40:19,430
And I call myself again.

727
00:40:19,429 --> 00:40:22,579
And if you write out the
substitution model for that

728
00:40:22,579 --> 00:40:26,429
iterative process, you'll see
exactly the same growth in

729
00:40:26,429 --> 00:40:29,079
state, all those promises that
are getting remembered that

730
00:40:29,079 --> 00:40:31,789
have to get called in
at the very end.

731
00:40:31,789 --> 00:40:35,690
So one of the disadvantages
is that you can't

732
00:40:35,690 --> 00:40:36,980
really express iteration.

733
00:40:36,980 --> 00:40:39,610
Maybe that's a little
theoretical reason why not,

734
00:40:39,610 --> 00:40:43,510
but in fact, people who are
trying to write real operating

735
00:40:43,510 --> 00:40:46,750
systems in these languages are
running into exactly these

736
00:40:46,750 --> 00:40:51,650
types of problems. Like it's
perfectly possible to

737
00:40:51,650 --> 00:40:54,610
implement a text editor in
languages like these.

738
00:40:54,610 --> 00:40:58,829
But after you work a while, you
suddenly have 3 megabytes

739
00:40:58,829 --> 00:41:01,239
of stuff, which is--

740
00:41:01,239 --> 00:41:04,469
I guess they call them the
dragging tail problem of

741
00:41:04,469 --> 00:41:07,319
people who are looking at these,
of promises that sort

742
00:41:07,320 --> 00:41:09,260
of haven't been called in
because you couldn't quite

743
00:41:09,260 --> 00:41:10,230
express an iteration.

744
00:41:10,230 --> 00:41:14,329
And one of the research
questions in these kinds of

745
00:41:14,329 --> 00:41:17,929
languages are figuring out the
right compiler technology to

746
00:41:17,929 --> 00:41:20,109
get rid of the so-called
dragging tails.

747
00:41:20,110 --> 00:41:23,940
It's not simple.

748
00:41:23,940 --> 00:41:28,519
But there's another kind of more
striking issue about why

749
00:41:28,519 --> 00:41:30,099
you just don't go ahead
and make your

750
00:41:30,099 --> 00:41:32,056
language normal order.

751
00:41:32,056 --> 00:41:37,440
And the reason is that
normal-order evaluation and

752
00:41:37,440 --> 00:41:42,000
side effects just don't mix.

753
00:41:42,000 --> 00:41:45,349
They just don't go together
very well.

754
00:41:45,349 --> 00:41:48,360
Somehow, you can't--

755
00:41:48,360 --> 00:41:51,500
it's sort of you can't
simultaneously go around

756
00:41:51,500 --> 00:41:55,989
trying to model objects with
local state and change and at

757
00:41:55,989 --> 00:41:58,519
the same time do these
normal-order tricks of

758
00:41:58,519 --> 00:42:00,400
de-coupling time.

759
00:42:00,400 --> 00:42:02,010
Let me just show you
a really simple

760
00:42:02,010 --> 00:42:03,790
example, very, very simple.

761
00:42:03,789 --> 00:42:07,519
Suppose we had a normal-order
language.

762
00:42:07,519 --> 00:42:09,550
And I'm going to start
out in this language.

763
00:42:09,550 --> 00:42:10,519
This is now normal order.

764
00:42:10,519 --> 00:42:13,570
I'm going to define x to be 0.

765
00:42:13,570 --> 00:42:15,750
It's just some variable
I'll initialize.

766
00:42:15,750 --> 00:42:18,610
And now I'm going to define this
little funny function,

767
00:42:18,610 --> 00:42:22,640
which is an identity function.

768
00:42:22,639 --> 00:42:25,519
And what it does, it keeps track
of the last time you

769
00:42:25,519 --> 00:42:26,769
called it using x.

770
00:42:26,769 --> 00:42:31,619


771
00:42:31,619 --> 00:42:34,389
So the identity of n just
returns n, but it

772
00:42:34,389 --> 00:42:36,759
sets x to be n.

773
00:42:36,760 --> 00:42:40,050
And now I'll define a little
increment function, which is a

774
00:42:40,050 --> 00:42:42,580
very little, simple scenario.

775
00:42:42,579 --> 00:42:44,779
Now, imagine I'm interacting
with this in the normal-order

776
00:42:44,780 --> 00:42:47,230
language, and I type
the following.

777
00:42:47,230 --> 00:42:52,940
I say define y to be increment
the identity function of 3, so

778
00:42:52,940 --> 00:42:54,190
y is going to be 4.

779
00:42:54,190 --> 00:42:57,409


780
00:42:57,409 --> 00:42:59,519
Now, I say what's x?

781
00:42:59,519 --> 00:43:02,719
Well, x should have been the
value that was remembered last

782
00:43:02,719 --> 00:43:04,709
when I called the identity
function.

783
00:43:04,710 --> 00:43:06,500
So you'd expect to say,
well, x is 3 at this

784
00:43:06,500 --> 00:43:08,530
point, but it's not.

785
00:43:08,530 --> 00:43:13,460
Because when I defined y here,
what I really defined y to be

786
00:43:13,460 --> 00:43:17,000
increment of a promise
to do this thing.

787
00:43:17,000 --> 00:43:19,050
So I didn't look at y,
so that identity

788
00:43:19,050 --> 00:43:21,560
function didn't get run.

789
00:43:21,559 --> 00:43:24,070
So if I type in this definition
and look at x, I'm

790
00:43:24,070 --> 00:43:25,320
going to get 0.

791
00:43:25,320 --> 00:43:28,360


792
00:43:28,360 --> 00:43:33,120
Now, if I go look at y and say
what's y, say y is 4, looking

793
00:43:33,119 --> 00:43:36,179
at y, that very active looking
at y caused the identity

794
00:43:36,179 --> 00:43:38,341
function to be run.

795
00:43:38,342 --> 00:43:40,740
And now x will get
remembered as 3.

796
00:43:40,739 --> 00:43:42,019
So here x will be 0.

797
00:43:42,019 --> 00:43:43,280
Here, x will be 3.

798
00:43:43,280 --> 00:43:47,890
That's a tiny, little, simple
scenario, but you can see what

799
00:43:47,889 --> 00:43:52,639
kind of a mess that's going to
make for debugging interactive

800
00:43:52,639 --> 00:43:57,099
programs when you have
normal-order evaluation.

801
00:43:57,099 --> 00:43:59,690
It's very confusing.

802
00:43:59,690 --> 00:44:03,200
But it's very confusing for a
very deep reason, which is

803
00:44:03,199 --> 00:44:07,250
that the whole idea of putting
in delays is that

804
00:44:07,250 --> 00:44:09,780
you throw away time.

805
00:44:09,780 --> 00:44:11,750
That's why we can have these
infinite processes.

806
00:44:11,750 --> 00:44:13,869
Since we've thrown away time, we
don't have to wait for them

807
00:44:13,869 --> 00:44:17,789
to run, right?

808
00:44:17,789 --> 00:44:21,000
We decouple the order of events
in the computer from

809
00:44:21,000 --> 00:44:23,730
what we write in our programs.
But when we talk about state

810
00:44:23,730 --> 00:44:26,909
and set and change, that's
exactly what we do want

811
00:44:26,909 --> 00:44:28,759
control of.

812
00:44:28,760 --> 00:44:32,960
So it's almost as if there's
this fundamental contradiction

813
00:44:32,960 --> 00:44:34,570
in what you want.

814
00:44:34,570 --> 00:44:38,710
And that brings us back to these
sort of philosophical

815
00:44:38,710 --> 00:44:40,720
mutterings about what is it that
you're trying to model

816
00:44:40,719 --> 00:44:42,409
and how do you look
at the world.

817
00:44:42,409 --> 00:44:45,889
Or sometimes this is called
the debate over functional

818
00:44:45,889 --> 00:44:47,139
programming.

819
00:44:47,139 --> 00:44:53,569


820
00:44:53,570 --> 00:44:57,730
A so-called purely functional
language is one that just

821
00:44:57,730 --> 00:45:00,440
doesn't have any side effects.

822
00:45:00,440 --> 00:45:02,450
Since you have no side effects,
there's no assignment

823
00:45:02,449 --> 00:45:06,359
operator, so there are no
terrible consequences of it.

824
00:45:06,360 --> 00:45:07,930
You can use a substitution-like
thing.

825
00:45:07,929 --> 00:45:11,119
Programs really are like
mathematics and not like

826
00:45:11,119 --> 00:45:12,639
models in the real
world, not like

827
00:45:12,639 --> 00:45:15,049
objects in the real world.

828
00:45:15,050 --> 00:45:16,100
There are a lot of
wonderful things

829
00:45:16,099 --> 00:45:17,170
about functional languages.

830
00:45:17,170 --> 00:45:19,240
Since there's no time, you never
have any synchronization

831
00:45:19,239 --> 00:45:23,139
problems. And if you want to put
something into a parallel

832
00:45:23,139 --> 00:45:26,819
algorithm, you can run the
pieces of that parallel

833
00:45:26,820 --> 00:45:29,260
processing any way you want.

834
00:45:29,260 --> 00:45:31,235
There's just never any
synchronization to worry that,

835
00:45:31,235 --> 00:45:33,640
and it's a very congenial
environment for doing this.

836
00:45:33,639 --> 00:45:35,449
The price is you give
up assignment.

837
00:45:35,449 --> 00:45:39,059


838
00:45:39,059 --> 00:45:41,460
So an advocate of a functional
language would say, gee,

839
00:45:41,460 --> 00:45:44,519
that's just a tiny
price to pay.

840
00:45:44,519 --> 00:45:45,690
You probably shouldn't
use assignment

841
00:45:45,690 --> 00:45:46,510
most of the time anyway.

842
00:45:46,510 --> 00:45:49,360
And if you just give up
assignment, you can be in this

843
00:45:49,360 --> 00:45:54,190
much, much nicer world than
this place with objects.

844
00:45:54,190 --> 00:45:56,300
Well, what's the rejoinder
to that?

845
00:45:56,300 --> 00:46:00,300
Remember how we got
into this mess.

846
00:46:00,300 --> 00:46:04,440
We started trying to model
things that had local state.

847
00:46:04,440 --> 00:46:06,840
So remember Jerry's random
number generator.

848
00:46:06,840 --> 00:46:10,000
There was this random number
generator that had some little

849
00:46:10,000 --> 00:46:12,289
state in it to compute the next
random number and the

850
00:46:12,289 --> 00:46:14,079
next random number and the
next random number.

851
00:46:14,079 --> 00:46:17,829
And we wanted to hide that state
away from the Cesaro

852
00:46:17,829 --> 00:46:21,049
compute part process, and that's
why we needed set.

853
00:46:21,050 --> 00:46:24,070
We wanted to package that
stated modularly.

854
00:46:24,070 --> 00:46:26,920
Well, a functional programming
person would say, well, you're

855
00:46:26,920 --> 00:46:27,559
just all wet.

856
00:46:27,559 --> 00:46:28,809
I mean, you can write
a perfectly

857
00:46:28,809 --> 00:46:29,840
good modular program.

858
00:46:29,840 --> 00:46:33,250
It's just you're thinking
about modularity wrong.

859
00:46:33,250 --> 00:46:35,420
You're hung up in this next
random number and the next

860
00:46:35,420 --> 00:46:36,880
random number and the
next random number.

861
00:46:36,880 --> 00:46:39,880
Why don't you just say let's
write a program.

862
00:46:39,880 --> 00:46:42,990
Let's write an enumerator
which just generates an

863
00:46:42,989 --> 00:46:44,444
infinite stream of
random numbers.

864
00:46:44,445 --> 00:46:49,010


865
00:46:49,010 --> 00:46:52,970
We can sort of have that stream
all at once, and that's

866
00:46:52,969 --> 00:46:54,539
going to be our source
of random numbers.

867
00:46:54,539 --> 00:46:56,769
And then if you like, you can
put that through some sort of

868
00:46:56,769 --> 00:46:58,530
processor, which is--

869
00:46:58,530 --> 00:46:59,530
I don't know--

870
00:46:59,530 --> 00:47:06,880
a Cesaro test, and that
can do what it wants.

871
00:47:06,880 --> 00:47:16,320
And what would come out of there
would be a stream of

872
00:47:16,320 --> 00:47:28,140
successive approximations
to pi.

873
00:47:28,139 --> 00:47:31,599
So as we looked further down
this stream, we'd tug on this

874
00:47:31,599 --> 00:47:34,420
Cesaro thing, and it
would pull out more

875
00:47:34,420 --> 00:47:35,539
and more random numbers.

876
00:47:35,539 --> 00:47:37,199
And the further and further we
look down the stream, the

877
00:47:37,199 --> 00:47:39,719
better an approximation
we'd get to pi.

878
00:47:39,719 --> 00:47:41,849
And it would do exactly the same
as the other computation,

879
00:47:41,849 --> 00:47:43,889
except we're thinking about
the modularity different.

880
00:47:43,889 --> 00:47:46,359
We're saying imagine we had all
those infinite streams of

881
00:47:46,360 --> 00:47:49,400
random numbers all at once.

882
00:47:49,400 --> 00:47:53,860
You can see the details of this
procedure in the book.

883
00:47:53,860 --> 00:47:56,940
Similarly, there are other
things that we tend to get

884
00:47:56,940 --> 00:48:00,730
locked into on this one and that
one and the next one and

885
00:48:00,730 --> 00:48:03,280
the next one, which don't
have to be that way.

886
00:48:03,280 --> 00:48:07,930
Like you might think about like
a banking system, which

887
00:48:07,929 --> 00:48:08,899
is a very simple idea.

888
00:48:08,900 --> 00:48:10,960
Imagine we have a program
that sort of

889
00:48:10,960 --> 00:48:12,210
represents a bank account.

890
00:48:12,210 --> 00:48:18,809


891
00:48:18,809 --> 00:48:22,860
The bank account might
have in it--

892
00:48:22,860 --> 00:48:26,019
if we looked at this in a sort
of message-passing view of the

893
00:48:26,019 --> 00:48:29,070
world, we'd say a bank account
is an object that has some

894
00:48:29,070 --> 00:48:31,510
local state in there, which
is the balance, say.

895
00:48:31,510 --> 00:48:34,110


896
00:48:34,110 --> 00:48:37,640
And a user using this system
comes and sends a transaction

897
00:48:37,639 --> 00:48:41,230
request. So the user sends a
transaction request, like

898
00:48:41,230 --> 00:48:43,969
deposit some money, and the
bank account maybe--

899
00:48:43,969 --> 00:48:45,849
let's say the bank account
always responds with what the

900
00:48:45,849 --> 00:48:48,559
current balance is.

901
00:48:48,559 --> 00:48:50,360
The user says let's deposits
some money, and the bank

902
00:48:50,360 --> 00:48:54,349
account sends back a message
which is the balance.

903
00:48:54,349 --> 00:48:57,969
And the user says deposit some
more, and the bank account

904
00:48:57,969 --> 00:48:59,149
sends back a message.

905
00:48:59,150 --> 00:49:00,900
And just like the random number
generator, you'd say,

906
00:49:00,900 --> 00:49:03,200
gee, we would like to use set.

907
00:49:03,199 --> 00:49:06,149
We'd like to have balance be a
piece of local state inside

908
00:49:06,150 --> 00:49:08,110
this bank account because we
want to separate the state of

909
00:49:08,110 --> 00:49:09,570
the user from the state
of the bank account.

910
00:49:09,570 --> 00:49:13,280


911
00:49:13,280 --> 00:49:16,420
Well, that's the
message-processing view.

912
00:49:16,420 --> 00:49:20,030
There's a stream view with that
thing, which does the

913
00:49:20,030 --> 00:49:22,740
same thing without any
set or side effects.

914
00:49:22,739 --> 00:49:29,379
And the idea is again we don't
think about anything having

915
00:49:29,380 --> 00:49:31,180
local state.

916
00:49:31,179 --> 00:49:33,639
We think about the bank account
as something that's

917
00:49:33,639 --> 00:49:38,639
going to process a stream
of transaction requests.

918
00:49:38,639 --> 00:49:40,670
So think about this bank account
not as something that

919
00:49:40,670 --> 00:49:44,510
goes message by message, but
something that takes in a

920
00:49:44,510 --> 00:49:46,610
stream of transaction
requests like maybe

921
00:49:46,610 --> 00:49:49,490
successive deposit announced.

922
00:49:49,489 --> 00:49:55,939
1, 2, 2, 4, those might be
successive amounts to deposit.

923
00:49:55,940 --> 00:49:58,570
And then coming out of
it is the successive

924
00:49:58,570 --> 00:50:03,769
balances 1, 3, 5, 9.

925
00:50:03,769 --> 00:50:05,550
So we think of the bank account
not as something that

926
00:50:05,550 --> 00:50:09,970
has state, but something that
acts sort of on the infinite

927
00:50:09,969 --> 00:50:10,819
stream of requests.

928
00:50:10,820 --> 00:50:12,370
But remember, we've
thrown away time.

929
00:50:12,369 --> 00:50:17,949
So what we can do is if the
user's here, we can have this

930
00:50:17,949 --> 00:50:21,529
infinite stream of requests
being generated one at a time

931
00:50:21,530 --> 00:50:27,000
coming from the user and this
transaction stream coming back

932
00:50:27,000 --> 00:50:30,010
on a printer being printed
one at a time.

933
00:50:30,010 --> 00:50:33,850
And if we drew a little line
here, right there to the user,

934
00:50:33,849 --> 00:50:36,909
the user couldn't tell
that this system

935
00:50:36,909 --> 00:50:39,559
doesn't have state.

936
00:50:39,559 --> 00:50:41,409
It looks just like the
other one, but

937
00:50:41,409 --> 00:50:42,659
there's no state in there.

938
00:50:42,659 --> 00:50:45,119


939
00:50:45,119 --> 00:50:48,509
And by the way, just to show
you, here's an actual

940
00:50:48,510 --> 00:50:52,240
implementation of this-- we'll
call it make deposit account

941
00:50:52,239 --> 00:50:53,834
because you can only deposit.

942
00:50:53,835 --> 00:50:57,429
It takes an initial balance and
then a stream of deposits

943
00:50:57,429 --> 00:51:00,019
you might make.

944
00:51:00,019 --> 00:51:00,820
And what is it?

945
00:51:00,820 --> 00:51:04,580
Well, it's just cons-stream of
the balance onto make a new

946
00:51:04,579 --> 00:51:08,489
account stream whose initial
balance is the old balance

947
00:51:08,489 --> 00:51:14,019
plus the first thing in the
deposit stream and make

948
00:51:14,019 --> 00:51:16,469
deposit account works on the
rest of which is the tail of

949
00:51:16,469 --> 00:51:18,299
the deposit stream.

950
00:51:18,300 --> 00:51:24,650
So there's sort of a very
typical message-passing,

951
00:51:24,650 --> 00:51:26,700
object-oriented thing
that's done without

952
00:51:26,699 --> 00:51:28,789
side effects at all.

953
00:51:28,789 --> 00:51:32,250
There are very many things
you can do this way.

954
00:51:32,250 --> 00:51:36,400
Well, can you do everything
without assignment?

955
00:51:36,400 --> 00:51:40,050
Can everybody go over to purely
functional languages?

956
00:51:40,050 --> 00:51:44,450
Well, we don't know, but there
seem to be places where purely

957
00:51:44,449 --> 00:51:48,099
functional programming
breaks down.

958
00:51:48,099 --> 00:51:50,029
Where it starts hurting is
when you have things like

959
00:51:50,030 --> 00:51:53,519
this, but you also mix it up
with the other things that we

960
00:51:53,519 --> 00:51:56,300
had to worry that, which are
objects and sharing and two

961
00:51:56,300 --> 00:51:58,850
independent agents
being the same.

962
00:51:58,849 --> 00:52:00,849
So under a typical one, suppose
you want to extend

963
00:52:00,849 --> 00:52:02,960
this bank account.

964
00:52:02,960 --> 00:52:04,210
So here's a bank account.

965
00:52:04,210 --> 00:52:12,220


966
00:52:12,219 --> 00:52:15,409
Bank accounts take in a stream
of transaction requests and

967
00:52:15,409 --> 00:52:18,779
put out streams of, say,
balances or responses to that.

968
00:52:18,780 --> 00:52:21,019
But suppose you want to model
the fact that this is a joint

969
00:52:21,019 --> 00:52:26,090
bank account between two
independent people.

970
00:52:26,090 --> 00:52:31,890
So suppose there are two people,
say, Bill and Dave,

971
00:52:31,889 --> 00:52:33,139
who have a joint bank account.

972
00:52:33,139 --> 00:52:35,960


973
00:52:35,960 --> 00:52:36,849
How would you model this?

974
00:52:36,849 --> 00:52:40,460
Well, Bill puts out a stream of
transaction requests, and

975
00:52:40,460 --> 00:52:42,389
Dave puts out a stream of
transaction requests, and

976
00:52:42,389 --> 00:52:45,879
somehow, they have to merge
into this bank account.

977
00:52:45,880 --> 00:52:48,369
So what you might do is write
a little stream processing

978
00:52:48,369 --> 00:52:58,659
thing called merge, which sort
of takes these, merges them

979
00:52:58,659 --> 00:53:01,190
together, produces a single
stream for the bank account.

980
00:53:01,190 --> 00:53:03,610
Now they're both talking to
the same bank account.

981
00:53:03,610 --> 00:53:06,599
That's all great, but how
do you write merge?

982
00:53:06,599 --> 00:53:09,730
What's this procedure merge?

983
00:53:09,730 --> 00:53:12,760
You want to do something
that's reasonable.

984
00:53:12,760 --> 00:53:14,380
Your first guess might be
to say, well, we'll take

985
00:53:14,380 --> 00:53:20,050
alternate requests from Bill and
Dave. But what happens if

986
00:53:20,050 --> 00:53:21,950
suddenly in the middle of this
thing, Dave goes away on

987
00:53:21,949 --> 00:53:24,149
vacation for two years?

988
00:53:24,150 --> 00:53:27,690
Then Bill's sort of stuck.

989
00:53:27,690 --> 00:53:29,750
So what you want to do is--
well, it's hard to describe.

990
00:53:29,750 --> 00:53:33,380
What you want to do is what
people call fair merge.

991
00:53:33,380 --> 00:53:38,410


992
00:53:38,409 --> 00:53:41,849
The idea of fair merge is it
sort of should do them

993
00:53:41,849 --> 00:53:43,929
alternately, but if there's
nothing waiting here, it

994
00:53:43,929 --> 00:53:46,009
should take one twice.

995
00:53:46,010 --> 00:53:48,450
Notice I can't even say that
without talking about time.

996
00:53:48,449 --> 00:53:51,299


997
00:53:51,300 --> 00:53:55,970
So one of the other active
researcher areas in functional

998
00:53:55,969 --> 00:54:00,480
languages is inventing little
things like fair merge and

999
00:54:00,480 --> 00:54:04,650
maybe some others, which will
take the places where I used

1000
00:54:04,650 --> 00:54:08,050
to need side effects and objects
and sort of hide them

1001
00:54:08,050 --> 00:54:11,160
away in some very well-defined
modules of the system so that

1002
00:54:11,159 --> 00:54:14,429
all the problems of assignment
don't sort of leak out all

1003
00:54:14,429 --> 00:54:16,759
over the system but are captured
in some fairly

1004
00:54:16,760 --> 00:54:18,010
well-understood things.

1005
00:54:18,010 --> 00:54:20,780


1006
00:54:20,780 --> 00:54:23,410
More generally, I think what
you're seeing is that we're

1007
00:54:23,409 --> 00:54:25,960
running across what I think
is a very basic problem in

1008
00:54:25,960 --> 00:54:29,449
computer science, which is how
to define languages that

1009
00:54:29,449 --> 00:54:36,239
somehow can talk about delayed
evaluation, but also be able

1010
00:54:36,239 --> 00:54:37,279
to reflect this view
that there are

1011
00:54:37,280 --> 00:54:38,360
objects in the world.

1012
00:54:38,360 --> 00:54:41,230
How do we somehow get both?

1013
00:54:41,230 --> 00:54:43,039
And I think that's a
very hard problem.

1014
00:54:43,039 --> 00:54:46,750
And it may be that it's a very
hard problem that has almost

1015
00:54:46,750 --> 00:54:49,260
nothing to do with computer
science, that it really is a

1016
00:54:49,260 --> 00:54:51,950
problem having to do with two
very incompatible ways of

1017
00:54:51,949 --> 00:54:53,839
looking at the world.

1018
00:54:53,840 --> 00:54:55,090
OK, questions?

1019
00:54:55,090 --> 00:55:17,556


1020
00:55:17,556 --> 00:55:20,610
AUDIENCE: You mentioned
earlier that once you

1021
00:55:20,610 --> 00:55:23,930
introduce assignment, the
general rule for using the

1022
00:55:23,929 --> 00:55:25,889
substitution model
is you can't.

1023
00:55:25,889 --> 00:55:27,569
Unless you're very careful,
you can't.

1024
00:55:27,570 --> 00:55:28,260
PROFESSOR: Right.

1025
00:55:28,260 --> 00:55:32,550
AUDIENCE: Is there a set of
techniques or a set of

1026
00:55:32,550 --> 00:55:37,030
guidelines for localizing the
effects of assignment so that

1027
00:55:37,030 --> 00:55:40,300
the very careful becomes
defined?

1028
00:55:40,300 --> 00:55:42,890
PROFESSOR: I don't know.

1029
00:55:42,889 --> 00:55:45,429
Let me think.

1030
00:55:45,429 --> 00:55:50,149
Well, certainly, there was an
assignment inside memo proc,

1031
00:55:50,150 --> 00:55:51,480
but that was sort
of hidden away.

1032
00:55:51,480 --> 00:55:53,480
It ended up not making
any difference.

1033
00:55:53,480 --> 00:55:57,385
Part of the reason for that is
once this thing triggered that

1034
00:55:57,385 --> 00:55:58,990
it had run and gotten
an answer, that

1035
00:55:58,989 --> 00:56:00,389
answer will never change.

1036
00:56:00,389 --> 00:56:02,079
So that was sort of a
one-time assignment.

1037
00:56:02,079 --> 00:56:05,019
So one very general thing you
can do is if you only do

1038
00:56:05,019 --> 00:56:08,750
what's called a one-time
assignment and never change

1039
00:56:08,750 --> 00:56:11,250
anything, then you
can do better.

1040
00:56:11,250 --> 00:56:17,155
One of the problems in this
merge thing, people have--

1041
00:56:17,155 --> 00:56:18,489
let me see if this is right.

1042
00:56:18,489 --> 00:56:22,909
I think it's true that with
fair merge, with just fair

1043
00:56:22,909 --> 00:56:27,059
merge, you can begin effectively
simulating

1044
00:56:27,059 --> 00:56:30,820
assignment in the rest
of the language.

1045
00:56:30,820 --> 00:56:33,630
It seems like anything you
do to go outside--

1046
00:56:33,630 --> 00:56:36,440
I'm not quite sure that's true
for fair merge, but it's true

1047
00:56:36,440 --> 00:56:38,500
of a little bit more
general things that

1048
00:56:38,500 --> 00:56:39,519
people have been doing.

1049
00:56:39,519 --> 00:56:42,630
So it might be that any little
bit you put in, suddenly if

1050
00:56:42,630 --> 00:56:44,610
they allow you to build
arbitrary stuff, it's almost

1051
00:56:44,610 --> 00:56:47,970
as bad as having assignment
altogether.

1052
00:56:47,969 --> 00:56:51,589
But that's an area that people
are thinking about now.

1053
00:56:51,590 --> 00:56:57,010
AUDIENCE: I guess I don't see
the problem here with merge if

1054
00:56:57,010 --> 00:57:00,930
I call Bill, if Bill is a
procedure, then Bill is going

1055
00:57:00,929 --> 00:57:03,690
to increment the bank account
or build the list that 's

1056
00:57:03,690 --> 00:57:04,730
going to put in the
next element.

1057
00:57:04,730 --> 00:57:07,170
If I call Dave twice in a
row, that will do that.

1058
00:57:07,170 --> 00:57:09,349
I'm not sure where fair merge
has to be involved.

1059
00:57:09,349 --> 00:57:10,150
PROFESSOR: The problem
is imagine

1060
00:57:10,150 --> 00:57:11,200
these really as people.

1061
00:57:11,199 --> 00:57:13,489
See, here I have the user who's
interacting with this

1062
00:57:13,489 --> 00:57:14,849
bank account.

1063
00:57:14,849 --> 00:57:15,960
Put in a request,
get an answer.

1064
00:57:15,960 --> 00:57:17,070
Put in a request,
get an answer.

1065
00:57:17,070 --> 00:57:18,200
AUDIENCE: Right.

1066
00:57:18,199 --> 00:57:20,859
PROFESSOR: But if the only way
I can process request is to

1067
00:57:20,860 --> 00:57:22,289
alternate them from
two people--

1068
00:57:22,289 --> 00:57:24,219
AUDIENCE: Well, why would
you alternate them?

1069
00:57:24,219 --> 00:57:25,069
PROFESSOR: Why don't I?

1070
00:57:25,070 --> 00:57:26,140
AUDIENCE: Yes.

1071
00:57:26,139 --> 00:57:26,579
Why do you?

1072
00:57:26,579 --> 00:57:27,639
PROFESSOR: Think of them
as real people, right?

1073
00:57:27,639 --> 00:57:29,279
This guy might go
away for a year.

1074
00:57:29,280 --> 00:57:32,700
And you're sitting here at the
bank account window, and you

1075
00:57:32,699 --> 00:57:34,039
can't put in two requests
because it's

1076
00:57:34,039 --> 00:57:35,480
waiting for this guy.

1077
00:57:35,480 --> 00:57:37,380
AUDIENCE: Why does it have
to be waiting for one?

1078
00:57:37,380 --> 00:57:39,110
PROFESSOR: Because it's trying
to compute a function.

1079
00:57:39,110 --> 00:57:41,720
I have to define a function.

1080
00:57:41,719 --> 00:57:44,209
Another way to say that is the
answer to what comes out of

1081
00:57:44,210 --> 00:57:51,690
this merge box is not a function
of what goes in.

1082
00:57:51,690 --> 00:57:53,490
Because, see, what would
the function be?

1083
00:57:53,489 --> 00:58:03,469
Suppose he puts in 1, 1, 1, 1,
and he puts in 2, 2, 2, 2.

1084
00:58:03,469 --> 00:58:05,909
What's the answer
supposed to be?

1085
00:58:05,909 --> 00:58:08,739
It's not good enough to say
it's 1, 2, 1, 2, 1, 2.

1086
00:58:08,739 --> 00:58:09,389
AUDIENCE: I understand.

1087
00:58:09,389 --> 00:58:11,559
But when Bill puts
in 1, 1 goes in.

1088
00:58:11,559 --> 00:58:13,949
When Dave puts in 2 twice,
2 goes in twice.

1089
00:58:13,949 --> 00:58:15,089
When Bill puts in--

1090
00:58:15,090 --> 00:58:15,450
PROFESSOR: Right.

1091
00:58:15,449 --> 00:58:17,139
AUDIENCE: Why can't
it be hooked to

1092
00:58:17,139 --> 00:58:18,679
the time of the input--

1093
00:58:18,679 --> 00:58:20,099
the actual procedural--

1094
00:58:20,099 --> 00:58:23,980
PROFESSOR: Because I
don't have time.

1095
00:58:23,980 --> 00:58:26,900
See, all I can say is I'm going
to define a function.

1096
00:58:26,900 --> 00:58:28,150
I don't have time.

1097
00:58:28,150 --> 00:58:32,070


1098
00:58:32,070 --> 00:58:34,690
There's no concept if it's going
to alternate, except if

1099
00:58:34,690 --> 00:58:38,420
nobody's there, it's going
to wait a while for him.

1100
00:58:38,420 --> 00:58:41,909
It's just going to say I have
the stream of requests, the

1101
00:58:41,909 --> 00:58:44,579
timeless infinite streams of
all the requests that Dave

1102
00:58:44,579 --> 00:58:47,809
would have made, right?

1103
00:58:47,809 --> 00:58:49,710
And the timeless infinite stream
of all the requests

1104
00:58:49,710 --> 00:58:51,690
Bill would have made, and I
want to operate on them.

1105
00:58:51,690 --> 00:58:53,510
See, that's how this bank
account is working.

1106
00:58:53,510 --> 00:58:56,710


1107
00:58:56,710 --> 00:58:59,119
And the problem is that these
poor people who are sitting at

1108
00:58:59,119 --> 00:59:02,179
the bank account windows
have the

1109
00:59:02,179 --> 00:59:05,339
misfortune to exist in time.

1110
00:59:05,340 --> 00:59:08,490
They don't see their infinite
stream of all the requests

1111
00:59:08,489 --> 00:59:10,069
they would have ever made.

1112
00:59:10,070 --> 00:59:11,550
They're waiting now, and
they want an answer.

1113
00:59:11,550 --> 00:59:14,289


1114
00:59:14,289 --> 00:59:16,340
So if you're sitting there--

1115
00:59:16,340 --> 00:59:20,360
if this is the screen operation
on some time-sharing

1116
00:59:20,360 --> 00:59:22,940
system and it's working
functionally, you want an

1117
00:59:22,940 --> 00:59:25,289
answer then when you
talk the character.

1118
00:59:25,289 --> 00:59:26,940
You don't want it to have to
wait for everybody in the

1119
00:59:26,940 --> 00:59:28,990
whole system to have typed one
character before it can get

1120
00:59:28,989 --> 00:59:30,909
around to service you.

1121
00:59:30,909 --> 00:59:33,889
So that's the problem.

1122
00:59:33,889 --> 00:59:36,849
I mean, the fact that people
live in time, apparently.

1123
00:59:36,849 --> 00:59:38,619
If they didn't, it wouldn't
be a problem.

1124
00:59:38,619 --> 00:59:49,099


1125
00:59:49,099 --> 00:59:52,239
AUDIENCE: I'm afraid I miss the
point of having no time in

1126
00:59:52,239 --> 00:59:54,739
this banking transaction.

1127
00:59:54,739 --> 00:59:56,879
Isn't time very important?

1128
00:59:56,880 --> 01:00:00,789
For instance, the sequence
of events.

1129
01:00:00,789 --> 01:00:07,150
If Dave take out $100,
then the timing

1130
01:00:07,150 --> 01:00:08,400
sequence should be important.

1131
01:00:08,400 --> 01:00:11,260
How do you treat transactions
as streams?

1132
01:00:11,260 --> 01:00:14,260
PROFESSOR: Well, that's
the thing I'm saying.

1133
01:00:14,260 --> 01:00:17,510
This is an example
where you can't.

1134
01:00:17,510 --> 01:00:18,610
You can't.

1135
01:00:18,610 --> 01:00:21,410
The point is what comes out of
here is simply not a function

1136
01:00:21,409 --> 01:00:24,170
of the stream going in here and
the stream going in here.

1137
01:00:24,170 --> 01:00:26,659
It's a function of the stream
going in here and the stream

1138
01:00:26,659 --> 01:00:29,670
going in here and some kind of
information about time, which

1139
01:00:29,670 --> 01:00:31,610
is precisely what a normal-order
language won't

1140
01:00:31,610 --> 01:00:32,860
let you say.

1141
01:00:32,860 --> 01:00:34,809


1142
01:00:34,809 --> 01:00:36,949
AUDIENCE: In order to brings
this back into a more

1143
01:00:36,949 --> 01:00:40,475
functional perspective, could we
just explicitly time stamp

1144
01:00:40,476 --> 01:00:44,390
all the inputs from Bill and
Dave and define fair merge to

1145
01:00:44,389 --> 01:00:46,400
just be the sort on
those time stamps?

1146
01:00:46,400 --> 01:00:49,150


1147
01:00:49,150 --> 01:00:49,550
PROFESSOR: Yeah, you
can do that.

1148
01:00:49,550 --> 01:00:50,600
You can do that sort of thing.

1149
01:00:50,599 --> 01:00:53,829
Another thing you could say is
imagine that really what this

1150
01:00:53,829 --> 01:00:59,069
function is, is that it does a
read every microsecond, and

1151
01:00:59,070 --> 01:01:00,110
then if there's none
there, that's

1152
01:01:00,110 --> 01:01:00,970
considered an empty one.

1153
01:01:00,969 --> 01:01:03,609
That's about equivalent
to what you said.

1154
01:01:03,610 --> 01:01:07,110
And yes, you can do that,
but that's a clg.

1155
01:01:07,110 --> 01:01:09,480
So it's not quite only
implementation

1156
01:01:09,480 --> 01:01:10,170
we're worried about.

1157
01:01:10,170 --> 01:01:12,829
We're worried about expressive
power in the language, and

1158
01:01:12,829 --> 01:01:15,630
what we're running across is a
real mismatch between what we

1159
01:01:15,630 --> 01:01:18,824
can say easily and what
we'd like to say.

1160
01:01:18,824 --> 01:01:20,789
AUDIENCE: It sounds like where
we're getting hung up with

1161
01:01:20,789 --> 01:01:23,480
that is the fact it expects one
input from both Bill and

1162
01:01:23,480 --> 01:01:26,079
Dave at the same time.

1163
01:01:26,079 --> 01:01:28,529
PROFESSOR: It's not quite one,
but it's anything you define.

1164
01:01:28,530 --> 01:01:31,000
So you can say Dave can go
twice as often, but if

1165
01:01:31,000 --> 01:01:36,110
anything you predefine, it's
not the right thing.

1166
01:01:36,110 --> 01:01:39,880
You can't decide at some
particular function of their

1167
01:01:39,880 --> 01:01:41,930
input requests.

1168
01:01:41,929 --> 01:01:44,869
Worse yet, I mean, worse yet,
there are things that even

1169
01:01:44,869 --> 01:01:47,289
merge can't do.

1170
01:01:47,289 --> 01:01:49,170
One thing you might want to do
that's even more general is

1171
01:01:49,170 --> 01:01:52,470
suddenly you add somebody else
to this bank account system.

1172
01:01:52,469 --> 01:01:56,029
You go and you add John to
this bank account system.

1173
01:01:56,030 --> 01:01:58,250
And now there's yet another
stream that's going to come

1174
01:01:58,250 --> 01:02:02,039
into the picture at some time
which we haven't prespecified.

1175
01:02:02,039 --> 01:02:04,050
So that's something even fair
merge can't do, and they're

1176
01:02:04,050 --> 01:02:05,662
things called--

1177
01:02:05,661 --> 01:02:07,219
I forget--

1178
01:02:07,219 --> 01:02:08,859
natagers or something.

1179
01:02:08,860 --> 01:02:11,789
That's a generalization of
fair merge to allow that.

1180
01:02:11,789 --> 01:02:14,139
There's a whole sort of research
discipline saying how

1181
01:02:14,139 --> 01:02:16,789
far can you push this functional
perspective by

1182
01:02:16,789 --> 01:02:19,579
adding more and more
mechanism?

1183
01:02:19,579 --> 01:02:21,469
And how far does that go before
the whole thing breaks

1184
01:02:21,469 --> 01:02:25,609
down and you might as well
been using set anyway.

1185
01:02:25,610 --> 01:02:28,960
AUDIENCE: You need to set him
up on automatic deposit.

1186
01:02:28,960 --> 01:02:39,630
[LAUGHTER]

1187
01:02:39,630 --> 01:02:40,880
PROFESSOR: OK, thank you.

1188
01:02:40,880 --> 01:03:00,115


